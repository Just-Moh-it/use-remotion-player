/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/page"],{

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/polyfills/process.js":
/*!****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/polyfills/process.js ***!
  \****************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nvar _global_process, _global_process1;\nmodule.exports = ((_global_process = __webpack_require__.g.process) == null ? void 0 : _global_process.env) && typeof ((_global_process1 = __webpack_require__.g.process) == null ? void 0 : _global_process1.env) === \"object\" ? __webpack_require__.g.process : __webpack_require__(/*! ../../compiled/process */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/process/browser.js\");\n\n//# sourceMappingURL=process.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC9wb2x5ZmlsbHMvcHJvY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EscUNBQXFDLHFCQUFNLGlGQUFpRixxQkFBTSxrRUFBa0UscUJBQU0sV0FBVyxtQkFBTyxDQUFDLHlLQUF3Qjs7QUFFclAiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjUuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3BvbHlmaWxscy9wcm9jZXNzLmpzPzA5NDciXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX2dsb2JhbF9wcm9jZXNzLCBfZ2xvYmFsX3Byb2Nlc3MxO1xubW9kdWxlLmV4cG9ydHMgPSAoKF9nbG9iYWxfcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzLmVudikgJiYgdHlwZW9mICgoX2dsb2JhbF9wcm9jZXNzMSA9IGdsb2JhbC5wcm9jZXNzKSA9PSBudWxsID8gdm9pZCAwIDogX2dsb2JhbF9wcm9jZXNzMS5lbnYpID09PSBcIm9iamVjdFwiID8gZ2xvYmFsLnByb2Nlc3MgOiByZXF1aXJlKFwiLi4vLi4vY29tcGlsZWQvcHJvY2Vzc1wiKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvY2Vzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/polyfills/process.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmohit%2Fdev%2Fopen-source%2Fuse-remotion-player%2Fpackages%2Fexample%2Fapp%2Fpage.tsx&server=false!":
/*!*********************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmohit%2Fdev%2Fopen-source%2Fuse-remotion-player%2Fpackages%2Fexample%2Fapp%2Fpage.tsx&server=false! ***!
  \*********************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/page.tsx */ \"(app-pages-browser)/./app/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGbW9oaXQlMkZkZXYlMkZvcGVuLXNvdXJjZSUyRnVzZS1yZW1vdGlvbi1wbGF5ZXIlMkZwYWNrYWdlcyUyRmV4YW1wbGUlMkZhcHAlMkZwYWdlLnRzeCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/YjU1NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9tb2hpdC9kZXYvb3Blbi1zb3VyY2UvdXNlLXJlbW90aW9uLXBsYXllci9wYWNrYWdlcy9leGFtcGxlL2FwcC9wYWdlLnRzeFwiKSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmohit%2Fdev%2Fopen-source%2Fuse-remotion-player%2Fpackages%2Fexample%2Fapp%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/page.tsx":
/*!**********************!*\
  !*** ./app/page.tsx ***!
  \**********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ HomePage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var use_remotion_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! use-remotion-player */ \"(app-pages-browser)/../use-remotion-player/dist/index.mjs\");\n/* harmony import */ var _remotion_Test__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../remotion/Test */ \"(app-pages-browser)/./remotion/Test.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \n\n\n\nfunction HomePage() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(use_remotion_player__WEBPACK_IMPORTED_MODULE_2__.CustomizablePlayer, {\n            controls: true,\n            component: _remotion_Test__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n            durationInFrames: 30 * 5,\n            compositionHeight: 1920,\n            compositionWidth: 1080,\n            fps: 30,\n            style: {\n                width: 200\n            },\n            onPlay: console.log,\n            onPause: console.log\n        }, void 0, false, {\n            fileName: \"/Users/mohit/dev/open-source/use-remotion-player/packages/example/app/page.tsx\",\n            lineNumber: 10,\n            columnNumber: 7\n        }, this)\n    }, void 0, false);\n}\n_c = HomePage;\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9wYWdlLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBRTBCO0FBQytCO0FBQ3JCO0FBRXJCLFNBQVNHO0lBQ3RCLHFCQUNFO2tCQUNFLDRFQUFDRixtRUFBa0JBO1lBQ2pCRyxRQUFRO1lBQ1JDLFdBQVdILHNEQUFJQTtZQUNmSSxrQkFBa0IsS0FBSztZQUN2QkMsbUJBQW1CO1lBQ25CQyxrQkFBa0I7WUFDbEJDLEtBQUs7WUFDTEMsT0FBTztnQkFBRUMsT0FBTztZQUFJO1lBQ3BCQyxRQUFRQyxRQUFRQyxHQUFHO1lBQ25CQyxTQUFTRixRQUFRQyxHQUFHOzs7Ozs7O0FBSTVCO0tBaEJ3QlgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3BhZ2UudHN4Pzc2MDMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5cbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEN1c3RvbWl6YWJsZVBsYXllciB9IGZyb20gXCJ1c2UtcmVtb3Rpb24tcGxheWVyXCI7XG5pbXBvcnQgVGVzdCBmcm9tIFwiLi4vcmVtb3Rpb24vVGVzdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIb21lUGFnZSgpIHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEN1c3RvbWl6YWJsZVBsYXllclxuICAgICAgICBjb250cm9sc1xuICAgICAgICBjb21wb25lbnQ9e1Rlc3R9XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM9ezMwICogNX1cbiAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ9ezE5MjB9XG4gICAgICAgIGNvbXBvc2l0aW9uV2lkdGg9ezEwODB9XG4gICAgICAgIGZwcz17MzB9XG4gICAgICAgIHN0eWxlPXt7IHdpZHRoOiAyMDAgfX1cbiAgICAgICAgb25QbGF5PXtjb25zb2xlLmxvZ31cbiAgICAgICAgb25QYXVzZT17Y29uc29sZS5sb2d9XG4gICAgICAvPlxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ3VzdG9taXphYmxlUGxheWVyIiwiVGVzdCIsIkhvbWVQYWdlIiwiY29udHJvbHMiLCJjb21wb25lbnQiLCJkdXJhdGlvbkluRnJhbWVzIiwiY29tcG9zaXRpb25IZWlnaHQiLCJjb21wb3NpdGlvbldpZHRoIiwiZnBzIiwic3R5bGUiLCJ3aWR0aCIsIm9uUGxheSIsImNvbnNvbGUiLCJsb2ciLCJvblBhdXNlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./remotion/Test.tsx":
/*!***************************!*\
  !*** ./remotion/Test.tsx ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Test; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nfunction Test() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n        children: \"Hello world\"\n    }, void 0, false, {\n        fileName: \"/Users/mohit/dev/open-source/use-remotion-player/packages/example/remotion/Test.tsx\",\n        lineNumber: 2,\n        columnNumber: 10\n    }, this);\n}\n_c = Test;\nvar _c;\n$RefreshReg$(_c, \"Test\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3JlbW90aW9uL1Rlc3QudHN4IiwibWFwcGluZ3MiOiI7Ozs7OztBQUFlLFNBQVNBO0lBQ3RCLHFCQUFPLDhEQUFDQztrQkFBRzs7Ozs7O0FBQ2I7S0FGd0JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3JlbW90aW9uL1Rlc3QudHN4P2U5MGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGVzdCgpIHtcbiAgcmV0dXJuIDxoMT5IZWxsbyB3b3JsZDwvaDE+O1xufVxuIl0sIm5hbWVzIjpbIlRlc3QiLCJoMSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./remotion/Test.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/process/browser.js":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/process/browser.js ***!
  \*****************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={229:function(e){var t=e.exports={};var r;var n;function defaultSetTimout(){throw new Error(\"setTimeout has not been defined\")}function defaultClearTimeout(){throw new Error(\"clearTimeout has not been defined\")}(function(){try{if(typeof setTimeout===\"function\"){r=setTimeout}else{r=defaultSetTimout}}catch(e){r=defaultSetTimout}try{if(typeof clearTimeout===\"function\"){n=clearTimeout}else{n=defaultClearTimeout}}catch(e){n=defaultClearTimeout}})();function runTimeout(e){if(r===setTimeout){return setTimeout(e,0)}if((r===defaultSetTimout||!r)&&setTimeout){r=setTimeout;return setTimeout(e,0)}try{return r(e,0)}catch(t){try{return r.call(null,e,0)}catch(t){return r.call(this,e,0)}}}function runClearTimeout(e){if(n===clearTimeout){return clearTimeout(e)}if((n===defaultClearTimeout||!n)&&clearTimeout){n=clearTimeout;return clearTimeout(e)}try{return n(e)}catch(t){try{return n.call(null,e)}catch(t){return n.call(this,e)}}}var i=[];var o=false;var u;var a=-1;function cleanUpNextTick(){if(!o||!u){return}o=false;if(u.length){i=u.concat(i)}else{a=-1}if(i.length){drainQueue()}}function drainQueue(){if(o){return}var e=runTimeout(cleanUpNextTick);o=true;var t=i.length;while(t){u=i;i=[];while(++a<t){if(u){u[a].run()}}a=-1;t=i.length}u=null;o=false;runClearTimeout(e)}t.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1){for(var r=1;r<arguments.length;r++){t[r-1]=arguments[r]}}i.push(new Item(e,t));if(i.length===1&&!o){runTimeout(drainQueue)}};function Item(e,t){this.fun=e;this.array=t}Item.prototype.run=function(){this.fun.apply(null,this.array)};t.title=\"browser\";t.browser=true;t.env={};t.argv=[];t.version=\"\";t.versions={};function noop(){}t.on=noop;t.addListener=noop;t.once=noop;t.off=noop;t.removeListener=noop;t.removeAllListeners=noop;t.emit=noop;t.prependListener=noop;t.prependOnceListener=noop;t.listeners=function(e){return[]};t.binding=function(e){throw new Error(\"process.binding is not supported\")};t.cwd=function(){return\"/\"};t.chdir=function(e){throw new Error(\"process.chdir is not supported\")};t.umask=function(){return 0}}};var t={};function __nccwpck_require__(r){var n=t[r];if(n!==undefined){return n.exports}var i=t[r]={exports:{}};var o=true;try{e[r](i,i.exports,__nccwpck_require__);o=false}finally{if(o)delete t[r]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var r=__nccwpck_require__(229);module.exports=r})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxnQkFBZ0IsbUJBQW1CLE1BQU0sTUFBTSw0QkFBNEIsbURBQW1ELCtCQUErQixxREFBcUQsWUFBWSxJQUFJLG1DQUFtQyxhQUFhLEtBQUssb0JBQW9CLFNBQVMsbUJBQW1CLElBQUkscUNBQXFDLGVBQWUsS0FBSyx1QkFBdUIsU0FBUyx1QkFBdUIsSUFBSSx1QkFBdUIsbUJBQW1CLHVCQUF1QiwyQ0FBMkMsYUFBYSx1QkFBdUIsSUFBSSxjQUFjLFNBQVMsSUFBSSx3QkFBd0IsU0FBUywwQkFBMEIsNEJBQTRCLHFCQUFxQix1QkFBdUIsZ0RBQWdELGVBQWUsdUJBQXVCLElBQUksWUFBWSxTQUFTLElBQUksc0JBQXNCLFNBQVMsd0JBQXdCLFNBQVMsWUFBWSxNQUFNLFNBQVMsMkJBQTJCLFdBQVcsT0FBTyxRQUFRLGFBQWEsY0FBYyxLQUFLLEtBQUssYUFBYSxjQUFjLHNCQUFzQixNQUFNLE9BQU8sa0NBQWtDLE9BQU8sZUFBZSxTQUFTLElBQUksS0FBSyxhQUFhLE1BQU0sWUFBWSxLQUFLLFdBQVcsT0FBTyxRQUFRLG1CQUFtQix1QkFBdUIsb0NBQW9DLHVCQUF1QixZQUFZLG1CQUFtQixLQUFLLHFCQUFxQixzQkFBc0IscUJBQXFCLHlCQUF5QixtQkFBbUIsV0FBVyxhQUFhLDhCQUE4QixpQ0FBaUMsa0JBQWtCLGVBQWUsU0FBUyxVQUFVLGFBQWEsY0FBYyxpQkFBaUIsVUFBVSxtQkFBbUIsWUFBWSxXQUFXLHNCQUFzQiwwQkFBMEIsWUFBWSx1QkFBdUIsMkJBQTJCLHdCQUF3QixVQUFVLHNCQUFzQixxREFBcUQsaUJBQWlCLFdBQVcsb0JBQW9CLG1EQUFtRCxtQkFBbUIsWUFBWSxTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSywrQkFBK0IsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wcm9jZXNzL2Jyb3dzZXIuanM/YjFiZiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXt2YXIgZT17MjI5OmZ1bmN0aW9uKGUpe3ZhciB0PWUuZXhwb3J0cz17fTt2YXIgcjt2YXIgbjtmdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0KCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfShmdW5jdGlvbigpe3RyeXtpZih0eXBlb2Ygc2V0VGltZW91dD09PVwiZnVuY3Rpb25cIil7cj1zZXRUaW1lb3V0fWVsc2V7cj1kZWZhdWx0U2V0VGltb3V0fX1jYXRjaChlKXtyPWRlZmF1bHRTZXRUaW1vdXR9dHJ5e2lmKHR5cGVvZiBjbGVhclRpbWVvdXQ9PT1cImZ1bmN0aW9uXCIpe249Y2xlYXJUaW1lb3V0fWVsc2V7bj1kZWZhdWx0Q2xlYXJUaW1lb3V0fX1jYXRjaChlKXtuPWRlZmF1bHRDbGVhclRpbWVvdXR9fSkoKTtmdW5jdGlvbiBydW5UaW1lb3V0KGUpe2lmKHI9PT1zZXRUaW1lb3V0KXtyZXR1cm4gc2V0VGltZW91dChlLDApfWlmKChyPT09ZGVmYXVsdFNldFRpbW91dHx8IXIpJiZzZXRUaW1lb3V0KXtyPXNldFRpbWVvdXQ7cmV0dXJuIHNldFRpbWVvdXQoZSwwKX10cnl7cmV0dXJuIHIoZSwwKX1jYXRjaCh0KXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLGUsMCl9Y2F0Y2godCl7cmV0dXJuIHIuY2FsbCh0aGlzLGUsMCl9fX1mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQoZSl7aWYobj09PWNsZWFyVGltZW91dCl7cmV0dXJuIGNsZWFyVGltZW91dChlKX1pZigobj09PWRlZmF1bHRDbGVhclRpbWVvdXR8fCFuKSYmY2xlYXJUaW1lb3V0KXtuPWNsZWFyVGltZW91dDtyZXR1cm4gY2xlYXJUaW1lb3V0KGUpfXRyeXtyZXR1cm4gbihlKX1jYXRjaCh0KXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLGUpfWNhdGNoKHQpe3JldHVybiBuLmNhbGwodGhpcyxlKX19fXZhciBpPVtdO3ZhciBvPWZhbHNlO3ZhciB1O3ZhciBhPS0xO2Z1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpe2lmKCFvfHwhdSl7cmV0dXJufW89ZmFsc2U7aWYodS5sZW5ndGgpe2k9dS5jb25jYXQoaSl9ZWxzZXthPS0xfWlmKGkubGVuZ3RoKXtkcmFpblF1ZXVlKCl9fWZ1bmN0aW9uIGRyYWluUXVldWUoKXtpZihvKXtyZXR1cm59dmFyIGU9cnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO289dHJ1ZTt2YXIgdD1pLmxlbmd0aDt3aGlsZSh0KXt1PWk7aT1bXTt3aGlsZSgrK2E8dCl7aWYodSl7dVthXS5ydW4oKX19YT0tMTt0PWkubGVuZ3RofXU9bnVsbDtvPWZhbHNlO3J1bkNsZWFyVGltZW91dChlKX10Lm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoLTEpO2lmKGFyZ3VtZW50cy5sZW5ndGg+MSl7Zm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl7dFtyLTFdPWFyZ3VtZW50c1tyXX19aS5wdXNoKG5ldyBJdGVtKGUsdCkpO2lmKGkubGVuZ3RoPT09MSYmIW8pe3J1blRpbWVvdXQoZHJhaW5RdWV1ZSl9fTtmdW5jdGlvbiBJdGVtKGUsdCl7dGhpcy5mdW49ZTt0aGlzLmFycmF5PXR9SXRlbS5wcm90b3R5cGUucnVuPWZ1bmN0aW9uKCl7dGhpcy5mdW4uYXBwbHkobnVsbCx0aGlzLmFycmF5KX07dC50aXRsZT1cImJyb3dzZXJcIjt0LmJyb3dzZXI9dHJ1ZTt0LmVudj17fTt0LmFyZ3Y9W107dC52ZXJzaW9uPVwiXCI7dC52ZXJzaW9ucz17fTtmdW5jdGlvbiBub29wKCl7fXQub249bm9vcDt0LmFkZExpc3RlbmVyPW5vb3A7dC5vbmNlPW5vb3A7dC5vZmY9bm9vcDt0LnJlbW92ZUxpc3RlbmVyPW5vb3A7dC5yZW1vdmVBbGxMaXN0ZW5lcnM9bm9vcDt0LmVtaXQ9bm9vcDt0LnByZXBlbmRMaXN0ZW5lcj1ub29wO3QucHJlcGVuZE9uY2VMaXN0ZW5lcj1ub29wO3QubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybltdfTt0LmJpbmRpbmc9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9O3QuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9O3QuY2hkaXI9ZnVuY3Rpb24oZSl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfTt0LnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fX07dmFyIHQ9e307ZnVuY3Rpb24gX19uY2N3cGNrX3JlcXVpcmVfXyhyKXt2YXIgbj10W3JdO2lmKG4hPT11bmRlZmluZWQpe3JldHVybiBuLmV4cG9ydHN9dmFyIGk9dFtyXT17ZXhwb3J0czp7fX07dmFyIG89dHJ1ZTt0cnl7ZVtyXShpLGkuZXhwb3J0cyxfX25jY3dwY2tfcmVxdWlyZV9fKTtvPWZhbHNlfWZpbmFsbHl7aWYobylkZWxldGUgdFtyXX1yZXR1cm4gaS5leHBvcnRzfWlmKHR5cGVvZiBfX25jY3dwY2tfcmVxdWlyZV9fIT09XCJ1bmRlZmluZWRcIilfX25jY3dwY2tfcmVxdWlyZV9fLmFiPV9fZGlybmFtZStcIi9cIjt2YXIgcj1fX25jY3dwY2tfcmVxdWlyZV9fKDIyOSk7bW9kdWxlLmV4cG9ydHM9cn0pKCk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/process/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV = jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLHVLQUEwQjs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLGVBQWU7QUFDaEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUixrREFBa0Q7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0EscUNBQXFDOztBQUVyQyxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkLFdBQVcsZUFBZTtBQUMxQixXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNERBQTREO0FBQzVEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLDhDQUE4QyxnREFBZ0QsTUFBTSxhQUFhOztBQUVqSDtBQUNBLCtDQUErQyxrQ0FBa0MsT0FBTzs7QUFFeEYsdUdBQXVHLGNBQWMsVUFBVSxnR0FBZ0csa0JBQWtCLFVBQVUsVUFBVTs7QUFFclE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxnQkFBZ0I7QUFDaEIsY0FBYztBQUNkLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNS40X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz85ZWZkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNlcnZlcl9jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9DQUNIRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY2FjaGUnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCdlcnJvcicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGl0ZW0pO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGVuYWJsZVNjb3BlQVBJID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBDcmVhdGUgRXZlbnQgSGFuZGxlIEFQSS5cbnZhciBlbmFibGVDYWNoZUVsZW1lbnQgPSBmYWxzZTtcbnZhciBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyA9IGZhbHNlOyAvLyBObyBrbm93biBidWdzLCBidXQgbmVlZHMgcGVyZm9ybWFuY2UgdGVzdGluZ1xuXG52YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7IC8vIEVuYWJsZXMgdW5zdGFibGVfYXZvaWRUaGlzRmFsbGJhY2sgZmVhdHVyZSBpbiBGaWJlclxuLy8gc3R1ZmYuIEludGVuZGVkIHRvIGVuYWJsZSBSZWFjdCBjb3JlIG1lbWJlcnMgdG8gbW9yZSBlYXNpbHkgZGVidWcgc2NoZWR1bGluZ1xuLy8gaXNzdWVzIGluIERFViBidWlsZHMuXG5cbnZhciBlbmFibGVEZWJ1Z1RyYWNpbmcgPSBmYWxzZTsgLy8gVHJhY2sgd2hpY2ggRmliZXIocykgc2NoZWR1bGUgcmVuZGVyIHdvcmsuXG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgLy8gSG9zdCByb290LCB0ZXh0IG5vZGUgb3IganVzdCBpbnZhbGlkIHR5cGUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVycm9yKCdSZWNlaXZlZCBhbiB1bmV4cGVjdGVkIG9iamVjdCBpbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBSRUFDVF9DQUNIRV9UWVBFOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJ0NhY2hlJztcbiAgICAgIH1cblxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfU0VSVkVSX0NPTlRFWFRfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250ZXh0MiA9IHR5cGU7XG4gICAgICAgICAgcmV0dXJuIChjb250ZXh0Mi5kaXNwbGF5TmFtZSB8fCBjb250ZXh0Mi5fZ2xvYmFsTmFtZSkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICBpZiAocHJlZml4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEV4dHJhY3QgdGhlIFZNIHNwZWNpZmljIHByZWZpeCB1c2VkIGJ5IGVhY2ggbGluZS5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8ICcnO1xuICAgICAgfVxuICAgIH0gLy8gV2UgdXNlIHRoZSBwcmVmaXggdG8gZW5zdXJlIG91ciBzdGFja3MgbGluZSB1cCB3aXRoIG5hdGl2ZSBzdGFjayBmcmFtZXMuXG5cblxuICAgIHJldHVybiAnXFxuJyArIHByZWZpeCArIG5hbWU7XG4gIH1cbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgIC8vIHNpbGVuY2UgdGhlIGVycm9yLlxuICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWF5YmVQcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCAmJiBzZWxmICYmIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG5mdW5jdGlvbiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTsgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9KTsgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc2VsZicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzZWxmXG4gICAgfSk7IC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc291cmNlXG4gICAgfSk7XG5cbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWJDEodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWJDEodHlwZSwgcHJvcHMsIGtleSwgc291cmNlLCBzZWxmKTsgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG5cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9IC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmcgZXJyb3JzLlxuICAgIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAgIC8vIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcblxuXG4gICAgaWYgKHZhbGlkVHlwZSkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG5cbiAgICAgIGlmIChjaGlsZHJlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChpc1N0YXRpY0NoaWxkcmVuKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2ldLCB0eXBlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVycm9yKCdSZWFjdC5qc3g6IFN0YXRpYyBjaGlsZHJlbiBzaG91bGQgYWx3YXlzIGJlIGFuIGFycmF5LiAnICsgJ1lvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gJyArICdVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywgJ2tleScpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSAvLyBUaGVzZSB0d28gZnVuY3Rpb25zIGV4aXN0IHRvIHN0aWxsIGdldCBjaGlsZCB3YXJuaW5ncyBpbiBkZXZcblxudmFyIGpzeERFViA9IGpzeFdpdGhWYWxpZGF0aW9uIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeERFViA9IGpzeERFVjtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js":
/*!*****************************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js ***!
  \*****************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe[prop-missing]\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n      // component, which we don't yet support. Attach a noop catch handler to\n      // silence the error.\n      // TODO: Implement component stacks for async client components?\n\n      if (maybePromise && typeof maybePromise.catch === 'function') {\n        maybePromise.catch(function () {});\n      }\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement$1(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement$1(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (hasOwnProperty.call(props, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(props).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n// even with the prod transform. This means that jsxDEV is purely\n// opt-in behavior for better messages but that we won't stop\n// giving you warnings if you use production apis.\n\nfunction jsxWithValidationStatic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, true);\n  }\n}\nfunction jsxWithValidationDynamic(type, props, key) {\n  {\n    return jsxWithValidation(type, props, key, false);\n  }\n}\n\nvar jsx = jsxWithValidationDynamic ; // we may want to special case jsxs internally to take advantage of static children.\n// for now we can ship identical prod functions\n\nvar jsxs = jsxWithValidationStatic ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsx = jsx;\nexports.jsxs = jsxs;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsdUtBQTBCOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0EsU0FBUztBQUNULHVCQUF1QjtBQUN2QjtBQUNBLFNBQVM7QUFDVCx1QkFBdUI7QUFDdkI7QUFDQSxTQUFTO0FBQ1Qsd0JBQXdCO0FBQ3hCO0FBQ0EsU0FBUztBQUNULHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVCxpQ0FBaUM7QUFDakM7QUFDQSxTQUFTO0FBQ1QsMkJBQTJCO0FBQzNCO0FBQ0EsU0FB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QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQ7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIscUJBQXFCO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsOENBQThDLGdEQUFnRCxNQUFNLGFBQWE7O0FBRWpIO0FBQ0EsK0NBQStDLGtDQUFrQyxPQUFPOztBQUV4Rix1R0FBdUcsY0FBYyxVQUFVLGdHQUFnRyxrQkFBa0IsVUFBVSxVQUFVOztBQUVyUTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQztBQUNyQzs7QUFFQTs7QUFFQSxnQkFBZ0I7QUFDaEIsV0FBVztBQUNYLFlBQVk7QUFDWixHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS9uZXh0QDEzLjUuNF9yZWFjdC1kb21AMTguMi4wX3JlYWN0QDE4LjIuMC9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcz9mMmYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKFwibmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0XCIpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCBlbmFibGVEZWJ1Z1RyYWNpbmcgIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSAgfHwgZW5hYmxlQ2FjaGVFbGVtZW50ICB8fCBlbmFibGVUcmFuc2l0aW9uVHJhY2luZyApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBkaXNwbGF5TmFtZSA9IG91dGVyVHlwZS5kaXNwbGF5TmFtZTtcblxuICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gIH1cblxuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lO1xufSAvLyBLZWVwIGluIHN5bmMgd2l0aCByZWFjdC1yZWNvbmNpbGVyL2dldENvbXBvbmVudE5hbWVGcm9tRmliZXJcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn0gLy8gTm90ZSB0aGF0IHRoZSByZWNvbmNpbGVyIHBhY2thZ2Ugc2hvdWxkIGdlbmVyYWxseSBwcmVmZXIgdG8gdXNlIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoKSBpbnN0ZWFkLlxuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIFJFQUNUX0NBQ0hFX1RZUEU6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAnQ2FjaGUnO1xuICAgICAgfVxuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoY29udGV4dCkgKyAnLkNvbnN1bWVyJztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRleHQyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gKGNvbnRleHQyLmRpc3BsYXlOYW1lIHx8IGNvbnRleHQyLl9nbG9iYWxOYW1lKSArICcuUHJvdmlkZXInO1xuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRyb2w7XG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCAncHJvcHMnLCB7XG4gICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgd29uJ3QgdGhyb3cgaW4gYSBub24tc3RyaWN0IG1vZGUgZnVuY3Rpb24uXG4gICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAvLyBmcmFtZXMgYWRkZWQgYnkgdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICB0cnkge1xuICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoZm4sIFtdLCBGYWtlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgRmFrZS5jYWxsKCk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ10gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgLy8gdHJpZXMgdG8gYWNjZXNzIFJlYWN0L1JlYWN0RE9NL3Byb3BzLiBXZSBzaG91bGQgcHJvYmFibHkgbWFrZSB0aGlzIHRocm93XG4gICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgIC8vIGNvbXBvbmVudCwgd2hpY2ggd2UgZG9uJ3QgeWV0IHN1cHBvcnQuIEF0dGFjaCBhIG5vb3AgY2F0Y2ggaGFuZGxlciB0b1xuICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgIGlmIChtYXliZVByb21pc2UgJiYgdHlwZW9mIG1heWJlUHJvbWlzZS5jYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBlbGVtZW50KSB7XG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIFRoaXMgaXMgb2theSBidXQgRmxvdyBkb2Vzbid0IGtub3cgaXQuXG4gICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG5cbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAoaGFzKHR5cGVTcGVjcywgdHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IkMSA9IHZvaWQgMDsgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yJDEubWVzc2FnZV0gPSB0cnVlO1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpO1xuICAgIH0gLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuXG5cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG5cblxuICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG5cbiAgICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5IHx8IHJlZikge1xuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCwgcHJvcHMpO1xuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG5cbntcbiAgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24gPSBmYWxzZTtcbn1cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgUmVhY3RFbGVtZW50LlxuICogQGZpbmFsXG4gKi9cblxuXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB7XG4gICAgaWYgKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKSB7XG4gIHtcbiAgICBpZiAoc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgICB9XG5cbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG5cblxudmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKTtcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlOyAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cbiAgICB2YXIgY2hpbGRPd25lciA9ICcnO1xuXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpICsgXCIuXCI7XG4gICAgfVxuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2Ygbm9kZSAhPT0gJ29iamVjdCcgfHwgIW5vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkgOyBlbHNlIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcblxuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgICAgLy8gYnV0IG5vdyB3ZSBwcmludCBhIHNlcGFyYXRlIHdhcm5pbmcgZm9yIHRoZW0gbGF0ZXIuXG4gICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCwgdmFsaWRhdGUgdGhhdCBpdHMgcHJvcHMgZm9sbG93IHRoZSBwcm9wVHlwZXMgZGVmaW5pdGlvbixcbiAqIHByb3ZpZGVkIGJ5IHRoZSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmICh0eXBlID09PSBudWxsIHx8IHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwcm9wVHlwZXM7XG5cbiAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIE5vdGU6IE1lbW8gb25seSBjaGVja3Mgb3V0ZXIgcHJvcHMgaGVyZS5cbiAgICAvLyBJbm5lciBwcm9wcyBhcmUgY2hlY2tlZCBpbiB0aGUgcmVjb25jaWxlci5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUpKSB7XG4gICAgICBwcm9wVHlwZXMgPSB0eXBlLnByb3BUeXBlcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwcm9wVHlwZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgICAgZXJyb3IoJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIF9uYW1lIHx8ICdVbmtub3duJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB0eXBlLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGEgZnJhZ21lbnQsIHZhbGlkYXRlIHRoYXQgaXQgY2FuIG9ubHkgYmUgcHJvdmlkZWQgd2l0aCBmcmFnbWVudCBwcm9wc1xuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGZyYWdtZW50XG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge307XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBlcnJvcignUmVhY3QuanN4OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGVTdHJpbmcsIGluZm8pO1xuICAgIH1cblxuICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7IC8vIFRoZSByZXN1bHQgY2FuIGJlIG51bGxpc2ggaWYgYSBtb2NrIG9yIGEgY3VzdG9tIGZ1bmN0aW9uIGlzIHVzZWQuXG4gICAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgICAvLyBXZSBkb24ndCB3YW50IGV4Y2VwdGlvbiBiZWhhdmlvciB0byBkaWZmZXIgYmV0d2VlbiBkZXYgYW5kIHByb2QuXG4gICAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG5cblxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuXG4gICAgICBpZiAoY2hpbGRyZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChpc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbltpXSwgdHlwZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICAgIE9iamVjdC5mcmVlemUoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gJyArICdZb3UgYXJlIGxpa2VseSBleHBsaWNpdGx5IGNhbGxpbmcgUmVhY3QuanN4cyBvciBSZWFjdC5qc3hERVYuICcgKyAnVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocHJvcHMsICdrZXknKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgcmV0dXJuIGsgIT09ICdrZXknO1xuICAgICAgfSk7XG4gICAgICB2YXIgYmVmb3JlRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7a2V5OiBzb21lS2V5LCAnICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7a2V5OiBzb21lS2V5fSc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSkge1xuICAgICAgICB2YXIgYWZ0ZXJFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3snICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7fSc7XG5cbiAgICAgICAgZXJyb3IoJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIHsuLi5wcm9wc30gLz5cXG4nICsgJ1JlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbicgKyAnICBsZXQgcHJvcHMgPSAlcztcXG4nICsgJyAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsIGJlZm9yZUV4YW1wbGUsIGNvbXBvbmVudE5hbWUsIGFmdGVyRXhhbXBsZSwgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NvbXBvbmVudE5hbWUgKyBiZWZvcmVFeGFtcGxlXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG4vLyBldmVuIHdpdGggdGhlIHByb2QgdHJhbnNmb3JtLiBUaGlzIG1lYW5zIHRoYXQganN4REVWIGlzIHB1cmVseVxuLy8gb3B0LWluIGJlaGF2aW9yIGZvciBiZXR0ZXIgbWVzc2FnZXMgYnV0IHRoYXQgd2Ugd29uJ3Qgc3RvcFxuLy8gZ2l2aW5nIHlvdSB3YXJuaW5ncyBpZiB5b3UgdXNlIHByb2R1Y3Rpb24gYXBpcy5cblxuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICB7XG4gICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgfVxufVxuXG52YXIganN4ID0ganN4V2l0aFZhbGlkYXRpb25EeW5hbWljIDsgLy8gd2UgbWF5IHdhbnQgdG8gc3BlY2lhbCBjYXNlIGpzeHMgaW50ZXJuYWxseSB0byB0YWtlIGFkdmFudGFnZSBvZiBzdGF0aWMgY2hpbGRyZW4uXG4vLyBmb3Igbm93IHdlIGNhbiBzaGlwIGlkZW50aWNhbCBwcm9kIGZ1bmN0aW9uc1xuXG52YXIganN4cyA9IGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljIDtcblxuZXhwb3J0cy5GcmFnbWVudCA9IFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5leHBvcnRzLmpzeCA9IGpzeDtcbmV4cG9ydHMuanN4cyA9IGpzeHM7XG4gIH0pKCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!***********************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \***********************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLCtQQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL25leHRAMTMuNS40X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzPzZkZmEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js":
/*!*******************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js ***!
  \*******************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-runtime.development.js */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtcnVudGltZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixJQUFJLEtBQXFDLEVBQUUsRUFFMUMsQ0FBQztBQUNGLEVBQUUsdVBBQWtFO0FBQ3BFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vbmV4dEAxMy41LjRfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtcnVudGltZS5qcz9mYjk3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/@remotion+player@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/@remotion/player/dist/esm/index.mjs":
/*!***************************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@remotion+player@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/@remotion/player/dist/esm/index.mjs ***!
  \***************************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Player: function() { return /* binding */ Player; },\n/* harmony export */   PlayerInternals: function() { return /* binding */ PlayerInternals; },\n/* harmony export */   Thumbnail: function() { return /* binding */ Thumbnail; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var remotion__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! remotion */ \"(app-pages-browser)/../../node_modules/.pnpm/remotion@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/remotion/dist/esm/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n\"use client\";\n\n\n\n\nconst calculatePlayerSize = ({ currentSize, width, height, compositionWidth, compositionHeight, }) => {\n    if (width !== undefined && height === undefined) {\n        return {\n            aspectRatio: [compositionWidth, compositionHeight].join('/'),\n        };\n    }\n    // Opposite: If has height specified, evaluate the height and specify a default width.\n    if (height !== undefined && width === undefined) {\n        return {\n            // Aspect ratio CSS prop will work\n            aspectRatio: [compositionWidth, compositionHeight].join('/'),\n        };\n    }\n    if (!currentSize) {\n        return {\n            width: compositionWidth,\n            height: compositionHeight,\n        };\n    }\n    return {\n        width: compositionWidth,\n        height: compositionHeight,\n    };\n};\n\nconst calculateScale = ({ canvasSize, compositionHeight, compositionWidth, previewSize, }) => {\n    const heightRatio = canvasSize.height / compositionHeight;\n    const widthRatio = canvasSize.width / compositionWidth;\n    const ratio = Math.min(heightRatio, widthRatio);\n    return previewSize === 'auto' ? ratio : Number(previewSize);\n};\nconst calculateCanvasTransformation = ({ previewSize, compositionWidth, compositionHeight, canvasSize, }) => {\n    const scale = calculateScale({\n        canvasSize,\n        compositionHeight,\n        compositionWidth,\n        previewSize,\n    });\n    const correction = 0 - (1 - scale) / 2;\n    const xCorrection = correction * compositionWidth;\n    const yCorrection = correction * compositionHeight;\n    const width = compositionWidth * scale;\n    const height = compositionHeight * scale;\n    const centerX = canvasSize.width / 2 - width / 2;\n    const centerY = canvasSize.height / 2 - height / 2;\n    return {\n        centerX,\n        centerY,\n        xCorrection,\n        yCorrection,\n        scale,\n    };\n};\nconst calculateOuterStyle = ({ config, style, canvasSize, }) => {\n    if (!config) {\n        return {};\n    }\n    return {\n        position: 'relative',\n        overflow: 'hidden',\n        ...calculatePlayerSize({\n            compositionHeight: config.height,\n            compositionWidth: config.width,\n            currentSize: canvasSize,\n            height: style === null || style === void 0 ? void 0 : style.height,\n            width: style === null || style === void 0 ? void 0 : style.width,\n        }),\n        ...style,\n    };\n};\nconst calculateContainerStyle = ({ config, canvasSize, layout, scale, }) => {\n    if (!config || !canvasSize || !layout) {\n        return {};\n    }\n    return {\n        position: 'absolute',\n        width: config.width,\n        height: config.height,\n        display: 'flex',\n        transform: `scale(${scale})`,\n        marginLeft: layout.xCorrection,\n        marginTop: layout.yCorrection,\n        overflow: 'hidden',\n    };\n};\nconst calculateOuter = ({ layout, scale, config, }) => {\n    if (!layout || !config) {\n        return {};\n    }\n    const { centerX, centerY } = layout;\n    return {\n        width: config.width * scale,\n        height: config.height * scale,\n        display: 'flex',\n        flexDirection: 'column',\n        position: 'absolute',\n        left: centerX,\n        top: centerY,\n        overflow: 'hidden',\n    };\n};\n\nconst PlayerEventEmitterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\nconst ThumbnailEmitterContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(undefined);\n\nclass PlayerEmitter {\n    constructor() {\n        this.listeners = {\n            ended: [],\n            error: [],\n            pause: [],\n            play: [],\n            ratechange: [],\n            scalechange: [],\n            seeked: [],\n            timeupdate: [],\n            frameupdate: [],\n            fullscreenchange: [],\n            volumechange: [],\n            mutechange: [],\n        };\n    }\n    addEventListener(name, callback) {\n        this.listeners[name].push(callback);\n    }\n    removeEventListener(name, callback) {\n        this.listeners[name] = this.listeners[name].filter((l) => l !== callback);\n    }\n    dispatchEvent(dispatchName, context) {\n        this.listeners[dispatchName].forEach((callback) => {\n            callback({ detail: context });\n        });\n    }\n    dispatchSeek(frame) {\n        this.dispatchEvent('seeked', {\n            frame,\n        });\n    }\n    dispatchVolumeChange(volume) {\n        this.dispatchEvent('volumechange', {\n            volume,\n        });\n    }\n    dispatchPause() {\n        this.dispatchEvent('pause', undefined);\n    }\n    dispatchPlay() {\n        this.dispatchEvent('play', undefined);\n    }\n    dispatchEnded() {\n        this.dispatchEvent('ended', undefined);\n    }\n    dispatchRateChange(playbackRate) {\n        this.dispatchEvent('ratechange', {\n            playbackRate,\n        });\n    }\n    dispatchScaleChange(scale) {\n        this.dispatchEvent('scalechange', {\n            scale,\n        });\n    }\n    dispatchError(error) {\n        this.dispatchEvent('error', {\n            error,\n        });\n    }\n    dispatchTimeUpdate(event) {\n        this.dispatchEvent('timeupdate', event);\n    }\n    dispatchFrameUpdate(event) {\n        this.dispatchEvent('frameupdate', event);\n    }\n    dispatchFullscreenChange(event) {\n        this.dispatchEvent('fullscreenchange', event);\n    }\n    dispatchMuteChange(event) {\n        this.dispatchEvent('mutechange', event);\n    }\n}\nclass ThumbnailEmitter {\n    constructor() {\n        this.listeners = {\n            error: [],\n        };\n    }\n    addEventListener(name, callback) {\n        this.listeners[name].push(callback);\n    }\n    removeEventListener(name, callback) {\n        this.listeners[name] = this.listeners[name].filter((l) => l !== callback);\n    }\n    dispatchEvent(dispatchName, context) {\n        this.listeners[dispatchName].forEach((callback) => {\n            callback({ detail: context });\n        });\n    }\n    dispatchError(error) {\n        this.dispatchEvent('error', {\n            error,\n        });\n    }\n}\n\nconst useHoverState = (ref) => {\n    const [hovered, stetHovered] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const { current } = ref;\n        if (!current) {\n            return;\n        }\n        const onHover = () => {\n            stetHovered(true);\n        };\n        const onLeave = () => {\n            stetHovered(false);\n        };\n        current.addEventListener('mouseenter', onHover);\n        current.addEventListener('mouseleave', onLeave);\n        return () => {\n            current.removeEventListener('mouseenter', onHover);\n            current.removeEventListener('mouseenter', onLeave);\n        };\n    }, [ref]);\n    return hovered;\n};\n\nconst calculateNextFrame = ({ time, currentFrame: startFrame, playbackSpeed, fps, actualLastFrame, actualFirstFrame, framesAdvanced, shouldLoop, }) => {\n    const op = playbackSpeed < 0 ? Math.ceil : Math.floor;\n    const framesToAdvance = op((time * playbackSpeed) / (1000 / fps)) - framesAdvanced;\n    const nextFrame = framesToAdvance + startFrame;\n    const isCurrentFrameOutside = startFrame > actualLastFrame || startFrame < actualFirstFrame;\n    const isNextFrameOutside = nextFrame > actualLastFrame || nextFrame < actualFirstFrame;\n    const hasEnded = !shouldLoop && isNextFrameOutside && !isCurrentFrameOutside;\n    if (playbackSpeed > 0) {\n        // Play forwards\n        if (isNextFrameOutside) {\n            return {\n                nextFrame: actualFirstFrame,\n                framesToAdvance,\n                hasEnded,\n            };\n        }\n        return { nextFrame, framesToAdvance, hasEnded };\n    }\n    // Reverse playback\n    if (isNextFrameOutside) {\n        return { nextFrame: actualLastFrame, framesToAdvance, hasEnded };\n    }\n    return { nextFrame, framesToAdvance, hasEnded };\n};\n\nconst getIsBackgrounded = () => {\n    if (typeof document === 'undefined') {\n        return false;\n    }\n    return document.visibilityState === 'hidden';\n};\nconst useIsBackgrounded = () => {\n    const isBackgrounded = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(getIsBackgrounded());\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const onVisibilityChange = () => {\n            isBackgrounded.current = getIsBackgrounded();\n        };\n        document.addEventListener('visibilitychange', onVisibilityChange);\n        return () => {\n            document.removeEventListener('visibilitychange', onVisibilityChange);\n        };\n    }, []);\n    return isBackgrounded;\n};\n\nconst usePlayer = () => {\n    var _a;\n    const [playing, setPlaying, imperativePlaying] = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.usePlayingState();\n    const [hasPlayed, setHasPlayed] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const frame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelinePosition();\n    const playStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(frame);\n    const setFrame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelineSetFrame();\n    const setTimelinePosition = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelineSetFrame();\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.SharedAudioContext);\n    const { audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.TimelineContext);\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    frameRef.current = frame;\n    const video = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useVideo();\n    const config = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useUnsafeVideoConfig();\n    const emitter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PlayerEventEmitterContext);\n    const lastFrame = ((_a = config === null || config === void 0 ? void 0 : config.durationInFrames) !== null && _a !== void 0 ? _a : 1) - 1;\n    const isLastFrame = frame === lastFrame;\n    const isFirstFrame = frame === 0;\n    if (!emitter) {\n        throw new TypeError('Expected Player event emitter context');\n    }\n    const seek = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((newFrame) => {\n        if (video === null || video === void 0 ? void 0 : video.id) {\n            setTimelinePosition((c) => ({ ...c, [video.id]: newFrame }));\n        }\n        emitter.dispatchSeek(newFrame);\n    }, [emitter, setTimelinePosition, video === null || video === void 0 ? void 0 : video.id]);\n    const play = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        if (imperativePlaying.current) {\n            return;\n        }\n        setHasPlayed(true);\n        if (isLastFrame) {\n            seek(0);\n        }\n        /**\n         * Play silent audio tags to warm them up for autoplay\n         */\n        if (audioContext && audioContext.numberOfAudioTags > 0 && e) {\n            audioContext.playAllAudios();\n        }\n        /**\n         * Play audios and videos directly here so they can benefit from\n         * being triggered by a click\n         */\n        audioAndVideoTags.current.forEach((a) => a.play());\n        imperativePlaying.current = true;\n        setPlaying(true);\n        playStart.current = frameRef.current;\n        emitter.dispatchPlay();\n    }, [\n        imperativePlaying,\n        isLastFrame,\n        audioContext,\n        setPlaying,\n        emitter,\n        seek,\n        audioAndVideoTags,\n    ]);\n    const pause = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (imperativePlaying.current) {\n            imperativePlaying.current = false;\n            setPlaying(false);\n            emitter.dispatchPause();\n        }\n    }, [emitter, imperativePlaying, setPlaying]);\n    const pauseAndReturnToPlayStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (imperativePlaying.current) {\n            imperativePlaying.current = false;\n            if (config) {\n                setTimelinePosition((c) => ({\n                    ...c,\n                    [config.id]: playStart.current,\n                }));\n                setPlaying(false);\n                emitter.dispatchPause();\n            }\n        }\n    }, [config, emitter, imperativePlaying, setPlaying, setTimelinePosition]);\n    const videoId = video === null || video === void 0 ? void 0 : video.id;\n    const frameBack = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((frames) => {\n        if (!videoId) {\n            return null;\n        }\n        if (imperativePlaying.current) {\n            return;\n        }\n        setFrame((c) => {\n            var _a, _b;\n            const prev = (_b = (_a = c[videoId]) !== null && _a !== void 0 ? _a : window.remotion_initialFrame) !== null && _b !== void 0 ? _b : 0;\n            return {\n                ...c,\n                [videoId]: Math.max(0, prev - frames),\n            };\n        });\n    }, [imperativePlaying, setFrame, videoId]);\n    const frameForward = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((frames) => {\n        if (!videoId) {\n            return null;\n        }\n        if (imperativePlaying.current) {\n            return;\n        }\n        setFrame((c) => {\n            var _a, _b;\n            const prev = (_b = (_a = c[videoId]) !== null && _a !== void 0 ? _a : window.remotion_initialFrame) !== null && _b !== void 0 ? _b : 0;\n            return {\n                ...c,\n                [videoId]: Math.min(lastFrame, prev + frames),\n            };\n        });\n    }, [videoId, imperativePlaying, lastFrame, setFrame]);\n    const returnValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            frameBack,\n            frameForward,\n            isLastFrame,\n            emitter,\n            playing,\n            play,\n            pause,\n            seek,\n            isFirstFrame,\n            getCurrentFrame: () => frameRef.current,\n            isPlaying: () => imperativePlaying.current,\n            pauseAndReturnToPlayStart,\n            hasPlayed,\n        };\n    }, [\n        frameBack,\n        frameForward,\n        isLastFrame,\n        emitter,\n        playing,\n        play,\n        pause,\n        seek,\n        isFirstFrame,\n        pauseAndReturnToPlayStart,\n        imperativePlaying,\n        hasPlayed,\n    ]);\n    return returnValue;\n};\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst usePlayback = ({ loop, playbackRate, moveToBeginningWhenEnded, inFrame, outFrame, }) => {\n    const config = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useUnsafeVideoConfig();\n    const frame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelinePosition();\n    const { playing, pause, emitter } = usePlayer();\n    const setFrame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelineSetFrame();\n    // requestAnimationFrame() does not work if the tab is not active.\n    // This means that audio will keep playing even if it has ended.\n    // In that case, we use setTimeout() instead.\n    const isBackgroundedRef = useIsBackgrounded();\n    const frameRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(frame);\n    frameRef.current = frame;\n    const lastTimeUpdateEvent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!config) {\n            return;\n        }\n        if (!playing) {\n            return;\n        }\n        let hasBeenStopped = false;\n        let reqAnimFrameCall = null;\n        const startedTime = performance.now();\n        let framesAdvanced = 0;\n        const cancelQueuedFrame = () => {\n            if (reqAnimFrameCall !== null) {\n                if (reqAnimFrameCall.type === 'raf') {\n                    cancelAnimationFrame(reqAnimFrameCall.id);\n                }\n                else {\n                    clearTimeout(reqAnimFrameCall.id);\n                }\n            }\n        };\n        const stop = () => {\n            hasBeenStopped = true;\n            cancelQueuedFrame();\n        };\n        const callback = () => {\n            const time = performance.now() - startedTime;\n            const actualLastFrame = outFrame !== null && outFrame !== void 0 ? outFrame : config.durationInFrames - 1;\n            const actualFirstFrame = inFrame !== null && inFrame !== void 0 ? inFrame : 0;\n            const { nextFrame, framesToAdvance, hasEnded } = calculateNextFrame({\n                time,\n                currentFrame: frameRef.current,\n                playbackSpeed: playbackRate,\n                fps: config.fps,\n                actualFirstFrame,\n                actualLastFrame,\n                framesAdvanced,\n                shouldLoop: loop,\n            });\n            framesAdvanced += framesToAdvance;\n            if (nextFrame !== frameRef.current &&\n                (!hasEnded || moveToBeginningWhenEnded)) {\n                setFrame((c) => ({ ...c, [config.id]: nextFrame }));\n            }\n            if (hasEnded) {\n                stop();\n                pause();\n                emitter.dispatchEnded();\n                return;\n            }\n            if (!hasBeenStopped) {\n                queueNextFrame();\n            }\n        };\n        const queueNextFrame = () => {\n            if (isBackgroundedRef.current) {\n                reqAnimFrameCall = {\n                    type: 'timeout',\n                    // Note: Most likely, this will not be 1000 / fps, but the browser will throttle it to ~1/sec.\n                    id: setTimeout(callback, 1000 / config.fps),\n                };\n            }\n            else {\n                reqAnimFrameCall = { type: 'raf', id: requestAnimationFrame(callback) };\n            }\n        };\n        queueNextFrame();\n        const onVisibilityChange = () => {\n            if (document.visibilityState === 'visible') {\n                return;\n            }\n            // If tab goes into the background, cancel requestAnimationFrame() and update immediately.\n            // , so the transition to setTimeout() can be fulfilled.\n            cancelQueuedFrame();\n            callback();\n        };\n        window.addEventListener('visibilitychange', onVisibilityChange);\n        return () => {\n            window.removeEventListener('visibilitychange', onVisibilityChange);\n            stop();\n        };\n    }, [\n        config,\n        loop,\n        pause,\n        playing,\n        setFrame,\n        emitter,\n        playbackRate,\n        inFrame,\n        outFrame,\n        moveToBeginningWhenEnded,\n        isBackgroundedRef,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const interval = setInterval(() => {\n            if (lastTimeUpdateEvent.current === frameRef.current) {\n                return;\n            }\n            emitter.dispatchTimeUpdate({ frame: frameRef.current });\n            lastTimeUpdateEvent.current = frameRef.current;\n        }, 250);\n        return () => clearInterval(interval);\n    }, [emitter]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        emitter.dispatchFrameUpdate({ frame });\n    }, [emitter, frame]);\n};\n\nlet elementSizeHooks = [];\nconst updateAllElementsSizes = () => {\n    for (const listener of elementSizeHooks) {\n        listener();\n    }\n};\nconst useElementSize = (ref, options) => {\n    const [size, setSize] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n        if (!ref.current) {\n            return null;\n        }\n        const rect = ref.current.getClientRects();\n        if (!rect[0]) {\n            return null;\n        }\n        return {\n            width: rect[0].width,\n            height: rect[0].height,\n            left: rect[0].x,\n            top: rect[0].y,\n            windowSize: {\n                height: window.innerHeight,\n                width: window.innerWidth,\n            },\n        };\n    });\n    const observer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (typeof ResizeObserver === 'undefined') {\n            return null;\n        }\n        return new ResizeObserver((entries) => {\n            // The contentRect returns the width without any `scale()`'s being applied. The height is wrong\n            const { contentRect, target } = entries[0];\n            // The clientRect returns the size with `scale()` being applied.\n            const newSize = target.getClientRects();\n            if (!(newSize === null || newSize === void 0 ? void 0 : newSize[0])) {\n                setSize(null);\n                return;\n            }\n            const probableCssParentScale = contentRect.width === 0 ? 1 : newSize[0].width / contentRect.width;\n            const width = options.shouldApplyCssTransforms\n                ? newSize[0].width\n                : newSize[0].width * (1 / probableCssParentScale);\n            const height = options.shouldApplyCssTransforms\n                ? newSize[0].height\n                : newSize[0].height * (1 / probableCssParentScale);\n            setSize({\n                width,\n                height,\n                left: newSize[0].x,\n                top: newSize[0].y,\n                windowSize: {\n                    height: window.innerHeight,\n                    width: window.innerWidth,\n                },\n            });\n        });\n    }, [options.shouldApplyCssTransforms]);\n    const updateSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (!ref.current) {\n            return;\n        }\n        const rect = ref.current.getClientRects();\n        if (!rect[0]) {\n            setSize(null);\n            return;\n        }\n        setSize((prevState) => {\n            const isSame = prevState &&\n                prevState.width === rect[0].width &&\n                prevState.height === rect[0].height &&\n                prevState.left === rect[0].x &&\n                prevState.top === rect[0].y &&\n                prevState.windowSize.height === window.innerHeight &&\n                prevState.windowSize.width === window.innerWidth;\n            if (isSame) {\n                return prevState;\n            }\n            return {\n                width: rect[0].width,\n                height: rect[0].height,\n                left: rect[0].x,\n                top: rect[0].y,\n                windowSize: {\n                    height: window.innerHeight,\n                    width: window.innerWidth,\n                },\n            };\n        });\n    }, [ref]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!observer) {\n            return;\n        }\n        const { current } = ref;\n        if (ref.current) {\n            observer.observe(ref.current);\n        }\n        return () => {\n            if (current) {\n                observer.unobserve(current);\n            }\n        };\n    }, [observer, ref, updateSize]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!options.triggerOnWindowResize) {\n            return;\n        }\n        window.addEventListener('resize', updateSize);\n        return () => {\n            window.removeEventListener('resize', updateSize);\n        };\n    }, [options.triggerOnWindowResize, updateSize]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        elementSizeHooks.push(updateSize);\n        return () => {\n            elementSizeHooks = elementSizeHooks.filter((e) => e !== updateSize);\n        };\n    }, [updateSize]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!size) {\n            return null;\n        }\n        return { ...size, refresh: updateSize };\n    }, [size, updateSize]);\n};\n\nconst PLAYER_CSS_CLASSNAME = '__remotion-player';\n\nconst errorStyle = {\n    display: 'flex',\n    justifyContent: 'center',\n    alignItems: 'center',\n    flex: 1,\n    height: '100%',\n    width: '100%',\n};\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor() {\n        super(...arguments);\n        this.state = { hasError: null };\n    }\n    static getDerivedStateFromError(error) {\n        // Update state so the next render will show the fallback UI.\n        return { hasError: error };\n    }\n    componentDidCatch(error) {\n        this.props.onError(error);\n    }\n    render() {\n        if (this.state.hasError) {\n            // You can render any custom fallback UI\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: errorStyle, children: this.props.errorFallback({\n                    error: this.state.hasError,\n                }) }));\n        }\n        return this.props.children;\n    }\n}\n\nconst formatTime = (timeInSeconds) => {\n    const minutes = Math.floor(timeInSeconds / 60);\n    const seconds = Math.floor(timeInSeconds - minutes * 60);\n    return `${String(minutes)}:${String(seconds).padStart(2, '0')}`;\n};\n\nconst ICON_SIZE = 25;\nconst fullscreenIconSize = 16;\nconst PlayIcon = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", { width: ICON_SIZE, height: ICON_SIZE, viewBox: \"0 0 25 25\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: \"M8 6.375C7.40904 8.17576 7.06921 10.2486 7.01438 12.3871C6.95955 14.5255 7.19163 16.6547 7.6875 18.5625C9.95364 18.2995 12.116 17.6164 14.009 16.5655C15.902 15.5147 17.4755 14.124 18.6088 12.5C17.5158 10.8949 15.9949 9.51103 14.1585 8.45082C12.3222 7.3906 10.2174 6.68116 8 6.375Z\", fill: \"white\", stroke: \"white\", strokeWidth: \"6.25\", strokeLinejoin: \"round\" }) }));\n};\nconst PauseIcon = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"svg\", { viewBox: \"0 0 100 100\", width: ICON_SIZE, height: ICON_SIZE, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"rect\", { x: \"25\", y: \"20\", width: \"20\", height: \"60\", fill: \"#fff\", ry: \"5\", rx: \"5\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"rect\", { x: \"55\", y: \"20\", width: \"20\", height: \"60\", fill: \"#fff\", ry: \"5\", rx: \"5\" })] }));\n};\nconst FullscreenIcon = ({ isFullscreen, }) => {\n    const strokeWidth = 6;\n    const viewSize = 32;\n    const out = isFullscreen ? 0 : strokeWidth / 2;\n    const middleInset = isFullscreen ? strokeWidth * 1.6 : strokeWidth / 2;\n    const inset = isFullscreen ? strokeWidth * 1.6 : strokeWidth * 2;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"svg\", { viewBox: `0 0 ${viewSize} ${viewSize}`, height: fullscreenIconSize, width: fullscreenIconSize, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: `\n\t\t\t\tM ${out} ${inset}\n\t\t\t\tL ${middleInset} ${middleInset}\n\t\t\t\tL ${inset} ${out}\n\t\t\t\t`, stroke: \"#fff\", strokeWidth: strokeWidth, fill: \"none\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: `\n\t\t\t\tM ${viewSize - out} ${inset}\n\t\t\t\tL ${viewSize - middleInset} ${middleInset}\n\t\t\t\tL ${viewSize - inset} ${out}\n\t\t\t\t`, stroke: \"#fff\", strokeWidth: strokeWidth, fill: \"none\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: `\n\t\t\t\tM ${out} ${viewSize - inset}\n\t\t\t\tL ${middleInset} ${viewSize - middleInset}\n\t\t\t\tL ${inset} ${viewSize - out}\n\t\t\t\t`, stroke: \"#fff\", strokeWidth: strokeWidth, fill: \"none\" }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: `\n\t\t\t\tM ${viewSize - out} ${viewSize - inset}\n\t\t\t\tL ${viewSize - middleInset} ${viewSize - middleInset}\n\t\t\t\tL ${viewSize - inset} ${viewSize - out}\n\t\t\t\t`, stroke: \"#fff\", strokeWidth: strokeWidth, fill: \"none\" })] }));\n};\nconst VolumeOffIcon = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", { width: ICON_SIZE, height: ICON_SIZE, viewBox: \"0 0 24 24\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: \"M3.63 3.63a.996.996 0 000 1.41L7.29 8.7 7 9H4c-.55 0-1 .45-1 1v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71v-4.17l4.18 4.18c-.49.37-1.02.68-1.6.91-.36.15-.58.53-.58.92 0 .72.73 1.18 1.39.91.8-.33 1.55-.77 2.22-1.31l1.34 1.34a.996.996 0 101.41-1.41L5.05 3.63c-.39-.39-1.02-.39-1.42 0zM19 12c0 .82-.15 1.61-.41 2.34l1.53 1.53c.56-1.17.88-2.48.88-3.87 0-3.83-2.4-7.11-5.78-8.4-.59-.23-1.22.23-1.22.86v.19c0 .38.25.71.61.85C17.18 6.54 19 9.06 19 12zm-8.71-6.29l-.17.17L12 7.76V6.41c0-.89-1.08-1.33-1.71-.7zM16.5 12A4.5 4.5 0 0014 7.97v1.79l2.48 2.48c.01-.08.02-.16.02-.24z\", fill: \"#fff\" }) }));\n};\nconst VolumeOnIcon = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", { width: ICON_SIZE, height: ICON_SIZE, viewBox: \"0 0 24 24\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { d: \"M3 10v4c0 .55.45 1 1 1h3l3.29 3.29c.63.63 1.71.18 1.71-.71V6.41c0-.89-1.08-1.34-1.71-.71L7 9H4c-.55 0-1 .45-1 1zm13.5 2A4.5 4.5 0 0014 7.97v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 4.45v.2c0 .38.25.71.6.85C17.18 6.53 19 9.06 19 12s-1.82 5.47-4.4 6.5c-.36.14-.6.47-.6.85v.2c0 .63.63 1.07 1.21.85C18.6 19.11 21 15.84 21 12s-2.4-7.11-5.79-8.4c-.58-.23-1.21.22-1.21.85z\", fill: \"#fff\" }) }));\n};\n\nconst BAR_HEIGHT$1 = 5;\nconst KNOB_SIZE$1 = 12;\nconst VOLUME_SLIDER_WIDTH = 100;\nconst MediaVolumeSlider = ({ displayVerticalVolumeSlider }) => {\n    const [mediaMuted, setMediaMuted] = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useMediaMutedState();\n    const [mediaVolume, setMediaVolume] = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useMediaVolumeState();\n    const [focused, setFocused] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const parentDivRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const hover = useHoverState(parentDivRef);\n    // Need to import it from React to fix React 17 ESM support.\n    const randomId = \n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    typeof react__WEBPACK_IMPORTED_MODULE_0__.useId === 'undefined' ? 'volume-slider' : react__WEBPACK_IMPORTED_MODULE_0__.useId();\n    const [randomClass] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => `__remotion-volume-slider-${(0,remotion__WEBPACK_IMPORTED_MODULE_1__.random)(randomId)}`.replace('.', ''));\n    const isMutedOrZero = mediaMuted || mediaVolume === 0;\n    const onVolumeChange = (e) => {\n        setMediaVolume(parseFloat(e.target.value));\n    };\n    const onBlur = () => {\n        setTimeout(() => {\n            // We need a small delay to check which element was focused next,\n            // and if it wasn't the volume slider, we hide it\n            if (document.activeElement !== inputRef.current) {\n                setFocused(false);\n            }\n        }, 10);\n    };\n    const onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (mediaVolume === 0) {\n            setMediaVolume(1);\n            setMediaMuted(false);\n            return;\n        }\n        setMediaMuted((mute) => !mute);\n    }, [mediaVolume, setMediaMuted, setMediaVolume]);\n    const parentDivStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            display: 'inline-flex',\n            background: 'none',\n            border: 'none',\n            justifyContent: 'center',\n            alignItems: 'center',\n            touchAction: 'none',\n            ...(displayVerticalVolumeSlider && { position: 'relative' }),\n        };\n    }, [displayVerticalVolumeSlider]);\n    const volumeContainer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            display: 'inline',\n            width: ICON_SIZE,\n            height: ICON_SIZE,\n            cursor: 'pointer',\n            appearance: 'none',\n            background: 'none',\n            border: 'none',\n            padding: 0,\n        };\n    }, []);\n    const inputStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const commonStyle = {\n            WebkitAppearance: 'none',\n            backgroundColor: 'rgba(255, 255, 255, 0.5)',\n            borderRadius: BAR_HEIGHT$1 / 2,\n            cursor: 'pointer',\n            height: BAR_HEIGHT$1,\n            width: VOLUME_SLIDER_WIDTH,\n            backgroundImage: `linear-gradient(\n\t\t\t\tto right,\n\t\t\t\twhite ${mediaVolume * 100}%, rgba(255, 255, 255, 0) ${mediaVolume * 100}%\n\t\t\t)`,\n        };\n        if (displayVerticalVolumeSlider) {\n            return {\n                ...commonStyle,\n                transform: `rotate(-90deg)`,\n                position: 'absolute',\n                bottom: ICON_SIZE + VOLUME_SLIDER_WIDTH / 2 + 5,\n            };\n        }\n        return {\n            ...commonStyle,\n            marginLeft: 5,\n        };\n    }, [displayVerticalVolumeSlider, mediaVolume]);\n    const sliderStyle = `\n\t.${randomClass}::-webkit-slider-thumb {\n\t\t-webkit-appearance: none;\n\t\tbackground-color: white;\n\t\tborder-radius: ${KNOB_SIZE$1 / 2}px;\n\t\tbox-shadow: 0 0 2px black;\n\t\theight: ${KNOB_SIZE$1}px;\n\t\twidth: ${KNOB_SIZE$1}px;\n\t}\n\n\t.${randomClass}::-moz-range-thumb {\n\t\t-webkit-appearance: none;\n\t\tbackground-color: white;\n\t\tborder-radius: ${KNOB_SIZE$1 / 2}px;\n\t\tbox-shadow: 0 0 2px black;\n\t\theight: ${KNOB_SIZE$1}px;\n\t\twidth: ${KNOB_SIZE$1}px;\n\t}\n`;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: parentDivRef, style: parentDivStyle, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"style\", { \n                // eslint-disable-next-line react/no-danger\n                dangerouslySetInnerHTML: {\n                    __html: sliderStyle,\n                } }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { \"aria-label\": isMutedOrZero ? 'Unmute sound' : 'Mute sound', title: isMutedOrZero ? 'Unmute sound' : 'Mute sound', onClick: onClick, onBlur: onBlur, onFocus: () => setFocused(true), style: volumeContainer, type: \"button\", children: isMutedOrZero ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VolumeOffIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VolumeOnIcon, {}) }), (focused || hover) && !mediaMuted && !remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.isIosSafari() ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"input\", { ref: inputRef, \"aria-label\": \"Change volume\", className: randomClass, max: 1, min: 0, onBlur: () => setFocused(false), onChange: onVolumeChange, step: 0.01, type: \"range\", value: mediaVolume, style: inputStyle })) : null] }));\n};\n\n// hook to hide a popup/modal when clicked outside\nfunction useComponentVisible(initialIsVisible) {\n    const [isComponentVisible, setIsComponentVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialIsVisible);\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const handleClickOutside = (event) => {\n            if (ref.current && !ref.current.contains(event.target)) {\n                setIsComponentVisible(false);\n            }\n        };\n        document.addEventListener('pointerup', handleClickOutside, true);\n        return () => {\n            document.removeEventListener('pointerup', handleClickOutside, true);\n        };\n    }, []);\n    return { ref, isComponentVisible, setIsComponentVisible };\n}\n\n// To align\nconst BOTTOM = 35;\n// Arbitrary to clamp the height of the popup\nconst THRESHOLD = 70;\nconst rateDiv = {\n    height: 30,\n    paddingRight: 15,\n    paddingLeft: 12,\n    display: 'flex',\n    flexDirection: 'row',\n    alignItems: 'center',\n};\nconst checkmarkContainer = {\n    width: 22,\n    display: 'flex',\n    alignItems: 'center',\n};\nconst checkmarkStyle = {\n    width: 14,\n    height: 14,\n    color: 'black',\n};\nconst Checkmark = () => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"svg\", { viewBox: \"0 0 512 512\", style: checkmarkStyle, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"path\", { fill: \"currentColor\", d: \"M435.848 83.466L172.804 346.51l-96.652-96.652c-4.686-4.686-12.284-4.686-16.971 0l-28.284 28.284c-4.686 4.686-4.686 12.284 0 16.971l133.421 133.421c4.686 4.686 12.284 4.686 16.971 0l299.813-299.813c4.686-4.686 4.686-12.284 0-16.971l-28.284-28.284c-4.686-4.686-12.284-4.686-16.97 0z\" }) }));\nconst PlaybackrateOption = ({ rate, onSelect, selectedRate, keyboardSelectedRate }) => {\n    const onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        onSelect(rate);\n    }, [onSelect, rate]);\n    const [hovered, setHovered] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const onMouseEnter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setHovered(true);\n    }, []);\n    const onMouseLeave = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setHovered(false);\n    }, []);\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            ...rateDiv,\n            backgroundColor: hovered || keyboardSelectedRate === rate ? '#eee' : 'transparent',\n        };\n    }, [hovered, keyboardSelectedRate, rate]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, tabIndex: 0, style: actualStyle, onClick: onClick, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: checkmarkContainer, children: rate === selectedRate ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Checkmark, {}) : null }), rate.toFixed(1), \"x\"] }, rate));\n};\nconst PlaybackPopup = ({ setIsComponentVisible, playbackRates, canvasSize }) => {\n    const { setPlaybackRate, playbackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.TimelineContext);\n    const [keyboardSelectedRate, setKeyboardSelectedRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(playbackRate);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const listener = (e) => {\n            e.preventDefault();\n            if (e.key === 'ArrowUp') {\n                const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);\n                if (currentIndex === 0) {\n                    return;\n                }\n                if (currentIndex === -1) {\n                    setKeyboardSelectedRate(playbackRates[0]);\n                }\n                else {\n                    setKeyboardSelectedRate(playbackRates[currentIndex - 1]);\n                }\n            }\n            else if (e.key === 'ArrowDown') {\n                const currentIndex = playbackRates.findIndex((rate) => rate === keyboardSelectedRate);\n                if (currentIndex === playbackRates.length - 1) {\n                    return;\n                }\n                if (currentIndex === -1) {\n                    setKeyboardSelectedRate(playbackRates[playbackRates.length - 1]);\n                }\n                else {\n                    setKeyboardSelectedRate(playbackRates[currentIndex + 1]);\n                }\n            }\n            else if (e.key === 'Enter') {\n                setPlaybackRate(keyboardSelectedRate);\n                setIsComponentVisible(false);\n            }\n        };\n        window.addEventListener('keydown', listener);\n        return () => {\n            window.removeEventListener('keydown', listener);\n        };\n    }, [\n        playbackRates,\n        keyboardSelectedRate,\n        setPlaybackRate,\n        setIsComponentVisible,\n    ]);\n    const onSelect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((rate) => {\n        setPlaybackRate(rate);\n        setIsComponentVisible(false);\n    }, [setIsComponentVisible, setPlaybackRate]);\n    const playbackPopup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            position: 'absolute',\n            right: 0,\n            width: 125,\n            maxHeight: canvasSize.height - THRESHOLD - BOTTOM,\n            bottom: 35,\n            background: '#fff',\n            borderRadius: 4,\n            overflow: 'auto',\n            color: 'black',\n            textAlign: 'left',\n        };\n    }, [canvasSize.height]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: playbackPopup, children: playbackRates.map((rate) => {\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlaybackrateOption, { selectedRate: playbackRate, onSelect: onSelect, rate: rate, keyboardSelectedRate: keyboardSelectedRate }, rate));\n        }) }));\n};\nconst label = {\n    fontSize: 13,\n    fontWeight: 'bold',\n    color: 'white',\n    border: '2px solid white',\n    borderRadius: 20,\n    paddingLeft: 8,\n    paddingRight: 8,\n    paddingTop: 2,\n    paddingBottom: 2,\n};\nconst playerButtonStyle = {\n    appearance: 'none',\n    backgroundColor: 'transparent',\n    border: 'none',\n    cursor: 'pointer',\n    paddingLeft: 0,\n    paddingRight: 0,\n    paddingTop: 6,\n    paddingBottom: 6,\n    height: 37,\n    display: 'inline-flex',\n    marginBottom: 0,\n    marginTop: 0,\n    alignItems: 'center',\n};\nconst button = {\n    ...playerButtonStyle,\n    position: 'relative',\n};\nconst PlaybackrateControl = ({ playbackRates, canvasSize }) => {\n    const { ref, isComponentVisible, setIsComponentVisible } = useComponentVisible(false);\n    const { playbackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.TimelineContext);\n    const onClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        e.stopPropagation();\n        e.preventDefault();\n        setIsComponentVisible(!isComponentVisible);\n    }, [isComponentVisible, setIsComponentVisible]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: ref, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"button\", { type: \"button\", \"aria-label\": \"Change playback rate\", style: button, onClick: onClick, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: label, children: [playbackRate, \"x\"] }), isComponentVisible && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlaybackPopup, { canvasSize: canvasSize, playbackRates: playbackRates, setIsComponentVisible: setIsComponentVisible }))] }) }));\n};\n\nconst getFrameFromX = (clientX, durationInFrames, width) => {\n    var _a;\n    const pos = clientX;\n    const frame = Math.round((0,remotion__WEBPACK_IMPORTED_MODULE_1__.interpolate)(pos, [0, width], [0, (_a = durationInFrames - 1) !== null && _a !== void 0 ? _a : 0], {\n        extrapolateLeft: 'clamp',\n        extrapolateRight: 'clamp',\n    }));\n    return frame;\n};\nconst BAR_HEIGHT = 5;\nconst KNOB_SIZE = 12;\nconst VERTICAL_PADDING = 4;\nconst containerStyle$1 = {\n    userSelect: 'none',\n    paddingTop: VERTICAL_PADDING,\n    paddingBottom: VERTICAL_PADDING,\n    boxSizing: 'border-box',\n    cursor: 'pointer',\n    position: 'relative',\n    touchAction: 'none',\n};\nconst barBackground = {\n    height: BAR_HEIGHT,\n    backgroundColor: 'rgba(255, 255, 255, 0.25)',\n    width: '100%',\n    borderRadius: BAR_HEIGHT / 2,\n};\nconst findBodyInWhichDivIsLocated = (div) => {\n    let current = div;\n    while (current.parentElement) {\n        current = current.parentElement;\n    }\n    return current;\n};\nconst PlayerSeekBar = ({ durationInFrames, onSeekEnd, onSeekStart, inFrame, outFrame }) => {\n    const containerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const barHovered = useHoverState(containerRef);\n    const size = useElementSize(containerRef, {\n        triggerOnWindowResize: true,\n        shouldApplyCssTransforms: true,\n    });\n    const { seek, play, pause, playing } = usePlayer();\n    const frame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelinePosition();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({\n        dragging: false,\n    });\n    const onPointerDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        if (!size) {\n            throw new Error('Player has no size');\n        }\n        const _frame = getFrameFromX(e.clientX - size.left, durationInFrames, size.width);\n        pause();\n        seek(_frame);\n        setDragging({\n            dragging: true,\n            wasPlaying: playing,\n        });\n        onSeekStart();\n    }, [size, durationInFrames, pause, seek, playing, onSeekStart]);\n    const onPointerMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        var _a;\n        if (!size) {\n            throw new Error('Player has no size');\n        }\n        if (!dragging.dragging) {\n            return;\n        }\n        const _frame = getFrameFromX(e.clientX - ((_a = size === null || size === void 0 ? void 0 : size.left) !== null && _a !== void 0 ? _a : 0), durationInFrames, size.width);\n        seek(_frame);\n    }, [dragging.dragging, durationInFrames, seek, size]);\n    const onPointerUp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setDragging({\n            dragging: false,\n        });\n        if (!dragging.dragging) {\n            return;\n        }\n        if (dragging.wasPlaying) {\n            play();\n        }\n        else {\n            pause();\n        }\n        onSeekEnd();\n    }, [dragging, onSeekEnd, pause, play]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!dragging.dragging) {\n            return;\n        }\n        const body = findBodyInWhichDivIsLocated(containerRef.current);\n        body.addEventListener('pointermove', onPointerMove);\n        body.addEventListener('pointerup', onPointerUp);\n        return () => {\n            body.removeEventListener('pointermove', onPointerMove);\n            body.removeEventListener('pointerup', onPointerUp);\n        };\n    }, [dragging.dragging, onPointerMove, onPointerUp]);\n    const knobStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return {\n            height: KNOB_SIZE,\n            width: KNOB_SIZE,\n            borderRadius: KNOB_SIZE / 2,\n            position: 'absolute',\n            top: VERTICAL_PADDING - KNOB_SIZE / 2 + 5 / 2,\n            backgroundColor: 'white',\n            left: Math.max(0, (frame / Math.max(1, durationInFrames - 1)) * ((_a = size === null || size === void 0 ? void 0 : size.width) !== null && _a !== void 0 ? _a : 0) -\n                KNOB_SIZE / 2),\n            boxShadow: '0 0 2px black',\n            opacity: Number(barHovered),\n        };\n    }, [barHovered, durationInFrames, frame, size]);\n    const fillStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            height: BAR_HEIGHT,\n            backgroundColor: 'rgba(255, 255, 255, 1)',\n            width: ((frame - (inFrame !== null && inFrame !== void 0 ? inFrame : 0)) / (durationInFrames - 1)) * 100 + '%',\n            marginLeft: ((inFrame !== null && inFrame !== void 0 ? inFrame : 0) / (durationInFrames - 1)) * 100 + '%',\n            borderRadius: BAR_HEIGHT / 2,\n        };\n    }, [durationInFrames, frame, inFrame]);\n    const active = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            height: BAR_HEIGHT,\n            backgroundColor: 'rgba(255, 255, 255, 0.25)',\n            width: (((outFrame !== null && outFrame !== void 0 ? outFrame : durationInFrames - 1) - (inFrame !== null && inFrame !== void 0 ? inFrame : 0)) /\n                (durationInFrames - 1)) *\n                100 +\n                '%',\n            marginLeft: ((inFrame !== null && inFrame !== void 0 ? inFrame : 0) / (durationInFrames - 1)) * 100 + '%',\n            borderRadius: BAR_HEIGHT / 2,\n            position: 'absolute',\n        };\n    }, [durationInFrames, inFrame, outFrame]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { ref: containerRef, onPointerDown: onPointerDown, style: containerStyle$1, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: barBackground, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: active }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: fillStyle })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: knobStyle })] }));\n};\n\nconst X_SPACER = 10;\nconst X_PADDING = 12;\nconst useVideoControlsResize = ({ allowFullscreen: allowFullScreen, playerWidth, }) => {\n    const resizeInfo = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const playPauseIconSize = ICON_SIZE;\n        const volumeIconSize = ICON_SIZE;\n        const _fullscreenIconSize = allowFullScreen ? fullscreenIconSize : 0;\n        const elementsSize = volumeIconSize +\n            playPauseIconSize +\n            _fullscreenIconSize +\n            X_PADDING * 2 +\n            X_SPACER * 2;\n        const maxTimeLabelWidth = playerWidth - elementsSize;\n        const maxTimeLabelWidthWithoutNegativeValue = Math.max(maxTimeLabelWidth, 0);\n        const availableTimeLabelWidthIfVolumeOpen = maxTimeLabelWidthWithoutNegativeValue - VOLUME_SLIDER_WIDTH;\n        // If max label width is lower than the volume width\n        // then it means we need to take it's width as the max label width\n        // otherwise we took the available width when volume open\n        const computedLabelWidth = availableTimeLabelWidthIfVolumeOpen < VOLUME_SLIDER_WIDTH\n            ? maxTimeLabelWidthWithoutNegativeValue\n            : availableTimeLabelWidthIfVolumeOpen;\n        const minWidthForHorizontalDisplay = computedLabelWidth + elementsSize + VOLUME_SLIDER_WIDTH;\n        const displayVerticalVolumeSlider = playerWidth < minWidthForHorizontalDisplay;\n        return {\n            maxTimeLabelWidth: maxTimeLabelWidthWithoutNegativeValue === 0\n                ? null\n                : maxTimeLabelWidthWithoutNegativeValue,\n            displayVerticalVolumeSlider,\n        };\n    }, [allowFullScreen, playerWidth]);\n    return resizeInfo;\n};\n\nconst gradientSteps = [\n    0, 0.013, 0.049, 0.104, 0.175, 0.259, 0.352, 0.45, 0.55, 0.648, 0.741, 0.825,\n    0.896, 0.951, 0.987,\n];\nconst gradientOpacities = [\n    0, 8.1, 15.5, 22.5, 29, 35.3, 41.2, 47.1, 52.9, 58.8, 64.7, 71, 77.5, 84.5,\n    91.9,\n];\nconst globalGradientOpacity = 1 / 0.7;\nconst containerStyle = {\n    boxSizing: 'border-box',\n    position: 'absolute',\n    bottom: 0,\n    width: '100%',\n    paddingTop: 40,\n    paddingBottom: 10,\n    backgroundImage: `linear-gradient(to bottom,${gradientSteps\n        .map((g, i) => {\n        return `hsla(0, 0%, 0%, ${g}) ${gradientOpacities[i] * globalGradientOpacity}%`;\n    })\n        .join(', ')}, hsl(0, 0%, 0%) 100%)`,\n    backgroundSize: 'auto 145px',\n    display: 'flex',\n    paddingRight: X_PADDING,\n    paddingLeft: X_PADDING,\n    flexDirection: 'column',\n    transition: 'opacity 0.3s',\n};\nconst controlsRow = {\n    display: 'flex',\n    flexDirection: 'row',\n    width: '100%',\n    alignItems: 'center',\n    justifyContent: 'center',\n    userSelect: 'none',\n};\nconst leftPartStyle = {\n    display: 'flex',\n    flexDirection: 'row',\n    userSelect: 'none',\n    alignItems: 'center',\n};\nconst xSpacer = {\n    width: 12,\n};\nconst ySpacer = {\n    height: 8,\n};\nconst flex1 = {\n    flex: 1,\n};\nconst fullscreen = {};\nconst PlayPauseButton = ({ playing }) => playing ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PauseIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlayIcon, {});\nconst Controls = ({ durationInFrames, isFullscreen, fps, player, showVolumeControls, onFullscreenButtonClick, allowFullscreen, onExitFullscreenButtonClick, spaceKeyToPlayOrPause, onSeekEnd, onSeekStart, inFrame, outFrame, initiallyShowControls, canvasSize, renderPlayPauseButton, renderFullscreenButton, alwaysShowControls, showPlaybackRateControl, containerRef, }) => {\n    var _a;\n    const playButtonRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const frame = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.useTimelinePosition();\n    const [supportsFullscreen, setSupportsFullscreen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const hovered = useHoverState(containerRef);\n    const { maxTimeLabelWidth, displayVerticalVolumeSlider } = useVideoControlsResize({\n        allowFullscreen,\n        playerWidth: (_a = canvasSize === null || canvasSize === void 0 ? void 0 : canvasSize.width) !== null && _a !== void 0 ? _a : 0,\n    });\n    const [shouldShowInitially, setInitiallyShowControls] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n        if (typeof initiallyShowControls === 'boolean') {\n            return initiallyShowControls;\n        }\n        if (typeof initiallyShowControls === 'number') {\n            if (initiallyShowControls % 1 !== 0) {\n                throw new Error('initiallyShowControls must be an integer or a boolean');\n            }\n            if (Number.isNaN(initiallyShowControls)) {\n                throw new Error('initiallyShowControls must not be NaN');\n            }\n            if (!Number.isFinite(initiallyShowControls)) {\n                throw new Error('initiallyShowControls must be finite');\n            }\n            if (initiallyShowControls <= 0) {\n                throw new Error('initiallyShowControls must be a positive integer');\n            }\n            return initiallyShowControls;\n        }\n        throw new TypeError('initiallyShowControls must be a number or a boolean');\n    });\n    const containerCss = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        // Hide if playing and mouse outside\n        const shouldShow = hovered || !player.playing || shouldShowInitially || alwaysShowControls;\n        return {\n            ...containerStyle,\n            opacity: Number(shouldShow),\n        };\n    }, [hovered, shouldShowInitially, player.playing, alwaysShowControls]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (playButtonRef.current && spaceKeyToPlayOrPause) {\n            // This switches focus to play button when player.playing flag changes\n            playButtonRef.current.focus({\n                preventScroll: true,\n            });\n        }\n    }, [player.playing, spaceKeyToPlayOrPause]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        // Must be handled client-side to avoid SSR hydration mismatch\n        setSupportsFullscreen((_a = (typeof document !== 'undefined' &&\n            (document.fullscreenEnabled || document.webkitFullscreenEnabled))) !== null && _a !== void 0 ? _a : false);\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (shouldShowInitially === false) {\n            return;\n        }\n        const time = shouldShowInitially === true ? 2000 : shouldShowInitially;\n        const timeout = setTimeout(() => {\n            setInitiallyShowControls(false);\n        }, time);\n        return () => {\n            clearInterval(timeout);\n        };\n    }, [shouldShowInitially]);\n    const timeLabel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            color: 'white',\n            fontFamily: 'sans-serif',\n            fontSize: 14,\n            maxWidth: maxTimeLabelWidth === null ? undefined : maxTimeLabelWidth,\n            overflow: 'hidden',\n            textOverflow: 'ellipsis',\n        };\n    }, [maxTimeLabelWidth]);\n    const playbackRates = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (showPlaybackRateControl === true) {\n            return [0.5, 0.8, 1, 1.2, 1.5, 1.8, 2, 2.5, 3];\n        }\n        if (Array.isArray(showPlaybackRateControl)) {\n            for (const rate of showPlaybackRateControl) {\n                if (typeof rate !== 'number') {\n                    throw new Error('Every item in showPlaybackRateControl must be a number');\n                }\n                if (rate <= 0) {\n                    throw new Error('Every item in showPlaybackRateControl must be positive');\n                }\n            }\n            return showPlaybackRateControl;\n        }\n        return null;\n    }, [showPlaybackRateControl]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: containerCss, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: controlsRow, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: leftPartStyle, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { ref: playButtonRef, type: \"button\", style: playerButtonStyle, onClick: player.playing ? player.pause : player.play, \"aria-label\": player.playing ? 'Pause video' : 'Play video', title: player.playing ? 'Pause video' : 'Play video', children: renderPlayPauseButton === null ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlayPauseButton, { playing: player.playing })) : (renderPlayPauseButton({ playing: player.playing })) }), showVolumeControls ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: xSpacer }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(MediaVolumeSlider, { displayVerticalVolumeSlider: displayVerticalVolumeSlider })] })) : null, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: xSpacer }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(\"div\", { style: timeLabel, children: [formatTime(frame / fps), \" / \", formatTime(durationInFrames / fps)] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: xSpacer })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: flex1 }), playbackRates && canvasSize && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlaybackrateControl, { canvasSize: canvasSize, playbackRates: playbackRates })), playbackRates && supportsFullscreen && allowFullscreen ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: xSpacer })) : null, (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: fullscreen, children: supportsFullscreen && allowFullscreen ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"button\", { type: \"button\", \"aria-label\": isFullscreen ? 'Exit fullscreen' : 'Enter Fullscreen', title: isFullscreen ? 'Exit fullscreen' : 'Enter Fullscreen', style: playerButtonStyle, onClick: isFullscreen\n                                ? onExitFullscreenButtonClick\n                                : onFullscreenButtonClick, children: renderFullscreenButton === null ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(FullscreenIcon, { isFullscreen: isFullscreen })) : (renderFullscreenButton({ isFullscreen })) })) : null })] }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: ySpacer }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlayerSeekBar, { onSeekEnd: onSeekEnd, onSeekStart: onSeekStart, durationInFrames: durationInFrames, inFrame: inFrame, outFrame: outFrame })] }));\n};\n\nconst IS_NODE = typeof document === 'undefined';\n\nconst cancellablePromise = (promise) => {\n    let isCanceled = false;\n    const wrappedPromise = new Promise((resolve, reject) => {\n        promise\n            .then((value) => {\n            if (isCanceled) {\n                reject({ isCanceled, value });\n                return;\n            }\n            resolve(value);\n        })\n            .catch((error) => {\n            reject({ isCanceled, error });\n        });\n    });\n    return {\n        promise: wrappedPromise,\n        cancel: () => {\n            isCanceled = true;\n        },\n    };\n};\n\n/* eslint-disable no-promise-executor-return */\nconst delay = (n) => new Promise((resolve) => setTimeout(resolve, n));\n\nconst useCancellablePromises = () => {\n    const pendingPromises = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const appendPendingPromise = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((promise) => {\n        pendingPromises.current = [...pendingPromises.current, promise];\n    }, []);\n    const removePendingPromise = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((promise) => {\n        pendingPromises.current = pendingPromises.current.filter((p) => p !== promise);\n    }, []);\n    const clearPendingPromises = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => pendingPromises.current.map((p) => p.cancel()), []);\n    const api = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        appendPendingPromise,\n        removePendingPromise,\n        clearPendingPromises,\n    }), [appendPendingPromise, clearPendingPromises, removePendingPromise]);\n    return api;\n};\n\nconst useClickPreventionOnDoubleClick = (onClick, onDoubleClick, doubleClickToFullscreen) => {\n    const api = useCancellablePromises();\n    const handleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (e) => {\n        api.clearPendingPromises();\n        const waitForClick = cancellablePromise(delay(200));\n        api.appendPendingPromise(waitForClick);\n        try {\n            await waitForClick.promise;\n            api.removePendingPromise(waitForClick);\n            onClick(e);\n        }\n        catch (errorInfo) {\n            const info = errorInfo;\n            api.removePendingPromise(waitForClick);\n            if (!info.isCanceled) {\n                throw info.error;\n            }\n        }\n    }, [api, onClick]);\n    const handleDoubleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        api.clearPendingPromises();\n        onDoubleClick();\n    }, [api, onDoubleClick]);\n    const returnValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!doubleClickToFullscreen) {\n            return [onClick, onDoubleClick];\n        }\n        return [handleClick, handleDoubleClick];\n    }, [\n        doubleClickToFullscreen,\n        handleClick,\n        handleDoubleClick,\n        onClick,\n        onDoubleClick,\n    ]);\n    return returnValue;\n};\n\nconst reactVersion$1 = react__WEBPACK_IMPORTED_MODULE_0__.version.split('.')[0];\nif (reactVersion$1 === '0') {\n    throw new Error(`Version ${reactVersion$1} of \"react\" is not supported by Remotion`);\n}\nconst doesReactVersionSupportSuspense$1 = parseInt(reactVersion$1, 10) >= 18;\nconst PlayerUI = ({ controls, style, loop, autoPlay, allowFullscreen, inputProps, clickToPlay, showVolumeControls, doubleClickToFullscreen, spaceKeyToPlayOrPause, errorFallback, playbackRate, renderLoading, renderPoster, className, moveToBeginningWhenEnded, showPosterWhenUnplayed, showPosterWhenEnded, showPosterWhenPaused, inFrame, outFrame, initiallyShowControls, renderFullscreen: renderFullscreenButton, renderPlayPauseButton, alwaysShowControls, showPlaybackRateControl, }, ref) => {\n    var _a, _b, _c;\n    const config = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useUnsafeVideoConfig();\n    const video = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useVideo();\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const canvasSize = useElementSize(container, {\n        triggerOnWindowResize: false,\n        shouldApplyCssTransforms: false,\n    });\n    const [hasPausedToResume, setHasPausedToResume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [shouldAutoplay, setShouldAutoPlay] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(autoPlay);\n    const [isFullscreen, setIsFullscreen] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => false);\n    const [seeking, setSeeking] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    usePlayback({\n        loop,\n        playbackRate,\n        moveToBeginningWhenEnded,\n        inFrame,\n        outFrame,\n    });\n    const player = usePlayer();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (hasPausedToResume && !player.playing) {\n            setHasPausedToResume(false);\n            player.play();\n        }\n    }, [hasPausedToResume, player]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const { current } = container;\n        if (!current) {\n            return;\n        }\n        const onFullscreenChange = () => {\n            setIsFullscreen(document.fullscreenElement === current ||\n                document.webkitFullscreenElement === current);\n        };\n        document.addEventListener('fullscreenchange', onFullscreenChange);\n        document.addEventListener('webkitfullscreenchange', onFullscreenChange);\n        return () => {\n            document.removeEventListener('fullscreenchange', onFullscreenChange);\n            document.removeEventListener('webkitfullscreenchange', onFullscreenChange);\n        };\n    }, []);\n    const toggle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        if (player.isPlaying()) {\n            player.pause();\n        }\n        else {\n            player.play(e);\n        }\n    }, [player]);\n    const requestFullscreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (!allowFullscreen) {\n            throw new Error('allowFullscreen is false');\n        }\n        const supportsFullScreen = document.fullscreenEnabled || document.webkitFullscreenEnabled;\n        if (!supportsFullScreen) {\n            throw new Error('Browser doesnt support fullscreen');\n        }\n        if (!container.current) {\n            throw new Error('No player ref found');\n        }\n        if (container.current.webkitRequestFullScreen) {\n            container.current.webkitRequestFullScreen();\n        }\n        else {\n            container.current.requestFullscreen();\n        }\n    }, [allowFullscreen]);\n    const exitFullscreen = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (document.webkitExitFullscreen) {\n            document.webkitExitFullscreen();\n        }\n        else {\n            document.exitFullscreen();\n        }\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const { current } = container;\n        if (!current) {\n            return;\n        }\n        const fullscreenChange = () => {\n            var _a;\n            const element = (_a = document.webkitFullscreenElement) !== null && _a !== void 0 ? _a : document.fullscreenElement;\n            if (element && element === container.current) {\n                player.emitter.dispatchFullscreenChange({\n                    isFullscreen: true,\n                });\n            }\n            else {\n                player.emitter.dispatchFullscreenChange({\n                    isFullscreen: false,\n                });\n            }\n        };\n        current.addEventListener('webkitfullscreenchange', fullscreenChange);\n        current.addEventListener('fullscreenchange', fullscreenChange);\n        return () => {\n            current.removeEventListener('webkitfullscreenchange', fullscreenChange);\n            current.removeEventListener('fullscreenchange', fullscreenChange);\n        };\n    }, [player.emitter]);\n    const durationInFrames = (_a = config === null || config === void 0 ? void 0 : config.durationInFrames) !== null && _a !== void 0 ? _a : 1;\n    const layout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!config || !canvasSize) {\n            return null;\n        }\n        return calculateCanvasTransformation({\n            canvasSize,\n            compositionHeight: config.height,\n            compositionWidth: config.width,\n            previewSize: 'auto',\n        });\n    }, [canvasSize, config]);\n    const scale = (_b = layout === null || layout === void 0 ? void 0 : layout.scale) !== null && _b !== void 0 ? _b : 1;\n    const initialScaleIgnored = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!initialScaleIgnored.current) {\n            initialScaleIgnored.current = true;\n            return;\n        }\n        player.emitter.dispatchScaleChange(scale);\n    }, [player.emitter, scale]);\n    const { setMediaVolume, setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.SetMediaVolumeContext);\n    const { mediaMuted, mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.MediaVolumeContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        player.emitter.dispatchVolumeChange(mediaVolume);\n    }, [player.emitter, mediaVolume]);\n    const isMuted = mediaMuted || mediaVolume === 0;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        player.emitter.dispatchMuteChange({\n            isMuted,\n        });\n    }, [player.emitter, isMuted]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        const methods = {\n            play: player.play,\n            pause: () => {\n                // If, after .seek()-ing, the player was explicitly paused, we don't resume\n                setHasPausedToResume(false);\n                player.pause();\n            },\n            toggle,\n            getContainerNode: () => container.current,\n            getCurrentFrame: player.getCurrentFrame,\n            isPlaying: () => player.playing,\n            seekTo: (f) => {\n                const lastFrame = durationInFrames - 1;\n                const frameToSeekTo = Math.max(0, Math.min(lastFrame, f));\n                // continue playing after seeking if the player was playing before\n                if (player.isPlaying()) {\n                    const pauseToResume = frameToSeekTo !== lastFrame || loop;\n                    setHasPausedToResume(pauseToResume);\n                    player.pause();\n                }\n                if (frameToSeekTo === lastFrame && !loop) {\n                    player.emitter.dispatchEnded();\n                }\n                player.seek(frameToSeekTo);\n            },\n            isFullscreen: () => isFullscreen,\n            requestFullscreen,\n            exitFullscreen,\n            getVolume: () => {\n                if (mediaMuted) {\n                    return 0;\n                }\n                return mediaVolume;\n            },\n            setVolume: (vol) => {\n                if (typeof vol !== 'number') {\n                    throw new TypeError(`setVolume() takes a number, got value of type ${typeof vol}`);\n                }\n                if (isNaN(vol)) {\n                    throw new TypeError(`setVolume() got a number that is NaN. Volume must be between 0 and 1.`);\n                }\n                if (vol < 0 || vol > 1) {\n                    throw new TypeError(`setVolume() got a number that is out of range. Must be between 0 and 1, got ${typeof vol}`);\n                }\n                setMediaVolume(vol);\n            },\n            isMuted: () => isMuted,\n            mute: () => {\n                setMediaMuted(true);\n            },\n            unmute: () => {\n                setMediaMuted(false);\n            },\n            getScale: () => scale,\n        };\n        return Object.assign(player.emitter, methods);\n    }, [\n        durationInFrames,\n        exitFullscreen,\n        isFullscreen,\n        loop,\n        mediaMuted,\n        isMuted,\n        mediaVolume,\n        player,\n        requestFullscreen,\n        setMediaMuted,\n        setMediaVolume,\n        toggle,\n        scale,\n    ]);\n    const VideoComponent = video ? video.component : null;\n    const outerStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateOuterStyle({ canvasSize, config, style });\n    }, [canvasSize, config, style]);\n    const outer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateOuter({ config, layout, scale });\n    }, [config, layout, scale]);\n    const containerStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateContainerStyle({ canvasSize, config, layout, scale });\n    }, [canvasSize, config, layout, scale]);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((error) => {\n        player.pause();\n        // Pay attention to `this context`\n        player.emitter.dispatchError(error);\n    }, [player]);\n    const onFullscreenButtonClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        e.stopPropagation();\n        requestFullscreen();\n    }, [requestFullscreen]);\n    const onExitFullscreenButtonClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        e.stopPropagation();\n        exitFullscreen();\n    }, [exitFullscreen]);\n    const onSingleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        toggle(e);\n    }, [toggle]);\n    const onSeekStart = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setSeeking(true);\n    }, []);\n    const onSeekEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setSeeking(false);\n    }, []);\n    const onDoubleClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        if (isFullscreen) {\n            exitFullscreen();\n        }\n        else {\n            requestFullscreen();\n        }\n    }, [exitFullscreen, isFullscreen, requestFullscreen]);\n    const [handleClick, handleDoubleClick] = useClickPreventionOnDoubleClick(onSingleClick, onDoubleClick, doubleClickToFullscreen);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (shouldAutoplay) {\n            player.play();\n            setShouldAutoPlay(false);\n        }\n    }, [shouldAutoplay, player]);\n    const loadingMarkup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return renderLoading\n            ? renderLoading({\n                height: outerStyle.height,\n                width: outerStyle.width,\n            })\n            : null;\n    }, [outerStyle.height, outerStyle.width, renderLoading]);\n    if (!config) {\n        return null;\n    }\n    const poster = renderPoster\n        ? renderPoster({\n            height: outerStyle.height,\n            width: outerStyle.width,\n        })\n        : null;\n    if (poster === undefined) {\n        throw new TypeError('renderPoster() must return a React element, but undefined was returned');\n    }\n    const shouldShowPoster = poster &&\n        [\n            showPosterWhenPaused && !player.isPlaying() && !seeking,\n            showPosterWhenEnded && player.isLastFrame && !player.isPlaying(),\n            showPosterWhenUnplayed && !player.hasPlayed && !player.isPlaying(),\n        ].some(Boolean);\n    const content = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: outer, onClick: clickToPlay ? handleClick : undefined, onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: containerStyle, className: PLAYER_CSS_CLASSNAME, children: VideoComponent ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, { onError: onError, errorFallback: errorFallback, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.ClipComposition, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VideoComponent, { ...((_c = video === null || video === void 0 ? void 0 : video.props) !== null && _c !== void 0 ? _c : {}), ...(inputProps !== null && inputProps !== void 0 ? inputProps : {}) }) }) })) : null }) }), shouldShowPoster ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: outer, onClick: clickToPlay ? handleClick : undefined, onDoubleClick: doubleClickToFullscreen ? handleDoubleClick : undefined, children: poster })) : null, controls ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(Controls, { fps: config.fps, durationInFrames: config.durationInFrames, player: player, containerRef: container, onFullscreenButtonClick: onFullscreenButtonClick, isFullscreen: isFullscreen, allowFullscreen: allowFullscreen, showVolumeControls: showVolumeControls, onExitFullscreenButtonClick: onExitFullscreenButtonClick, spaceKeyToPlayOrPause: spaceKeyToPlayOrPause, onSeekEnd: onSeekEnd, onSeekStart: onSeekStart, inFrame: inFrame, outFrame: outFrame, initiallyShowControls: initiallyShowControls, canvasSize: canvasSize, renderFullscreenButton: renderFullscreenButton, renderPlayPauseButton: renderPlayPauseButton, alwaysShowControls: alwaysShowControls, showPlaybackRateControl: showPlaybackRateControl })) : null] }));\n    if (IS_NODE && !doesReactVersionSupportSuspense$1) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: container, style: outerStyle, className: className, children: content }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: container, style: outerStyle, className: className, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: loadingMarkup, children: content }) }));\n};\nvar PlayerUI$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PlayerUI);\n\nconst VOLUME_PERSISTANCE_KEY = 'remotion.volumePreference';\nconst persistVolume = (volume) => {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    window.localStorage.setItem(VOLUME_PERSISTANCE_KEY, String(volume));\n};\nconst getPreferredVolume = () => {\n    if (typeof window === 'undefined') {\n        return 1;\n    }\n    const val = window.localStorage.getItem(VOLUME_PERSISTANCE_KEY);\n    return val ? Number(val) : 1;\n};\n\nconst PLAYER_COMP_ID = 'player-comp';\nconst SharedPlayerContexts = ({ children, timelineContext, fps, compositionHeight, compositionWidth, durationInFrames, component, numberOfSharedAudioTags, initiallyMuted, }) => {\n    const compositionManagerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const context = {\n            compositions: [\n                {\n                    component: component,\n                    durationInFrames,\n                    height: compositionHeight,\n                    width: compositionWidth,\n                    fps,\n                    id: PLAYER_COMP_ID,\n                    nonce: 777,\n                    folderName: null,\n                    parentFolderName: null,\n                    schema: null,\n                    calculateMetadata: null,\n                },\n            ],\n            folders: [],\n            registerFolder: () => undefined,\n            unregisterFolder: () => undefined,\n            registerComposition: () => undefined,\n            unregisterComposition: () => undefined,\n            currentCompositionMetadata: null,\n            setCurrentCompositionMetadata: () => undefined,\n            canvasContent: { type: 'composition', compositionId: 'player-comp' },\n            setCanvasContent: () => undefined,\n        };\n        return context;\n    }, [component, durationInFrames, compositionHeight, compositionWidth, fps]);\n    const [mediaMuted, setMediaMuted] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => initiallyMuted);\n    const [mediaVolume, setMediaVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => getPreferredVolume());\n    const mediaVolumeContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            mediaMuted,\n            mediaVolume,\n        };\n    }, [mediaMuted, mediaVolume]);\n    const setMediaVolumeAndPersist = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((vol) => {\n        setMediaVolume(vol);\n        persistVolume(vol);\n    }, []);\n    const setMediaVolumeContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            setMediaMuted,\n            setMediaVolume: setMediaVolumeAndPersist,\n        };\n    }, [setMediaVolumeAndPersist]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.CanUseRemotionHooksProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.TimelineContext.Provider, { value: timelineContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.CompositionManager.Provider, { value: compositionManagerContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.ResolveCompositionConfig, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.PrefetchProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.DurationsContextProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.MediaVolumeContext.Provider, { value: mediaVolumeContextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.NativeLayersProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.SetMediaVolumeContext.Provider, { value: setMediaVolumeContextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.SharedAudioContextProvider, { numberOfAudioTags: numberOfSharedAudioTags, component: component, children: children }) }) }) }) }) }) }) }) }) }));\n};\n\nconst validateSingleFrame = (frame, variableName) => {\n    if (typeof frame === 'undefined' || frame === null) {\n        return frame !== null && frame !== void 0 ? frame : null;\n    }\n    if (typeof frame !== 'number') {\n        throw new TypeError(`\"${variableName}\" must be a number, but is ${JSON.stringify(frame)}`);\n    }\n    if (Number.isNaN(frame)) {\n        throw new TypeError(`\"${variableName}\" must not be NaN, but is ${JSON.stringify(frame)}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new TypeError(`\"${variableName}\" must be finite, but is ${JSON.stringify(frame)}`);\n    }\n    if (frame % 1 !== 0) {\n        throw new TypeError(`\"${variableName}\" must be an integer, but is ${JSON.stringify(frame)}`);\n    }\n    return frame;\n};\nconst validateInOutFrames = ({ inFrame, durationInFrames, outFrame, }) => {\n    const validatedInFrame = validateSingleFrame(inFrame, 'inFrame');\n    const validatedOutFrame = validateSingleFrame(outFrame, 'outFrame');\n    if (validatedInFrame === null && validatedOutFrame === null) {\n        return;\n    }\n    // Must not be over the duration\n    if (validatedInFrame !== null && validatedInFrame > durationInFrames - 1) {\n        throw new Error('inFrame must be less than (durationInFrames - 1), but is ' +\n            validatedInFrame);\n    }\n    if (validatedOutFrame !== null && validatedOutFrame > durationInFrames - 1) {\n        throw new Error('outFrame must be less than (durationInFrames - 1), but is ' +\n            validatedOutFrame);\n    }\n    // Must not be under 0\n    if (validatedInFrame !== null && validatedInFrame < 0) {\n        throw new Error('inFrame must be greater than 0, but is ' + validatedInFrame);\n    }\n    if (validatedOutFrame !== null && validatedOutFrame <= 0) {\n        throw new Error(`outFrame must be greater than 0, but is ${validatedOutFrame}. If you want to render a single frame, use <Thumbnail /> instead.`);\n    }\n    if (validatedOutFrame !== null &&\n        validatedInFrame !== null &&\n        validatedOutFrame <= validatedInFrame) {\n        throw new Error('outFrame must be greater than inFrame, but is ' +\n            validatedOutFrame +\n            ' <= ' +\n            validatedInFrame);\n    }\n};\n\nconst validateInitialFrame = ({ initialFrame, durationInFrames, }) => {\n    if (typeof durationInFrames !== 'number') {\n        throw new Error(`\\`durationInFrames\\` must be a number, but is ${JSON.stringify(durationInFrames)}`);\n    }\n    if (typeof initialFrame === 'undefined') {\n        return;\n    }\n    if (typeof initialFrame !== 'number') {\n        throw new Error(`\\`initialFrame\\` must be a number, but is ${JSON.stringify(initialFrame)}`);\n    }\n    if (Number.isNaN(initialFrame)) {\n        throw new Error(`\\`initialFrame\\` must be a number, but is NaN`);\n    }\n    if (!Number.isFinite(initialFrame)) {\n        throw new Error(`\\`initialFrame\\` must be a number, but is Infinity`);\n    }\n    if (initialFrame % 1 !== 0) {\n        throw new Error(`\\`initialFrame\\` must be an integer, but is ${JSON.stringify(initialFrame)}`);\n    }\n    if (initialFrame > durationInFrames - 1) {\n        throw new Error(`\\`initialFrame\\` must be less or equal than \\`durationInFrames - 1\\`, but is ${JSON.stringify(initialFrame)}`);\n    }\n};\n\nconst validatePlaybackRate = (playbackRate) => {\n    if (playbackRate === undefined) {\n        return;\n    }\n    if (playbackRate > 4) {\n        throw new Error(`The highest possible playback rate is 4. You passed: ${playbackRate}`);\n    }\n    if (playbackRate < -4) {\n        throw new Error(`The lowest possible playback rate is -4. You passed: ${playbackRate}`);\n    }\n    if (playbackRate === 0) {\n        throw new Error(`A playback rate of 0 is not supported.`);\n    }\n};\n\n/* eslint-disable prefer-destructuring */\nconst validateFps = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.validateFps;\nconst validateDimension = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.validateDimension;\nconst validateDurationInFrames = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.validateDurationInFrames;\nconst validateDefaultAndInputProps = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.validateDefaultAndInputProps;\n\nconst componentOrNullIfLazy = (props) => {\n    if ('component' in props) {\n        return props.component;\n    }\n    return null;\n};\nconst PlayerFn = ({ durationInFrames, compositionHeight, compositionWidth, fps, inputProps, style, controls = false, loop = false, autoPlay = false, showVolumeControls = true, allowFullscreen = true, clickToPlay, doubleClickToFullscreen = false, spaceKeyToPlayOrPause = true, moveToBeginningWhenEnded = true, numberOfSharedAudioTags = 5, errorFallback = () => '⚠️', playbackRate = 1, renderLoading, className, showPosterWhenUnplayed, showPosterWhenEnded, showPosterWhenPaused, initialFrame, renderPoster, inFrame, outFrame, initiallyShowControls, renderFullscreenButton, renderPlayPauseButton, alwaysShowControls = false, initiallyMuted = false, showPlaybackRateControl = false, ...componentProps }, ref) => {\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            window.remotion_isPlayer = true;\n        }, []);\n    }\n    // @ts-expect-error\n    if (componentProps.defaultProps !== undefined) {\n        throw new Error('The <Player /> component does not accept `defaultProps`, but some were passed. Use `inputProps` instead.');\n    }\n    const componentForValidation = componentOrNullIfLazy(componentProps);\n    // @ts-expect-error\n    if ((componentForValidation === null || componentForValidation === void 0 ? void 0 : componentForValidation.type) === remotion__WEBPACK_IMPORTED_MODULE_1__.Composition) {\n        throw new TypeError(`'component' should not be an instance of <Composition/>. Pass the React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);\n    }\n    if (componentForValidation === remotion__WEBPACK_IMPORTED_MODULE_1__.Composition) {\n        throw new TypeError(`'component' must not be the 'Composition' component. Pass your own React component directly, and set the duration, fps and dimensions as separate props. See https://www.remotion.dev/docs/player/examples for an example.`);\n    }\n    const component = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useLazyComponent(componentProps);\n    validateInitialFrame({ initialFrame, durationInFrames });\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => ({\n        [PLAYER_COMP_ID]: initialFrame !== null && initialFrame !== void 0 ? initialFrame : 0,\n    }));\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [rootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)('player-comp');\n    const [emitter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new PlayerEmitter());\n    const rootRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [currentPlaybackRate, setCurrentPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(playbackRate);\n    if (typeof compositionHeight !== 'number') {\n        throw new TypeError(`'compositionHeight' must be a number but got '${typeof compositionHeight}' instead`);\n    }\n    if (typeof compositionWidth !== 'number') {\n        throw new TypeError(`'compositionWidth' must be a number but got '${typeof compositionWidth}' instead`);\n    }\n    validateDimension(compositionHeight, 'compositionHeight', 'of the <Player /> component');\n    validateDimension(compositionWidth, 'compositionWidth', 'of the <Player /> component');\n    validateDurationInFrames(durationInFrames, {\n        component: 'of the <Player/> component',\n        allowFloats: false,\n    });\n    validateFps(fps, 'as a prop of the <Player/> component', false);\n    validateDefaultAndInputProps(inputProps, 'inputProps', null);\n    validateInOutFrames({\n        durationInFrames,\n        inFrame,\n        outFrame,\n    });\n    if (typeof controls !== 'boolean' && typeof controls !== 'undefined') {\n        throw new TypeError(`'controls' must be a boolean or undefined but got '${typeof controls}' instead`);\n    }\n    if (typeof autoPlay !== 'boolean' && typeof autoPlay !== 'undefined') {\n        throw new TypeError(`'autoPlay' must be a boolean or undefined but got '${typeof autoPlay}' instead`);\n    }\n    if (typeof loop !== 'boolean' && typeof loop !== 'undefined') {\n        throw new TypeError(`'loop' must be a boolean or undefined but got '${typeof loop}' instead`);\n    }\n    if (typeof doubleClickToFullscreen !== 'boolean' &&\n        typeof doubleClickToFullscreen !== 'undefined') {\n        throw new TypeError(`'doubleClickToFullscreen' must be a boolean or undefined but got '${typeof doubleClickToFullscreen}' instead`);\n    }\n    if (typeof showVolumeControls !== 'boolean' &&\n        typeof showVolumeControls !== 'undefined') {\n        throw new TypeError(`'showVolumeControls' must be a boolean or undefined but got '${typeof showVolumeControls}' instead`);\n    }\n    if (typeof allowFullscreen !== 'boolean' &&\n        typeof allowFullscreen !== 'undefined') {\n        throw new TypeError(`'allowFullscreen' must be a boolean or undefined but got '${typeof allowFullscreen}' instead`);\n    }\n    if (typeof clickToPlay !== 'boolean' && typeof clickToPlay !== 'undefined') {\n        throw new TypeError(`'clickToPlay' must be a boolean or undefined but got '${typeof clickToPlay}' instead`);\n    }\n    if (typeof spaceKeyToPlayOrPause !== 'boolean' &&\n        typeof spaceKeyToPlayOrPause !== 'undefined') {\n        throw new TypeError(`'spaceKeyToPlayOrPause' must be a boolean or undefined but got '${typeof spaceKeyToPlayOrPause}' instead`);\n    }\n    if (typeof numberOfSharedAudioTags !== 'number' ||\n        numberOfSharedAudioTags % 1 !== 0 ||\n        !Number.isFinite(numberOfSharedAudioTags) ||\n        Number.isNaN(numberOfSharedAudioTags) ||\n        numberOfSharedAudioTags < 0) {\n        throw new TypeError(`'numberOfSharedAudioTags' must be an integer but got '${numberOfSharedAudioTags}' instead`);\n    }\n    validatePlaybackRate(currentPlaybackRate);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        emitter.dispatchRateChange(currentPlaybackRate);\n    }, [emitter, currentPlaybackRate]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        setCurrentPlaybackRate(playbackRate);\n    }, [playbackRate]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => rootRef.current, []);\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            frame,\n            playing,\n            rootId,\n            playbackRate: currentPlaybackRate,\n            imperativePlaying,\n            setPlaybackRate: (rate) => {\n                setCurrentPlaybackRate(rate);\n            },\n            audioAndVideoTags,\n        };\n    }, [frame, currentPlaybackRate, playing, rootId]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            setFrame,\n            setPlaying,\n        };\n    }, [setFrame]);\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            // Inject CSS only on client, and also only after the Player has hydrated\n            remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.CSSUtils.injectCSS(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.CSSUtils.makeDefaultCSS(`.${PLAYER_CSS_CLASSNAME}`, '#fff'));\n        }, []);\n    }\n    const actualInputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => inputProps !== null && inputProps !== void 0 ? inputProps : {}, [inputProps]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.IsPlayerContextProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SharedPlayerContexts, { timelineContext: timelineContextValue, component: component, compositionHeight: compositionHeight, compositionWidth: compositionWidth, durationInFrames: durationInFrames, fps: fps, numberOfSharedAudioTags: numberOfSharedAudioTags, initiallyMuted: initiallyMuted, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.Timeline.SetTimelineContext.Provider, { value: setTimelineContextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlayerEventEmitterContext.Provider, { value: emitter, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(PlayerUI$1, { ref: rootRef, renderLoading: renderLoading, autoPlay: Boolean(autoPlay), loop: Boolean(loop), controls: Boolean(controls), errorFallback: errorFallback, style: style, inputProps: actualInputProps, allowFullscreen: Boolean(allowFullscreen), moveToBeginningWhenEnded: Boolean(moveToBeginningWhenEnded), clickToPlay: typeof clickToPlay === 'boolean'\n                            ? clickToPlay\n                            : Boolean(controls), showVolumeControls: Boolean(showVolumeControls), doubleClickToFullscreen: Boolean(doubleClickToFullscreen), spaceKeyToPlayOrPause: Boolean(spaceKeyToPlayOrPause), playbackRate: currentPlaybackRate, className: className !== null && className !== void 0 ? className : undefined, showPosterWhenUnplayed: Boolean(showPosterWhenUnplayed), showPosterWhenEnded: Boolean(showPosterWhenEnded), showPosterWhenPaused: Boolean(showPosterWhenPaused), renderPoster: renderPoster, inFrame: inFrame !== null && inFrame !== void 0 ? inFrame : null, outFrame: outFrame !== null && outFrame !== void 0 ? outFrame : null, initiallyShowControls: initiallyShowControls !== null && initiallyShowControls !== void 0 ? initiallyShowControls : true, renderFullscreen: renderFullscreenButton !== null && renderFullscreenButton !== void 0 ? renderFullscreenButton : null, renderPlayPauseButton: renderPlayPauseButton !== null && renderPlayPauseButton !== void 0 ? renderPlayPauseButton : null, alwaysShowControls: alwaysShowControls, showPlaybackRateControl: showPlaybackRateControl }) }) }) }) }));\n};\nconst forward$1 = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef;\n/**\n * @description A component which can be rendered in a regular React App (for example: Vite, Next.js) to display a Remotion video.\n * @see [Documentation](https://www.remotion.dev/docs/player/player)\n */\nconst Player = forward$1(PlayerFn);\n\nconst useThumbnail = () => {\n    const emitter = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThumbnailEmitterContext);\n    if (!emitter) {\n        throw new TypeError('Expected Player event emitter context');\n    }\n    const returnValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            emitter,\n        };\n    }, [emitter]);\n    return returnValue;\n};\n\nconst reactVersion = react__WEBPACK_IMPORTED_MODULE_0__.version.split('.')[0];\nif (reactVersion === '0') {\n    throw new Error(`Version ${reactVersion} of \"react\" is not supported by Remotion`);\n}\nconst doesReactVersionSupportSuspense = parseInt(reactVersion, 10) >= 18;\nconst ThumbnailUI = ({ style, inputProps, errorFallback, renderLoading, className }, ref) => {\n    var _a, _b;\n    const config = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useUnsafeVideoConfig();\n    const video = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useVideo();\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const canvasSize = useElementSize(container, {\n        triggerOnWindowResize: false,\n        shouldApplyCssTransforms: false,\n    });\n    const layout = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!config || !canvasSize) {\n            return null;\n        }\n        return calculateCanvasTransformation({\n            canvasSize,\n            compositionHeight: config.height,\n            compositionWidth: config.width,\n            previewSize: 'auto',\n        });\n    }, [canvasSize, config]);\n    const scale = (_a = layout === null || layout === void 0 ? void 0 : layout.scale) !== null && _a !== void 0 ? _a : 1;\n    const thumbnail = useThumbnail();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        const methods = {\n            getContainerNode: () => container.current,\n            getScale: () => scale,\n        };\n        return Object.assign(thumbnail.emitter, methods);\n    }, [scale, thumbnail.emitter]);\n    const VideoComponent = video ? video.component : null;\n    const outerStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateOuterStyle({ config, style, canvasSize });\n    }, [canvasSize, config, style]);\n    const outer = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateOuter({ config, layout, scale });\n    }, [config, layout, scale]);\n    const containerStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return calculateContainerStyle({\n            canvasSize,\n            config,\n            layout,\n            scale,\n        });\n    }, [canvasSize, config, layout, scale]);\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((error) => {\n        // Pay attention to `this context`\n        thumbnail.emitter.dispatchError(error);\n    }, [thumbnail.emitter]);\n    const rootRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => rootRef.current, []);\n    const loadingMarkup = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return renderLoading\n            ? renderLoading({\n                height: outerStyle.height,\n                width: outerStyle.width,\n            })\n            : null;\n    }, [outerStyle.height, outerStyle.width, renderLoading]);\n    if (!config) {\n        return null;\n    }\n    const content = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: outer, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { style: containerStyle, className: PLAYER_CSS_CLASSNAME, children: VideoComponent ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ErrorBoundary, { onError: onError, errorFallback: errorFallback, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(VideoComponent, { ...((_b = video === null || video === void 0 ? void 0 : video.props) !== null && _b !== void 0 ? _b : {}), ...(inputProps !== null && inputProps !== void 0 ? inputProps : {}) }) })) : null }) }));\n    if (IS_NODE && !doesReactVersionSupportSuspense) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: container, style: outerStyle, className: className, children: content }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(\"div\", { ref: container, style: outerStyle, className: className, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: loadingMarkup, children: content }) }));\n};\nvar ThumbnailUI$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ThumbnailUI);\n\nconst ThumbnailFn = ({ frameToDisplay, style, inputProps, compositionHeight, compositionWidth, durationInFrames, fps, className, errorFallback = () => '⚠️', renderLoading, ...componentProps }, ref) => {\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            window.remotion_isPlayer = true;\n        }, []);\n    }\n    const [thumbnailId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String((0,remotion__WEBPACK_IMPORTED_MODULE_1__.random)(null)));\n    const rootRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const timelineState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const value = {\n            playing: false,\n            frame: {\n                [PLAYER_COMP_ID]: frameToDisplay,\n            },\n            rootId: thumbnailId,\n            imperativePlaying: {\n                current: false,\n            },\n            playbackRate: 1,\n            setPlaybackRate: () => {\n                throw new Error('thumbnail');\n            },\n            audioAndVideoTags: { current: [] },\n        };\n        return value;\n    }, [frameToDisplay, thumbnailId]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => rootRef.current, []);\n    const Component = remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.useLazyComponent(componentProps);\n    const [emitter] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new ThumbnailEmitter());\n    const passedInputProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return inputProps !== null && inputProps !== void 0 ? inputProps : {};\n    }, [inputProps]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(remotion__WEBPACK_IMPORTED_MODULE_1__.Internals.IsPlayerContextProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(SharedPlayerContexts, { timelineContext: timelineState, component: Component, compositionHeight: compositionHeight, compositionWidth: compositionWidth, durationInFrames: durationInFrames, fps: fps, numberOfSharedAudioTags: 0, initiallyMuted: true, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ThumbnailEmitterContext.Provider, { value: emitter, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)(ThumbnailUI$1, { className: className, errorFallback: errorFallback, inputProps: passedInputProps, renderLoading: renderLoading, style: style }) }) }) }));\n};\nconst forward = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef;\n/**\n * @description A component which can be rendered in a regular React App (for example: Create React App, Next.js) to display a single frame of a video.\n * @see [Documentation](https://www.remotion.dev/docs/player/thumbnail)\n */\nconst Thumbnail = forward(ThumbnailFn);\n\nconst PlayerInternals = {\n    PlayerEventEmitterContext,\n    PlayerEmitter,\n    usePlayer,\n    usePlayback,\n    useElementSize,\n    calculateCanvasTransformation,\n    useHoverState,\n    updateAllElementsSizes,\n    calculateScale,\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQHJlbW90aW9uK3BsYXllckA0LjAuNDdfcmVhY3QtZG9tQDE4LjIuMF9yZWFjdEAxOC4yLjAvbm9kZV9tb2R1bGVzL0ByZW1vdGlvbi9wbGF5ZXIvZGlzdC9lc20vaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBO0FBQ3lKO0FBQ2xGO0FBQ2Y7O0FBRXhELCtCQUErQixrRUFBa0U7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEIsK0RBQStEO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsK0RBQStEO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDRCQUE0QjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLG9DQUFvQztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3QkFBd0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQkFBbUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsZ0RBQW1CO0FBQ3JELGdDQUFnQyxnREFBbUI7O0FBRW5EO0FBQ0E7QUFDQTtB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QVEsSUFBSSw0Q0FBNEMsR0FBRztBQUMzSjtBQUNBLG9CQUFvQixpREFBVTs7QUFFOUIsdUJBQXVCLHdLQUF3SztBQUMvTDtBQUNBO0FBQ0EsUUFBUSxzREFBZTtBQUN2QjtBQUNBLFNBQVM7QUFDVDtBQUNBLDBCQUEwQiwrQ0FBUSxjQUFjLGdEQUFNO0FBQ3RELG9CQUFvQiw2Q0FBTTtBQUMxQiwwQkFBMEIsOENBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixpQ0FBaUMsYUFBYTtBQUM5QztBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksMERBQW1CO0FBQ3ZCLHNCQUFzQiwrQ0FBUztBQUMvQixzQkFBc0IsK0NBQVE7QUFDOUIsNkJBQTZCLDhDQUFPO0FBQ3BDO0FBQ0EsS0FBSztBQUNMLFlBQVksc0RBQUcsQ0FBQywrQ0FBUyw0QkFBNEIsVUFBVSxzREFBRyx5QkFBeUIsME9BQTBPLHNEQUFHLHFDQUFxQywwQkFBMEIsc0RBQUcsa0JBQWtCLDhIQUE4SCxHQUFHLEdBQUcsR0FBRztBQUNuaUI7QUFDQSxnQkFBZ0IsNkNBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0ByZW1vdGlvbitwbGF5ZXJANC4wLjQ3X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9AcmVtb3Rpb24vcGxheWVyL2Rpc3QvZXNtL2luZGV4Lm1qcz9kYjJlIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiwgdXNlQ29udGV4dCwgdXNlQ2FsbGJhY2ssIHVzZU1lbW8sIGZvcndhcmRSZWYsIHVzZUltcGVyYXRpdmVIYW5kbGUsIFN1c3BlbnNlLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBJbnRlcm5hbHMsIHJhbmRvbSwgaW50ZXJwb2xhdGUsIENvbXBvc2l0aW9uIH0gZnJvbSAncmVtb3Rpb24nO1xuaW1wb3J0IHsganN4LCBqc3hzLCBGcmFnbWVudCB9IGZyb20gJ3JlYWN0L2pzeC1ydW50aW1lJztcblxuY29uc3QgY2FsY3VsYXRlUGxheWVyU2l6ZSA9ICh7IGN1cnJlbnRTaXplLCB3aWR0aCwgaGVpZ2h0LCBjb21wb3NpdGlvbldpZHRoLCBjb21wb3NpdGlvbkhlaWdodCwgfSkgPT4ge1xuICAgIGlmICh3aWR0aCAhPT0gdW5kZWZpbmVkICYmIGhlaWdodCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3BlY3RSYXRpbzogW2NvbXBvc2l0aW9uV2lkdGgsIGNvbXBvc2l0aW9uSGVpZ2h0XS5qb2luKCcvJyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE9wcG9zaXRlOiBJZiBoYXMgaGVpZ2h0IHNwZWNpZmllZCwgZXZhbHVhdGUgdGhlIGhlaWdodCBhbmQgc3BlY2lmeSBhIGRlZmF1bHQgd2lkdGguXG4gICAgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdpZHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIEFzcGVjdCByYXRpbyBDU1MgcHJvcCB3aWxsIHdvcmtcbiAgICAgICAgICAgIGFzcGVjdFJhdGlvOiBbY29tcG9zaXRpb25XaWR0aCwgY29tcG9zaXRpb25IZWlnaHRdLmpvaW4oJy8nKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKCFjdXJyZW50U2l6ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IGNvbXBvc2l0aW9uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogY29tcG9zaXRpb25XaWR0aCxcbiAgICAgICAgaGVpZ2h0OiBjb21wb3NpdGlvbkhlaWdodCxcbiAgICB9O1xufTtcblxuY29uc3QgY2FsY3VsYXRlU2NhbGUgPSAoeyBjYW52YXNTaXplLCBjb21wb3NpdGlvbkhlaWdodCwgY29tcG9zaXRpb25XaWR0aCwgcHJldmlld1NpemUsIH0pID0+IHtcbiAgICBjb25zdCBoZWlnaHRSYXRpbyA9IGNhbnZhc1NpemUuaGVpZ2h0IC8gY29tcG9zaXRpb25IZWlnaHQ7XG4gICAgY29uc3Qgd2lkdGhSYXRpbyA9IGNhbnZhc1NpemUud2lkdGggLyBjb21wb3NpdGlvbldpZHRoO1xuICAgIGNvbnN0IHJhdGlvID0gTWF0aC5taW4oaGVpZ2h0UmF0aW8sIHdpZHRoUmF0aW8pO1xuICAgIHJldHVybiBwcmV2aWV3U2l6ZSA9PT0gJ2F1dG8nID8gcmF0aW8gOiBOdW1iZXIocHJldmlld1NpemUpO1xufTtcbmNvbnN0IGNhbGN1bGF0ZUNhbnZhc1RyYW5zZm9ybWF0aW9uID0gKHsgcHJldmlld1NpemUsIGNvbXBvc2l0aW9uV2lkdGgsIGNvbXBvc2l0aW9uSGVpZ2h0LCBjYW52YXNTaXplLCB9KSA9PiB7XG4gICAgY29uc3Qgc2NhbGUgPSBjYWxjdWxhdGVTY2FsZSh7XG4gICAgICAgIGNhbnZhc1NpemUsXG4gICAgICAgIGNvbXBvc2l0aW9uSGVpZ2h0LFxuICAgICAgICBjb21wb3NpdGlvbldpZHRoLFxuICAgICAgICBwcmV2aWV3U2l6ZSxcbiAgICB9KTtcbiAgICBjb25zdCBjb3JyZWN0aW9uID0gMCAtICgxIC0gc2NhbGUpIC8gMjtcbiAgICBjb25zdCB4Q29ycmVjdGlvbiA9IGNvcnJlY3Rpb24gKiBjb21wb3NpdGlvbldpZHRoO1xuICAgIGNvbnN0IHlDb3JyZWN0aW9uID0gY29ycmVjdGlvbiAqIGNvbXBvc2l0aW9uSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gY29tcG9zaXRpb25XaWR0aCAqIHNjYWxlO1xuICAgIGNvbnN0IGhlaWdodCA9IGNvbXBvc2l0aW9uSGVpZ2h0ICogc2NhbGU7XG4gICAgY29uc3QgY2VudGVyWCA9IGNhbnZhc1NpemUud2lkdGggLyAyIC0gd2lkdGggLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSBjYW52YXNTaXplLmhlaWdodCAvIDIgLSBoZWlnaHQgLyAyO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNlbnRlclgsXG4gICAgICAgIGNlbnRlclksXG4gICAgICAgIHhDb3JyZWN0aW9uLFxuICAgICAgICB5Q29ycmVjdGlvbixcbiAgICAgICAgc2NhbGUsXG4gICAgfTtcbn07XG5jb25zdCBjYWxjdWxhdGVPdXRlclN0eWxlID0gKHsgY29uZmlnLCBzdHlsZSwgY2FudmFzU2l6ZSwgfSkgPT4ge1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgLi4uY2FsY3VsYXRlUGxheWVyU2l6ZSh7XG4gICAgICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICAgICAgICAgIGN1cnJlbnRTaXplOiBjYW52YXNTaXplLFxuICAgICAgICAgICAgaGVpZ2h0OiBzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHN0eWxlID09PSBudWxsIHx8IHN0eWxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZS53aWR0aCxcbiAgICAgICAgfSksXG4gICAgICAgIC4uLnN0eWxlLFxuICAgIH07XG59O1xuY29uc3QgY2FsY3VsYXRlQ29udGFpbmVyU3R5bGUgPSAoeyBjb25maWcsIGNhbnZhc1NpemUsIGxheW91dCwgc2NhbGUsIH0pID0+IHtcbiAgICBpZiAoIWNvbmZpZyB8fCAhY2FudmFzU2l6ZSB8fCAhbGF5b3V0KSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgIHdpZHRoOiBjb25maWcud2lkdGgsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICAgICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgICAgICB0cmFuc2Zvcm06IGBzY2FsZSgke3NjYWxlfSlgLFxuICAgICAgICBtYXJnaW5MZWZ0OiBsYXlvdXQueENvcnJlY3Rpb24sXG4gICAgICAgIG1hcmdpblRvcDogbGF5b3V0LnlDb3JyZWN0aW9uLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgfTtcbn07XG5jb25zdCBjYWxjdWxhdGVPdXRlciA9ICh7IGxheW91dCwgc2NhbGUsIGNvbmZpZywgfSkgPT4ge1xuICAgIGlmICghbGF5b3V0IHx8ICFjb25maWcpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBjb25zdCB7IGNlbnRlclgsIGNlbnRlclkgfSA9IGxheW91dDtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogY29uZmlnLndpZHRoICogc2NhbGUsXG4gICAgICAgIGhlaWdodDogY29uZmlnLmhlaWdodCAqIHNjYWxlLFxuICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgbGVmdDogY2VudGVyWCxcbiAgICAgICAgdG9wOiBjZW50ZXJZLFxuICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgfTtcbn07XG5cbmNvbnN0IFBsYXllckV2ZW50RW1pdHRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHVuZGVmaW5lZCk7XG5jb25zdCBUaHVtYm5haWxFbWl0dGVyQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcblxuY2xhc3MgUGxheWVyRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0ge1xuICAgICAgICAgICAgZW5kZWQ6IFtdLFxuICAgICAgICAgICAgZXJyb3I6IFtdLFxuICAgICAgICAgICAgcGF1c2U6IFtdLFxuICAgICAgICAgICAgcGxheTogW10sXG4gICAgICAgICAgICByYXRlY2hhbmdlOiBbXSxcbiAgICAgICAgICAgIHNjYWxlY2hhbmdlOiBbXSxcbiAgICAgICAgICAgIHNlZWtlZDogW10sXG4gICAgICAgICAgICB0aW1ldXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGZyYW1ldXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGZ1bGxzY3JlZW5jaGFuZ2U6IFtdLFxuICAgICAgICAgICAgdm9sdW1lY2hhbmdlOiBbXSxcbiAgICAgICAgICAgIG11dGVjaGFuZ2U6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cbiAgICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW25hbWVdID0gdGhpcy5saXN0ZW5lcnNbbmFtZV0uZmlsdGVyKChsKSA9PiBsICE9PSBjYWxsYmFjayk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXZlbnQoZGlzcGF0Y2hOYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzW2Rpc3BhdGNoTmFtZV0uZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHsgZGV0YWlsOiBjb250ZXh0IH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2hTZWVrKGZyYW1lKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnc2Vla2VkJywge1xuICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaFZvbHVtZUNoYW5nZSh2b2x1bWUpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCd2b2x1bWVjaGFuZ2UnLCB7XG4gICAgICAgICAgICB2b2x1bWUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaFBhdXNlKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3BhdXNlJywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hQbGF5KCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3BsYXknLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBkaXNwYXRjaEVuZGVkKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2VuZGVkJywgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZGlzcGF0Y2hSYXRlQ2hhbmdlKHBsYXliYWNrUmF0ZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ3JhdGVjaGFuZ2UnLCB7XG4gICAgICAgICAgICBwbGF5YmFja1JhdGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwYXRjaFNjYWxlQ2hhbmdlKHNjYWxlKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgnc2NhbGVjaGFuZ2UnLCB7XG4gICAgICAgICAgICBzY2FsZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzcGF0Y2hUaW1lVXBkYXRlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCgndGltZXVwZGF0ZScsIGV2ZW50KTtcbiAgICB9XG4gICAgZGlzcGF0Y2hGcmFtZVVwZGF0ZShldmVudCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoJ2ZyYW1ldXBkYXRlJywgZXZlbnQpO1xuICAgIH1cbiAgICBkaXNwYXRjaEZ1bGxzY3JlZW5DaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdmdWxsc2NyZWVuY2hhbmdlJywgZXZlbnQpO1xuICAgIH1cbiAgICBkaXNwYXRjaE11dGVDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdtdXRlY2hhbmdlJywgZXZlbnQpO1xuICAgIH1cbn1cbmNsYXNzIFRodW1ibmFpbEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IHtcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXS5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tuYW1lXSA9IHRoaXMubGlzdGVuZXJzW25hbWVdLmZpbHRlcigobCkgPT4gbCAhPT0gY2FsbGJhY2spO1xuICAgIH1cbiAgICBkaXNwYXRjaEV2ZW50KGRpc3BhdGNoTmFtZSwgY29udGV4dCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVyc1tkaXNwYXRjaE5hbWVdLmZvckVhY2goKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFjayh7IGRldGFpbDogY29udGV4dCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRpc3BhdGNoRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KCdlcnJvcicsIHtcbiAgICAgICAgICAgIGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IHVzZUhvdmVyU3RhdGUgPSAocmVmKSA9PiB7XG4gICAgY29uc3QgW2hvdmVyZWQsIHN0ZXRIb3ZlcmVkXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHJlZjtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25Ib3ZlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHN0ZXRIb3ZlcmVkKHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkxlYXZlID0gKCkgPT4ge1xuICAgICAgICAgICAgc3RldEhvdmVyZWQoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbkhvdmVyKTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgb25MZWF2ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBvbkhvdmVyKTtcbiAgICAgICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VlbnRlcicsIG9uTGVhdmUpO1xuICAgICAgICB9O1xuICAgIH0sIFtyZWZdKTtcbiAgICByZXR1cm4gaG92ZXJlZDtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZU5leHRGcmFtZSA9ICh7IHRpbWUsIGN1cnJlbnRGcmFtZTogc3RhcnRGcmFtZSwgcGxheWJhY2tTcGVlZCwgZnBzLCBhY3R1YWxMYXN0RnJhbWUsIGFjdHVhbEZpcnN0RnJhbWUsIGZyYW1lc0FkdmFuY2VkLCBzaG91bGRMb29wLCB9KSA9PiB7XG4gICAgY29uc3Qgb3AgPSBwbGF5YmFja1NwZWVkIDwgMCA/IE1hdGguY2VpbCA6IE1hdGguZmxvb3I7XG4gICAgY29uc3QgZnJhbWVzVG9BZHZhbmNlID0gb3AoKHRpbWUgKiBwbGF5YmFja1NwZWVkKSAvICgxMDAwIC8gZnBzKSkgLSBmcmFtZXNBZHZhbmNlZDtcbiAgICBjb25zdCBuZXh0RnJhbWUgPSBmcmFtZXNUb0FkdmFuY2UgKyBzdGFydEZyYW1lO1xuICAgIGNvbnN0IGlzQ3VycmVudEZyYW1lT3V0c2lkZSA9IHN0YXJ0RnJhbWUgPiBhY3R1YWxMYXN0RnJhbWUgfHwgc3RhcnRGcmFtZSA8IGFjdHVhbEZpcnN0RnJhbWU7XG4gICAgY29uc3QgaXNOZXh0RnJhbWVPdXRzaWRlID0gbmV4dEZyYW1lID4gYWN0dWFsTGFzdEZyYW1lIHx8IG5leHRGcmFtZSA8IGFjdHVhbEZpcnN0RnJhbWU7XG4gICAgY29uc3QgaGFzRW5kZWQgPSAhc2hvdWxkTG9vcCAmJiBpc05leHRGcmFtZU91dHNpZGUgJiYgIWlzQ3VycmVudEZyYW1lT3V0c2lkZTtcbiAgICBpZiAocGxheWJhY2tTcGVlZCA+IDApIHtcbiAgICAgICAgLy8gUGxheSBmb3J3YXJkc1xuICAgICAgICBpZiAoaXNOZXh0RnJhbWVPdXRzaWRlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5leHRGcmFtZTogYWN0dWFsRmlyc3RGcmFtZSxcbiAgICAgICAgICAgICAgICBmcmFtZXNUb0FkdmFuY2UsXG4gICAgICAgICAgICAgICAgaGFzRW5kZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5leHRGcmFtZSwgZnJhbWVzVG9BZHZhbmNlLCBoYXNFbmRlZCB9O1xuICAgIH1cbiAgICAvLyBSZXZlcnNlIHBsYXliYWNrXG4gICAgaWYgKGlzTmV4dEZyYW1lT3V0c2lkZSkge1xuICAgICAgICByZXR1cm4geyBuZXh0RnJhbWU6IGFjdHVhbExhc3RGcmFtZSwgZnJhbWVzVG9BZHZhbmNlLCBoYXNFbmRlZCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBuZXh0RnJhbWUsIGZyYW1lc1RvQWR2YW5jZSwgaGFzRW5kZWQgfTtcbn07XG5cbmNvbnN0IGdldElzQmFja2dyb3VuZGVkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG59O1xuY29uc3QgdXNlSXNCYWNrZ3JvdW5kZWQgPSAoKSA9PiB7XG4gICAgY29uc3QgaXNCYWNrZ3JvdW5kZWQgPSB1c2VSZWYoZ2V0SXNCYWNrZ3JvdW5kZWQoKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgb25WaXNpYmlsaXR5Q2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgaXNCYWNrZ3JvdW5kZWQuY3VycmVudCA9IGdldElzQmFja2dyb3VuZGVkKCk7XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCBvblZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpc0JhY2tncm91bmRlZDtcbn07XG5cbmNvbnN0IHVzZVBsYXllciA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgW3BsYXlpbmcsIHNldFBsYXlpbmcsIGltcGVyYXRpdmVQbGF5aW5nXSA9IEludGVybmFscy5UaW1lbGluZS51c2VQbGF5aW5nU3RhdGUoKTtcbiAgICBjb25zdCBbaGFzUGxheWVkLCBzZXRIYXNQbGF5ZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGZyYW1lID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgICBjb25zdCBwbGF5U3RhcnQgPSB1c2VSZWYoZnJhbWUpO1xuICAgIGNvbnN0IHNldEZyYW1lID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lU2V0RnJhbWUoKTtcbiAgICBjb25zdCBzZXRUaW1lbGluZVBvc2l0aW9uID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lU2V0RnJhbWUoKTtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSB1c2VDb250ZXh0KEludGVybmFscy5TaGFyZWRBdWRpb0NvbnRleHQpO1xuICAgIGNvbnN0IHsgYXVkaW9BbmRWaWRlb1RhZ3MgfSA9IHVzZUNvbnRleHQoSW50ZXJuYWxzLlRpbWVsaW5lLlRpbWVsaW5lQ29udGV4dCk7XG4gICAgY29uc3QgZnJhbWVSZWYgPSB1c2VSZWYoKTtcbiAgICBmcmFtZVJlZi5jdXJyZW50ID0gZnJhbWU7XG4gICAgY29uc3QgdmlkZW8gPSBJbnRlcm5hbHMudXNlVmlkZW8oKTtcbiAgICBjb25zdCBjb25maWcgPSBJbnRlcm5hbHMudXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCBlbWl0dGVyID0gdXNlQ29udGV4dChQbGF5ZXJFdmVudEVtaXR0ZXJDb250ZXh0KTtcbiAgICBjb25zdCBsYXN0RnJhbWUgPSAoKF9hID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmR1cmF0aW9uSW5GcmFtZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDEpIC0gMTtcbiAgICBjb25zdCBpc0xhc3RGcmFtZSA9IGZyYW1lID09PSBsYXN0RnJhbWU7XG4gICAgY29uc3QgaXNGaXJzdEZyYW1lID0gZnJhbWUgPT09IDA7XG4gICAgaWYgKCFlbWl0dGVyKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFBsYXllciBldmVudCBlbWl0dGVyIGNvbnRleHQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlayA9IHVzZUNhbGxiYWNrKChuZXdGcmFtZSkgPT4ge1xuICAgICAgICBpZiAodmlkZW8gPT09IG51bGwgfHwgdmlkZW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvLmlkKSB7XG4gICAgICAgICAgICBzZXRUaW1lbGluZVBvc2l0aW9uKChjKSA9PiAoeyAuLi5jLCBbdmlkZW8uaWRdOiBuZXdGcmFtZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZW1pdHRlci5kaXNwYXRjaFNlZWsobmV3RnJhbWUpO1xuICAgIH0sIFtlbWl0dGVyLCBzZXRUaW1lbGluZVBvc2l0aW9uLCB2aWRlbyA9PT0gbnVsbCB8fCB2aWRlbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW8uaWRdKTtcbiAgICBjb25zdCBwbGF5ID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgaWYgKGltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRIYXNQbGF5ZWQodHJ1ZSk7XG4gICAgICAgIGlmIChpc0xhc3RGcmFtZSkge1xuICAgICAgICAgICAgc2VlaygwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGxheSBzaWxlbnQgYXVkaW8gdGFncyB0byB3YXJtIHRoZW0gdXAgZm9yIGF1dG9wbGF5XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoYXVkaW9Db250ZXh0ICYmIGF1ZGlvQ29udGV4dC5udW1iZXJPZkF1ZGlvVGFncyA+IDAgJiYgZSkge1xuICAgICAgICAgICAgYXVkaW9Db250ZXh0LnBsYXlBbGxBdWRpb3MoKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogUGxheSBhdWRpb3MgYW5kIHZpZGVvcyBkaXJlY3RseSBoZXJlIHNvIHRoZXkgY2FuIGJlbmVmaXQgZnJvbVxuICAgICAgICAgKiBiZWluZyB0cmlnZ2VyZWQgYnkgYSBjbGlja1xuICAgICAgICAgKi9cbiAgICAgICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudC5mb3JFYWNoKChhKSA9PiBhLnBsYXkoKSk7XG4gICAgICAgIGltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBzZXRQbGF5aW5nKHRydWUpO1xuICAgICAgICBwbGF5U3RhcnQuY3VycmVudCA9IGZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgIGVtaXR0ZXIuZGlzcGF0Y2hQbGF5KCk7XG4gICAgfSwgW1xuICAgICAgICBpbXBlcmF0aXZlUGxheWluZyxcbiAgICAgICAgaXNMYXN0RnJhbWUsXG4gICAgICAgIGF1ZGlvQ29udGV4dCxcbiAgICAgICAgc2V0UGxheWluZyxcbiAgICAgICAgZW1pdHRlcixcbiAgICAgICAgc2VlayxcbiAgICAgICAgYXVkaW9BbmRWaWRlb1RhZ3MsXG4gICAgXSk7XG4gICAgY29uc3QgcGF1c2UgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChpbXBlcmF0aXZlUGxheWluZy5jdXJyZW50KSB7XG4gICAgICAgICAgICBpbXBlcmF0aXZlUGxheWluZy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBzZXRQbGF5aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGVtaXR0ZXIuZGlzcGF0Y2hQYXVzZSgpO1xuICAgICAgICB9XG4gICAgfSwgW2VtaXR0ZXIsIGltcGVyYXRpdmVQbGF5aW5nLCBzZXRQbGF5aW5nXSk7XG4gICAgY29uc3QgcGF1c2VBbmRSZXR1cm5Ub1BsYXlTdGFydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChjb25maWcpIHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lbGluZVBvc2l0aW9uKChjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgICAgICAgICBbY29uZmlnLmlkXTogcGxheVN0YXJ0LmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHNldFBsYXlpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZGlzcGF0Y2hQYXVzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW2NvbmZpZywgZW1pdHRlciwgaW1wZXJhdGl2ZVBsYXlpbmcsIHNldFBsYXlpbmcsIHNldFRpbWVsaW5lUG9zaXRpb25dKTtcbiAgICBjb25zdCB2aWRlb0lkID0gdmlkZW8gPT09IG51bGwgfHwgdmlkZW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvLmlkO1xuICAgIGNvbnN0IGZyYW1lQmFjayA9IHVzZUNhbGxiYWNrKChmcmFtZXMpID0+IHtcbiAgICAgICAgaWYgKCF2aWRlb0lkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW1wZXJhdGl2ZVBsYXlpbmcuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldEZyYW1lKChjKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgY29uc3QgcHJldiA9IChfYiA9IChfYSA9IGNbdmlkZW9JZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmMsXG4gICAgICAgICAgICAgICAgW3ZpZGVvSWRdOiBNYXRoLm1heCgwLCBwcmV2IC0gZnJhbWVzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sIFtpbXBlcmF0aXZlUGxheWluZywgc2V0RnJhbWUsIHZpZGVvSWRdKTtcbiAgICBjb25zdCBmcmFtZUZvcndhcmQgPSB1c2VDYWxsYmFjaygoZnJhbWVzKSA9PiB7XG4gICAgICAgIGlmICghdmlkZW9JZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGltcGVyYXRpdmVQbGF5aW5nLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRGcmFtZSgoYykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSAoX2IgPSAoX2EgPSBjW3ZpZGVvSWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jLFxuICAgICAgICAgICAgICAgIFt2aWRlb0lkXTogTWF0aC5taW4obGFzdEZyYW1lLCBwcmV2ICsgZnJhbWVzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH0sIFt2aWRlb0lkLCBpbXBlcmF0aXZlUGxheWluZywgbGFzdEZyYW1lLCBzZXRGcmFtZV0pO1xuICAgIGNvbnN0IHJldHVyblZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcmFtZUJhY2ssXG4gICAgICAgICAgICBmcmFtZUZvcndhcmQsXG4gICAgICAgICAgICBpc0xhc3RGcmFtZSxcbiAgICAgICAgICAgIGVtaXR0ZXIsXG4gICAgICAgICAgICBwbGF5aW5nLFxuICAgICAgICAgICAgcGxheSxcbiAgICAgICAgICAgIHBhdXNlLFxuICAgICAgICAgICAgc2VlayxcbiAgICAgICAgICAgIGlzRmlyc3RGcmFtZSxcbiAgICAgICAgICAgIGdldEN1cnJlbnRGcmFtZTogKCkgPT4gZnJhbWVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIGlzUGxheWluZzogKCkgPT4gaW1wZXJhdGl2ZVBsYXlpbmcuY3VycmVudCxcbiAgICAgICAgICAgIHBhdXNlQW5kUmV0dXJuVG9QbGF5U3RhcnQsXG4gICAgICAgICAgICBoYXNQbGF5ZWQsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBmcmFtZUJhY2ssXG4gICAgICAgIGZyYW1lRm9yd2FyZCxcbiAgICAgICAgaXNMYXN0RnJhbWUsXG4gICAgICAgIGVtaXR0ZXIsXG4gICAgICAgIHBsYXlpbmcsXG4gICAgICAgIHBsYXksXG4gICAgICAgIHBhdXNlLFxuICAgICAgICBzZWVrLFxuICAgICAgICBpc0ZpcnN0RnJhbWUsXG4gICAgICAgIHBhdXNlQW5kUmV0dXJuVG9QbGF5U3RhcnQsXG4gICAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgICBoYXNQbGF5ZWQsXG4gICAgXSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVzZS1iZWZvcmUtZGVmaW5lICovXG5jb25zdCB1c2VQbGF5YmFjayA9ICh7IGxvb3AsIHBsYXliYWNrUmF0ZSwgbW92ZVRvQmVnaW5uaW5nV2hlbkVuZGVkLCBpbkZyYW1lLCBvdXRGcmFtZSwgfSkgPT4ge1xuICAgIGNvbnN0IGNvbmZpZyA9IEludGVybmFscy51c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICAgIGNvbnN0IGZyYW1lID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgICBjb25zdCB7IHBsYXlpbmcsIHBhdXNlLCBlbWl0dGVyIH0gPSB1c2VQbGF5ZXIoKTtcbiAgICBjb25zdCBzZXRGcmFtZSA9IEludGVybmFscy5UaW1lbGluZS51c2VUaW1lbGluZVNldEZyYW1lKCk7XG4gICAgLy8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCkgZG9lcyBub3Qgd29yayBpZiB0aGUgdGFiIGlzIG5vdCBhY3RpdmUuXG4gICAgLy8gVGhpcyBtZWFucyB0aGF0IGF1ZGlvIHdpbGwga2VlcCBwbGF5aW5nIGV2ZW4gaWYgaXQgaGFzIGVuZGVkLlxuICAgIC8vIEluIHRoYXQgY2FzZSwgd2UgdXNlIHNldFRpbWVvdXQoKSBpbnN0ZWFkLlxuICAgIGNvbnN0IGlzQmFja2dyb3VuZGVkUmVmID0gdXNlSXNCYWNrZ3JvdW5kZWQoKTtcbiAgICBjb25zdCBmcmFtZVJlZiA9IHVzZVJlZihmcmFtZSk7XG4gICAgZnJhbWVSZWYuY3VycmVudCA9IGZyYW1lO1xuICAgIGNvbnN0IGxhc3RUaW1lVXBkYXRlRXZlbnQgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYXlpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaGFzQmVlblN0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlcUFuaW1GcmFtZUNhbGwgPSBudWxsO1xuICAgICAgICBjb25zdCBzdGFydGVkVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICBsZXQgZnJhbWVzQWR2YW5jZWQgPSAwO1xuICAgICAgICBjb25zdCBjYW5jZWxRdWV1ZWRGcmFtZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXFBbmltRnJhbWVDYWxsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcUFuaW1GcmFtZUNhbGwudHlwZSA9PT0gJ3JhZicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUocmVxQW5pbUZyYW1lQ2FsbC5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxQW5pbUZyYW1lQ2FsbC5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgaGFzQmVlblN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgY2FuY2VsUXVldWVkRnJhbWUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0aW1lID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydGVkVGltZTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbExhc3RGcmFtZSA9IG91dEZyYW1lICE9PSBudWxsICYmIG91dEZyYW1lICE9PSB2b2lkIDAgPyBvdXRGcmFtZSA6IGNvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbEZpcnN0RnJhbWUgPSBpbkZyYW1lICE9PSBudWxsICYmIGluRnJhbWUgIT09IHZvaWQgMCA/IGluRnJhbWUgOiAwO1xuICAgICAgICAgICAgY29uc3QgeyBuZXh0RnJhbWUsIGZyYW1lc1RvQWR2YW5jZSwgaGFzRW5kZWQgfSA9IGNhbGN1bGF0ZU5leHRGcmFtZSh7XG4gICAgICAgICAgICAgICAgdGltZSxcbiAgICAgICAgICAgICAgICBjdXJyZW50RnJhbWU6IGZyYW1lUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgcGxheWJhY2tTcGVlZDogcGxheWJhY2tSYXRlLFxuICAgICAgICAgICAgICAgIGZwczogY29uZmlnLmZwcyxcbiAgICAgICAgICAgICAgICBhY3R1YWxGaXJzdEZyYW1lLFxuICAgICAgICAgICAgICAgIGFjdHVhbExhc3RGcmFtZSxcbiAgICAgICAgICAgICAgICBmcmFtZXNBZHZhbmNlZCxcbiAgICAgICAgICAgICAgICBzaG91bGRMb29wOiBsb29wLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBmcmFtZXNBZHZhbmNlZCArPSBmcmFtZXNUb0FkdmFuY2U7XG4gICAgICAgICAgICBpZiAobmV4dEZyYW1lICE9PSBmcmFtZVJlZi5jdXJyZW50ICYmXG4gICAgICAgICAgICAgICAgKCFoYXNFbmRlZCB8fCBtb3ZlVG9CZWdpbm5pbmdXaGVuRW5kZWQpKSB7XG4gICAgICAgICAgICAgICAgc2V0RnJhbWUoKGMpID0+ICh7IC4uLmMsIFtjb25maWcuaWRdOiBuZXh0RnJhbWUgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc0VuZGVkKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgICAgICAgICAgZW1pdHRlci5kaXNwYXRjaEVuZGVkKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFoYXNCZWVuU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIHF1ZXVlTmV4dEZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHF1ZXVlTmV4dEZyYW1lID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQmFja2dyb3VuZGVkUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXFBbmltRnJhbWVDYWxsID0ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAndGltZW91dCcsXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IE1vc3QgbGlrZWx5LCB0aGlzIHdpbGwgbm90IGJlIDEwMDAgLyBmcHMsIGJ1dCB0aGUgYnJvd3NlciB3aWxsIHRocm90dGxlIGl0IHRvIH4xL3NlYy5cbiAgICAgICAgICAgICAgICAgICAgaWQ6IHNldFRpbWVvdXQoY2FsbGJhY2ssIDEwMDAgLyBjb25maWcuZnBzKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxQW5pbUZyYW1lQ2FsbCA9IHsgdHlwZTogJ3JhZicsIGlkOiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2spIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHF1ZXVlTmV4dEZyYW1lKCk7XG4gICAgICAgIGNvbnN0IG9uVmlzaWJpbGl0eUNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICd2aXNpYmxlJykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRhYiBnb2VzIGludG8gdGhlIGJhY2tncm91bmQsIGNhbmNlbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSBhbmQgdXBkYXRlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgLy8gLCBzbyB0aGUgdHJhbnNpdGlvbiB0byBzZXRUaW1lb3V0KCkgY2FuIGJlIGZ1bGZpbGxlZC5cbiAgICAgICAgICAgIGNhbmNlbFF1ZXVlZEZyYW1lKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndmlzaWJpbGl0eWNoYW5nZScsIG9uVmlzaWJpbGl0eUNoYW5nZSk7XG4gICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjb25maWcsXG4gICAgICAgIGxvb3AsXG4gICAgICAgIHBhdXNlLFxuICAgICAgICBwbGF5aW5nLFxuICAgICAgICBzZXRGcmFtZSxcbiAgICAgICAgZW1pdHRlcixcbiAgICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgICBpbkZyYW1lLFxuICAgICAgICBvdXRGcmFtZSxcbiAgICAgICAgbW92ZVRvQmVnaW5uaW5nV2hlbkVuZGVkLFxuICAgICAgICBpc0JhY2tncm91bmRlZFJlZixcbiAgICBdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmIChsYXN0VGltZVVwZGF0ZUV2ZW50LmN1cnJlbnQgPT09IGZyYW1lUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbWl0dGVyLmRpc3BhdGNoVGltZVVwZGF0ZSh7IGZyYW1lOiBmcmFtZVJlZi5jdXJyZW50IH0pO1xuICAgICAgICAgICAgbGFzdFRpbWVVcGRhdGVFdmVudC5jdXJyZW50ID0gZnJhbWVSZWYuY3VycmVudDtcbiAgICAgICAgfSwgMjUwKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICAgIH0sIFtlbWl0dGVyXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZW1pdHRlci5kaXNwYXRjaEZyYW1lVXBkYXRlKHsgZnJhbWUgfSk7XG4gICAgfSwgW2VtaXR0ZXIsIGZyYW1lXSk7XG59O1xuXG5sZXQgZWxlbWVudFNpemVIb29rcyA9IFtdO1xuY29uc3QgdXBkYXRlQWxsRWxlbWVudHNTaXplcyA9ICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGVsZW1lbnRTaXplSG9va3MpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICB9XG59O1xuY29uc3QgdXNlRWxlbWVudFNpemUgPSAocmVmLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgW3NpemUsIHNldFNpemVdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWN0ID0gcmVmLmN1cnJlbnQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgaWYgKCFyZWN0WzBdKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IHJlY3RbMF0ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHJlY3RbMF0uaGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogcmVjdFswXS54LFxuICAgICAgICAgICAgdG9wOiByZWN0WzBdLnksXG4gICAgICAgICAgICB3aW5kb3dTaXplOiB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCBvYnNlcnZlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZXNpemVPYnNlcnZlcigoZW50cmllcykgPT4ge1xuICAgICAgICAgICAgLy8gVGhlIGNvbnRlbnRSZWN0IHJldHVybnMgdGhlIHdpZHRoIHdpdGhvdXQgYW55IGBzY2FsZSgpYCdzIGJlaW5nIGFwcGxpZWQuIFRoZSBoZWlnaHQgaXMgd3JvbmdcbiAgICAgICAgICAgIGNvbnN0IHsgY29udGVudFJlY3QsIHRhcmdldCB9ID0gZW50cmllc1swXTtcbiAgICAgICAgICAgIC8vIFRoZSBjbGllbnRSZWN0IHJldHVybnMgdGhlIHNpemUgd2l0aCBgc2NhbGUoKWAgYmVpbmcgYXBwbGllZC5cbiAgICAgICAgICAgIGNvbnN0IG5ld1NpemUgPSB0YXJnZXQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgICAgIGlmICghKG5ld1NpemUgPT09IG51bGwgfHwgbmV3U2l6ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV3U2l6ZVswXSkpIHtcbiAgICAgICAgICAgICAgICBzZXRTaXplKG51bGwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2JhYmxlQ3NzUGFyZW50U2NhbGUgPSBjb250ZW50UmVjdC53aWR0aCA9PT0gMCA/IDEgOiBuZXdTaXplWzBdLndpZHRoIC8gY29udGVudFJlY3Qud2lkdGg7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IG9wdGlvbnMuc2hvdWxkQXBwbHlDc3NUcmFuc2Zvcm1zXG4gICAgICAgICAgICAgICAgPyBuZXdTaXplWzBdLndpZHRoXG4gICAgICAgICAgICAgICAgOiBuZXdTaXplWzBdLndpZHRoICogKDEgLyBwcm9iYWJsZUNzc1BhcmVudFNjYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IG9wdGlvbnMuc2hvdWxkQXBwbHlDc3NUcmFuc2Zvcm1zXG4gICAgICAgICAgICAgICAgPyBuZXdTaXplWzBdLmhlaWdodFxuICAgICAgICAgICAgICAgIDogbmV3U2l6ZVswXS5oZWlnaHQgKiAoMSAvIHByb2JhYmxlQ3NzUGFyZW50U2NhbGUpO1xuICAgICAgICAgICAgc2V0U2l6ZSh7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgIGxlZnQ6IG5ld1NpemVbMF0ueCxcbiAgICAgICAgICAgICAgICB0b3A6IG5ld1NpemVbMF0ueSxcbiAgICAgICAgICAgICAgICB3aW5kb3dTaXplOiB7XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LCBbb3B0aW9ucy5zaG91bGRBcHBseUNzc1RyYW5zZm9ybXNdKTtcbiAgICBjb25zdCB1cGRhdGVTaXplID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjdCA9IHJlZi5jdXJyZW50LmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgIGlmICghcmVjdFswXSkge1xuICAgICAgICAgICAgc2V0U2l6ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRTaXplKChwcmV2U3RhdGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZSA9IHByZXZTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZS53aWR0aCA9PT0gcmVjdFswXS53aWR0aCAmJlxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZS5oZWlnaHQgPT09IHJlY3RbMF0uaGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgcHJldlN0YXRlLmxlZnQgPT09IHJlY3RbMF0ueCAmJlxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZS50b3AgPT09IHJlY3RbMF0ueSAmJlxuICAgICAgICAgICAgICAgIHByZXZTdGF0ZS53aW5kb3dTaXplLmhlaWdodCA9PT0gd2luZG93LmlubmVySGVpZ2h0ICYmXG4gICAgICAgICAgICAgICAgcHJldlN0YXRlLndpbmRvd1NpemUud2lkdGggPT09IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgICAgICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiByZWN0WzBdLndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVjdFswXS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdDogcmVjdFswXS54LFxuICAgICAgICAgICAgICAgIHRvcDogcmVjdFswXS55LFxuICAgICAgICAgICAgICAgIHdpbmRvd1NpemU6IHtcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3JlZl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghb2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHJlZjtcbiAgICAgICAgaWYgKHJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW29ic2VydmVyLCByZWYsIHVwZGF0ZVNpemVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIW9wdGlvbnMudHJpZ2dlck9uV2luZG93UmVzaXplKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVNpemUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHVwZGF0ZVNpemUpO1xuICAgICAgICB9O1xuICAgIH0sIFtvcHRpb25zLnRyaWdnZXJPbldpbmRvd1Jlc2l6ZSwgdXBkYXRlU2l6ZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGVsZW1lbnRTaXplSG9va3MucHVzaCh1cGRhdGVTaXplKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGVsZW1lbnRTaXplSG9va3MgPSBlbGVtZW50U2l6ZUhvb2tzLmZpbHRlcigoZSkgPT4gZSAhPT0gdXBkYXRlU2l6ZSk7XG4gICAgICAgIH07XG4gICAgfSwgW3VwZGF0ZVNpemVdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uc2l6ZSwgcmVmcmVzaDogdXBkYXRlU2l6ZSB9O1xuICAgIH0sIFtzaXplLCB1cGRhdGVTaXplXSk7XG59O1xuXG5jb25zdCBQTEFZRVJfQ1NTX0NMQVNTTkFNRSA9ICdfX3JlbW90aW9uLXBsYXllcic7XG5cbmNvbnN0IGVycm9yU3R5bGUgPSB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBmbGV4OiAxLFxuICAgIGhlaWdodDogJzEwMCUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG59O1xuY2xhc3MgRXJyb3JCb3VuZGFyeSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB7IGhhc0Vycm9yOiBudWxsIH07XG4gICAgfVxuICAgIHN0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgLy8gVXBkYXRlIHN0YXRlIHNvIHRoZSBuZXh0IHJlbmRlciB3aWxsIHNob3cgdGhlIGZhbGxiYWNrIFVJLlxuICAgICAgICByZXR1cm4geyBoYXNFcnJvcjogZXJyb3IgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkVycm9yKGVycm9yKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5oYXNFcnJvcikge1xuICAgICAgICAgICAgLy8gWW91IGNhbiByZW5kZXIgYW55IGN1c3RvbSBmYWxsYmFjayBVSVxuICAgICAgICAgICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBzdHlsZTogZXJyb3JTdHlsZSwgY2hpbGRyZW46IHRoaXMucHJvcHMuZXJyb3JGYWxsYmFjayh7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiB0aGlzLnN0YXRlLmhhc0Vycm9yLFxuICAgICAgICAgICAgICAgIH0pIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG59XG5cbmNvbnN0IGZvcm1hdFRpbWUgPSAodGltZUluU2Vjb25kcykgPT4ge1xuICAgIGNvbnN0IG1pbnV0ZXMgPSBNYXRoLmZsb29yKHRpbWVJblNlY29uZHMgLyA2MCk7XG4gICAgY29uc3Qgc2Vjb25kcyA9IE1hdGguZmxvb3IodGltZUluU2Vjb25kcyAtIG1pbnV0ZXMgKiA2MCk7XG4gICAgcmV0dXJuIGAke1N0cmluZyhtaW51dGVzKX06JHtTdHJpbmcoc2Vjb25kcykucGFkU3RhcnQoMiwgJzAnKX1gO1xufTtcblxuY29uc3QgSUNPTl9TSVpFID0gMjU7XG5jb25zdCBmdWxsc2NyZWVuSWNvblNpemUgPSAxNjtcbmNvbnN0IFBsYXlJY29uID0gKCkgPT4ge1xuICAgIHJldHVybiAoanN4KFwic3ZnXCIsIHsgd2lkdGg6IElDT05fU0laRSwgaGVpZ2h0OiBJQ09OX1NJWkUsIHZpZXdCb3g6IFwiMCAwIDI1IDI1XCIsIGZpbGw6IFwibm9uZVwiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTggNi4zNzVDNy40MDkwNCA4LjE3NTc2IDcuMDY5MjEgMTAuMjQ4NiA3LjAxNDM4IDEyLjM4NzFDNi45NTk1NSAxNC41MjU1IDcuMTkxNjMgMTYuNjU0NyA3LjY4NzUgMTguNTYyNUM5Ljk1MzY0IDE4LjI5OTUgMTIuMTE2IDE3LjYxNjQgMTQuMDA5IDE2LjU2NTVDMTUuOTAyIDE1LjUxNDcgMTcuNDc1NSAxNC4xMjQgMTguNjA4OCAxMi41QzE3LjUxNTggMTAuODk0OSAxNS45OTQ5IDkuNTExMDMgMTQuMTU4NSA4LjQ1MDgyQzEyLjMyMjIgNy4zOTA2IDEwLjIxNzQgNi42ODExNiA4IDYuMzc1WlwiLCBmaWxsOiBcIndoaXRlXCIsIHN0cm9rZTogXCJ3aGl0ZVwiLCBzdHJva2VXaWR0aDogXCI2LjI1XCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIgfSkgfSkpO1xufTtcbmNvbnN0IFBhdXNlSWNvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCAxMDAgMTAwXCIsIHdpZHRoOiBJQ09OX1NJWkUsIGhlaWdodDogSUNPTl9TSVpFLCBjaGlsZHJlbjogW2pzeChcInJlY3RcIiwgeyB4OiBcIjI1XCIsIHk6IFwiMjBcIiwgd2lkdGg6IFwiMjBcIiwgaGVpZ2h0OiBcIjYwXCIsIGZpbGw6IFwiI2ZmZlwiLCByeTogXCI1XCIsIHJ4OiBcIjVcIiB9KSwganN4KFwicmVjdFwiLCB7IHg6IFwiNTVcIiwgeTogXCIyMFwiLCB3aWR0aDogXCIyMFwiLCBoZWlnaHQ6IFwiNjBcIiwgZmlsbDogXCIjZmZmXCIsIHJ5OiBcIjVcIiwgcng6IFwiNVwiIH0pXSB9KSk7XG59O1xuY29uc3QgRnVsbHNjcmVlbkljb24gPSAoeyBpc0Z1bGxzY3JlZW4sIH0pID0+IHtcbiAgICBjb25zdCBzdHJva2VXaWR0aCA9IDY7XG4gICAgY29uc3Qgdmlld1NpemUgPSAzMjtcbiAgICBjb25zdCBvdXQgPSBpc0Z1bGxzY3JlZW4gPyAwIDogc3Ryb2tlV2lkdGggLyAyO1xuICAgIGNvbnN0IG1pZGRsZUluc2V0ID0gaXNGdWxsc2NyZWVuID8gc3Ryb2tlV2lkdGggKiAxLjYgOiBzdHJva2VXaWR0aCAvIDI7XG4gICAgY29uc3QgaW5zZXQgPSBpc0Z1bGxzY3JlZW4gPyBzdHJva2VXaWR0aCAqIDEuNiA6IHN0cm9rZVdpZHRoICogMjtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyB2aWV3Qm94OiBgMCAwICR7dmlld1NpemV9ICR7dmlld1NpemV9YCwgaGVpZ2h0OiBmdWxsc2NyZWVuSWNvblNpemUsIHdpZHRoOiBmdWxsc2NyZWVuSWNvblNpemUsIGNoaWxkcmVuOiBbanN4KFwicGF0aFwiLCB7IGQ6IGBcblx0XHRcdFx0TSAke291dH0gJHtpbnNldH1cblx0XHRcdFx0TCAke21pZGRsZUluc2V0fSAke21pZGRsZUluc2V0fVxuXHRcdFx0XHRMICR7aW5zZXR9ICR7b3V0fVxuXHRcdFx0XHRgLCBzdHJva2U6IFwiI2ZmZlwiLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsIGZpbGw6IFwibm9uZVwiIH0pLCBqc3goXCJwYXRoXCIsIHsgZDogYFxuXHRcdFx0XHRNICR7dmlld1NpemUgLSBvdXR9ICR7aW5zZXR9XG5cdFx0XHRcdEwgJHt2aWV3U2l6ZSAtIG1pZGRsZUluc2V0fSAke21pZGRsZUluc2V0fVxuXHRcdFx0XHRMICR7dmlld1NpemUgLSBpbnNldH0gJHtvdXR9XG5cdFx0XHRcdGAsIHN0cm9rZTogXCIjZmZmXCIsIHN0cm9rZVdpZHRoOiBzdHJva2VXaWR0aCwgZmlsbDogXCJub25lXCIgfSksIGpzeChcInBhdGhcIiwgeyBkOiBgXG5cdFx0XHRcdE0gJHtvdXR9ICR7dmlld1NpemUgLSBpbnNldH1cblx0XHRcdFx0TCAke21pZGRsZUluc2V0fSAke3ZpZXdTaXplIC0gbWlkZGxlSW5zZXR9XG5cdFx0XHRcdEwgJHtpbnNldH0gJHt2aWV3U2l6ZSAtIG91dH1cblx0XHRcdFx0YCwgc3Ryb2tlOiBcIiNmZmZcIiwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoLCBmaWxsOiBcIm5vbmVcIiB9KSwganN4KFwicGF0aFwiLCB7IGQ6IGBcblx0XHRcdFx0TSAke3ZpZXdTaXplIC0gb3V0fSAke3ZpZXdTaXplIC0gaW5zZXR9XG5cdFx0XHRcdEwgJHt2aWV3U2l6ZSAtIG1pZGRsZUluc2V0fSAke3ZpZXdTaXplIC0gbWlkZGxlSW5zZXR9XG5cdFx0XHRcdEwgJHt2aWV3U2l6ZSAtIGluc2V0fSAke3ZpZXdTaXplIC0gb3V0fVxuXHRcdFx0XHRgLCBzdHJva2U6IFwiI2ZmZlwiLCBzdHJva2VXaWR0aDogc3Ryb2tlV2lkdGgsIGZpbGw6IFwibm9uZVwiIH0pXSB9KSk7XG59O1xuY29uc3QgVm9sdW1lT2ZmSWNvbiA9ICgpID0+IHtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHdpZHRoOiBJQ09OX1NJWkUsIGhlaWdodDogSUNPTl9TSVpFLCB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjMgMy42M2EuOTk2Ljk5NiAwIDAwMCAxLjQxTDcuMjkgOC43IDcgOUg0Yy0uNTUgMC0xIC40NS0xIDF2NGMwIC41NS40NSAxIDEgMWgzbDMuMjkgMy4yOWMuNjMuNjMgMS43MS4xOCAxLjcxLS43MXYtNC4xN2w0LjE4IDQuMThjLS40OS4zNy0xLjAyLjY4LTEuNi45MS0uMzYuMTUtLjU4LjUzLS41OC45MiAwIC43Mi43MyAxLjE4IDEuMzkuOTEuOC0uMzMgMS41NS0uNzcgMi4yMi0xLjMxbDEuMzQgMS4zNGEuOTk2Ljk5NiAwIDEwMS40MS0xLjQxTDUuMDUgMy42M2MtLjM5LS4zOS0xLjAyLS4zOS0xLjQyIDB6TTE5IDEyYzAgLjgyLS4xNSAxLjYxLS40MSAyLjM0bDEuNTMgMS41M2MuNTYtMS4xNy44OC0yLjQ4Ljg4LTMuODcgMC0zLjgzLTIuNC03LjExLTUuNzgtOC40LS41OS0uMjMtMS4yMi4yMy0xLjIyLjg2di4xOWMwIC4zOC4yNS43MS42MS44NUMxNy4xOCA2LjU0IDE5IDkuMDYgMTkgMTJ6bS04LjcxLTYuMjlsLS4xNy4xN0wxMiA3Ljc2VjYuNDFjMC0uODktMS4wOC0xLjMzLTEuNzEtLjd6TTE2LjUgMTJBNC41IDQuNSAwIDAwMTQgNy45N3YxLjc5bDIuNDggMi40OGMuMDEtLjA4LjAyLS4xNi4wMi0uMjR6XCIsIGZpbGw6IFwiI2ZmZlwiIH0pIH0pKTtcbn07XG5jb25zdCBWb2x1bWVPbkljb24gPSAoKSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB3aWR0aDogSUNPTl9TSVpFLCBoZWlnaHQ6IElDT05fU0laRSwgdmlld0JveDogXCIwIDAgMjQgMjRcIiwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBkOiBcIk0zIDEwdjRjMCAuNTUuNDUgMSAxIDFoM2wzLjI5IDMuMjljLjYzLjYzIDEuNzEuMTggMS43MS0uNzFWNi40MWMwLS44OS0xLjA4LTEuMzQtMS43MS0uNzFMNyA5SDRjLS41NSAwLTEgLjQ1LTEgMXptMTMuNSAyQTQuNSA0LjUgMCAwMDE0IDcuOTd2OC4wNWMxLjQ4LS43MyAyLjUtMi4yNSAyLjUtNC4wMnpNMTQgNC40NXYuMmMwIC4zOC4yNS43MS42Ljg1QzE3LjE4IDYuNTMgMTkgOS4wNiAxOSAxMnMtMS44MiA1LjQ3LTQuNCA2LjVjLS4zNi4xNC0uNi40Ny0uNi44NXYuMmMwIC42My42MyAxLjA3IDEuMjEuODVDMTguNiAxOS4xMSAyMSAxNS44NCAyMSAxMnMtMi40LTcuMTEtNS43OS04LjRjLS41OC0uMjMtMS4yMS4yMi0xLjIxLjg1elwiLCBmaWxsOiBcIiNmZmZcIiB9KSB9KSk7XG59O1xuXG5jb25zdCBCQVJfSEVJR0hUJDEgPSA1O1xuY29uc3QgS05PQl9TSVpFJDEgPSAxMjtcbmNvbnN0IFZPTFVNRV9TTElERVJfV0lEVEggPSAxMDA7XG5jb25zdCBNZWRpYVZvbHVtZVNsaWRlciA9ICh7IGRpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlciB9KSA9PiB7XG4gICAgY29uc3QgW21lZGlhTXV0ZWQsIHNldE1lZGlhTXV0ZWRdID0gSW50ZXJuYWxzLnVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICAgIGNvbnN0IFttZWRpYVZvbHVtZSwgc2V0TWVkaWFWb2x1bWVdID0gSW50ZXJuYWxzLnVzZU1lZGlhVm9sdW1lU3RhdGUoKTtcbiAgICBjb25zdCBbZm9jdXNlZCwgc2V0Rm9jdXNlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgcGFyZW50RGl2UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGlucHV0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGhvdmVyID0gdXNlSG92ZXJTdGF0ZShwYXJlbnREaXZSZWYpO1xuICAgIC8vIE5lZWQgdG8gaW1wb3J0IGl0IGZyb20gUmVhY3QgdG8gZml4IFJlYWN0IDE3IEVTTSBzdXBwb3J0LlxuICAgIGNvbnN0IHJhbmRvbUlkID0gXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgdHlwZW9mIFJlYWN0LnVzZUlkID09PSAndW5kZWZpbmVkJyA/ICd2b2x1bWUtc2xpZGVyJyA6IFJlYWN0LnVzZUlkKCk7XG4gICAgY29uc3QgW3JhbmRvbUNsYXNzXSA9IHVzZVN0YXRlKCgpID0+IGBfX3JlbW90aW9uLXZvbHVtZS1zbGlkZXItJHtyYW5kb20ocmFuZG9tSWQpfWAucmVwbGFjZSgnLicsICcnKSk7XG4gICAgY29uc3QgaXNNdXRlZE9yWmVybyA9IG1lZGlhTXV0ZWQgfHwgbWVkaWFWb2x1bWUgPT09IDA7XG4gICAgY29uc3Qgb25Wb2x1bWVDaGFuZ2UgPSAoZSkgPT4ge1xuICAgICAgICBzZXRNZWRpYVZvbHVtZShwYXJzZUZsb2F0KGUudGFyZ2V0LnZhbHVlKSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkJsdXIgPSAoKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgLy8gV2UgbmVlZCBhIHNtYWxsIGRlbGF5IHRvIGNoZWNrIHdoaWNoIGVsZW1lbnQgd2FzIGZvY3VzZWQgbmV4dCxcbiAgICAgICAgICAgIC8vIGFuZCBpZiBpdCB3YXNuJ3QgdGhlIHZvbHVtZSBzbGlkZXIsIHdlIGhpZGUgaXRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBpbnB1dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDEwKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChtZWRpYVZvbHVtZSA9PT0gMCkge1xuICAgICAgICAgICAgc2V0TWVkaWFWb2x1bWUoMSk7XG4gICAgICAgICAgICBzZXRNZWRpYU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXRNZWRpYU11dGVkKChtdXRlKSA9PiAhbXV0ZSk7XG4gICAgfSwgW21lZGlhVm9sdW1lLCBzZXRNZWRpYU11dGVkLCBzZXRNZWRpYVZvbHVtZV0pO1xuICAgIGNvbnN0IHBhcmVudERpdlN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWZsZXgnLFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJ25vbmUnLFxuICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXG4gICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICAgICAgICAgIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gICAgICAgICAgICAuLi4oZGlzcGxheVZlcnRpY2FsVm9sdW1lU2xpZGVyICYmIHsgcG9zaXRpb246ICdyZWxhdGl2ZScgfSksXG4gICAgICAgIH07XG4gICAgfSwgW2Rpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlcl0pO1xuICAgIGNvbnN0IHZvbHVtZUNvbnRhaW5lciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZScsXG4gICAgICAgICAgICB3aWR0aDogSUNPTl9TSVpFLFxuICAgICAgICAgICAgaGVpZ2h0OiBJQ09OX1NJWkUsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIGFwcGVhcmFuY2U6ICdub25lJyxcbiAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcbiAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxuICAgICAgICAgICAgcGFkZGluZzogMCxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgaW5wdXRTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBjb21tb25TdHlsZSA9IHtcbiAgICAgICAgICAgIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJyxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC41KScsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IEJBUl9IRUlHSFQkMSAvIDIsXG4gICAgICAgICAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICAgICAgICAgIGhlaWdodDogQkFSX0hFSUdIVCQxLFxuICAgICAgICAgICAgd2lkdGg6IFZPTFVNRV9TTElERVJfV0lEVEgsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQoXG5cdFx0XHRcdHRvIHJpZ2h0LFxuXHRcdFx0XHR3aGl0ZSAke21lZGlhVm9sdW1lICogMTAwfSUsIHJnYmEoMjU1LCAyNTUsIDI1NSwgMCkgJHttZWRpYVZvbHVtZSAqIDEwMH0lXG5cdFx0XHQpYCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGRpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5jb21tb25TdHlsZSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IGByb3RhdGUoLTkwZGVnKWAsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICAgICAgYm90dG9tOiBJQ09OX1NJWkUgKyBWT0xVTUVfU0xJREVSX1dJRFRIIC8gMiArIDUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb21tb25TdHlsZSxcbiAgICAgICAgICAgIG1hcmdpbkxlZnQ6IDUsXG4gICAgICAgIH07XG4gICAgfSwgW2Rpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlciwgbWVkaWFWb2x1bWVdKTtcbiAgICBjb25zdCBzbGlkZXJTdHlsZSA9IGBcblx0LiR7cmFuZG9tQ2xhc3N9Ojotd2Via2l0LXNsaWRlci10aHVtYiB7XG5cdFx0LXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuXHRcdGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xuXHRcdGJvcmRlci1yYWRpdXM6ICR7S05PQl9TSVpFJDEgLyAyfXB4O1xuXHRcdGJveC1zaGFkb3c6IDAgMCAycHggYmxhY2s7XG5cdFx0aGVpZ2h0OiAke0tOT0JfU0laRSQxfXB4O1xuXHRcdHdpZHRoOiAke0tOT0JfU0laRSQxfXB4O1xuXHR9XG5cblx0LiR7cmFuZG9tQ2xhc3N9OjotbW96LXJhbmdlLXRodW1iIHtcblx0XHQtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG5cdFx0YmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XG5cdFx0Ym9yZGVyLXJhZGl1czogJHtLTk9CX1NJWkUkMSAvIDJ9cHg7XG5cdFx0Ym94LXNoYWRvdzogMCAwIDJweCBibGFjaztcblx0XHRoZWlnaHQ6ICR7S05PQl9TSVpFJDF9cHg7XG5cdFx0d2lkdGg6ICR7S05PQl9TSVpFJDF9cHg7XG5cdH1cbmA7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgcmVmOiBwYXJlbnREaXZSZWYsIHN0eWxlOiBwYXJlbnREaXZTdHlsZSwgY2hpbGRyZW46IFtqc3goXCJzdHlsZVwiLCB7IFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9uby1kYW5nZXJcbiAgICAgICAgICAgICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTDoge1xuICAgICAgICAgICAgICAgICAgICBfX2h0bWw6IHNsaWRlclN0eWxlLFxuICAgICAgICAgICAgICAgIH0gfSksIGpzeChcImJ1dHRvblwiLCB7IFwiYXJpYS1sYWJlbFwiOiBpc011dGVkT3JaZXJvID8gJ1VubXV0ZSBzb3VuZCcgOiAnTXV0ZSBzb3VuZCcsIHRpdGxlOiBpc011dGVkT3JaZXJvID8gJ1VubXV0ZSBzb3VuZCcgOiAnTXV0ZSBzb3VuZCcsIG9uQ2xpY2s6IG9uQ2xpY2ssIG9uQmx1cjogb25CbHVyLCBvbkZvY3VzOiAoKSA9PiBzZXRGb2N1c2VkKHRydWUpLCBzdHlsZTogdm9sdW1lQ29udGFpbmVyLCB0eXBlOiBcImJ1dHRvblwiLCBjaGlsZHJlbjogaXNNdXRlZE9yWmVybyA/IGpzeChWb2x1bWVPZmZJY29uLCB7fSkgOiBqc3goVm9sdW1lT25JY29uLCB7fSkgfSksIChmb2N1c2VkIHx8IGhvdmVyKSAmJiAhbWVkaWFNdXRlZCAmJiAhSW50ZXJuYWxzLmlzSW9zU2FmYXJpKCkgPyAoanN4KFwiaW5wdXRcIiwgeyByZWY6IGlucHV0UmVmLCBcImFyaWEtbGFiZWxcIjogXCJDaGFuZ2Ugdm9sdW1lXCIsIGNsYXNzTmFtZTogcmFuZG9tQ2xhc3MsIG1heDogMSwgbWluOiAwLCBvbkJsdXI6ICgpID0+IHNldEZvY3VzZWQoZmFsc2UpLCBvbkNoYW5nZTogb25Wb2x1bWVDaGFuZ2UsIHN0ZXA6IDAuMDEsIHR5cGU6IFwicmFuZ2VcIiwgdmFsdWU6IG1lZGlhVm9sdW1lLCBzdHlsZTogaW5wdXRTdHlsZSB9KSkgOiBudWxsXSB9KSk7XG59O1xuXG4vLyBob29rIHRvIGhpZGUgYSBwb3B1cC9tb2RhbCB3aGVuIGNsaWNrZWQgb3V0c2lkZVxuZnVuY3Rpb24gdXNlQ29tcG9uZW50VmlzaWJsZShpbml0aWFsSXNWaXNpYmxlKSB7XG4gICAgY29uc3QgW2lzQ29tcG9uZW50VmlzaWJsZSwgc2V0SXNDb21wb25lbnRWaXNpYmxlXSA9IHVzZVN0YXRlKGluaXRpYWxJc1Zpc2libGUpO1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVDbGlja091dHNpZGUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWYuY3VycmVudCAmJiAhcmVmLmN1cnJlbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHNldElzQ29tcG9uZW50VmlzaWJsZShmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIGhhbmRsZUNsaWNrT3V0c2lkZSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBoYW5kbGVDbGlja091dHNpZGUsIHRydWUpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4geyByZWYsIGlzQ29tcG9uZW50VmlzaWJsZSwgc2V0SXNDb21wb25lbnRWaXNpYmxlIH07XG59XG5cbi8vIFRvIGFsaWduXG5jb25zdCBCT1RUT00gPSAzNTtcbi8vIEFyYml0cmFyeSB0byBjbGFtcCB0aGUgaGVpZ2h0IG9mIHRoZSBwb3B1cFxuY29uc3QgVEhSRVNIT0xEID0gNzA7XG5jb25zdCByYXRlRGl2ID0ge1xuICAgIGhlaWdodDogMzAsXG4gICAgcGFkZGluZ1JpZ2h0OiAxNSxcbiAgICBwYWRkaW5nTGVmdDogMTIsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxufTtcbmNvbnN0IGNoZWNrbWFya0NvbnRhaW5lciA9IHtcbiAgICB3aWR0aDogMjIsXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxufTtcbmNvbnN0IGNoZWNrbWFya1N0eWxlID0ge1xuICAgIHdpZHRoOiAxNCxcbiAgICBoZWlnaHQ6IDE0LFxuICAgIGNvbG9yOiAnYmxhY2snLFxufTtcbmNvbnN0IENoZWNrbWFyayA9ICgpID0+IChqc3goXCJzdmdcIiwgeyB2aWV3Qm94OiBcIjAgMCA1MTIgNTEyXCIsIHN0eWxlOiBjaGVja21hcmtTdHlsZSwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBmaWxsOiBcImN1cnJlbnRDb2xvclwiLCBkOiBcIk00MzUuODQ4IDgzLjQ2NkwxNzIuODA0IDM0Ni41MWwtOTYuNjUyLTk2LjY1MmMtNC42ODYtNC42ODYtMTIuMjg0LTQuNjg2LTE2Ljk3MSAwbC0yOC4yODQgMjguMjg0Yy00LjY4NiA0LjY4Ni00LjY4NiAxMi4yODQgMCAxNi45NzFsMTMzLjQyMSAxMzMuNDIxYzQuNjg2IDQuNjg2IDEyLjI4NCA0LjY4NiAxNi45NzEgMGwyOTkuODEzLTI5OS44MTNjNC42ODYtNC42ODYgNC42ODYtMTIuMjg0IDAtMTYuOTcxbC0yOC4yODQtMjguMjg0Yy00LjY4Ni00LjY4Ni0xMi4yODQtNC42ODYtMTYuOTcgMHpcIiB9KSB9KSk7XG5jb25zdCBQbGF5YmFja3JhdGVPcHRpb24gPSAoeyByYXRlLCBvblNlbGVjdCwgc2VsZWN0ZWRSYXRlLCBrZXlib2FyZFNlbGVjdGVkUmF0ZSB9KSA9PiB7XG4gICAgY29uc3Qgb25DbGljayA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgb25TZWxlY3QocmF0ZSk7XG4gICAgfSwgW29uU2VsZWN0LCByYXRlXSk7XG4gICAgY29uc3QgW2hvdmVyZWQsIHNldEhvdmVyZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IG9uTW91c2VFbnRlciA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0SG92ZXJlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25Nb3VzZUxlYXZlID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRIb3ZlcmVkKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgYWN0dWFsU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLnJhdGVEaXYsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvdmVyZWQgfHwga2V5Ym9hcmRTZWxlY3RlZFJhdGUgPT09IHJhdGUgPyAnI2VlZScgOiAndHJhbnNwYXJlbnQnLFxuICAgICAgICB9O1xuICAgIH0sIFtob3ZlcmVkLCBrZXlib2FyZFNlbGVjdGVkUmF0ZSwgcmF0ZV0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IG9uTW91c2VFbnRlcjogb25Nb3VzZUVudGVyLCBvbk1vdXNlTGVhdmU6IG9uTW91c2VMZWF2ZSwgdGFiSW5kZXg6IDAsIHN0eWxlOiBhY3R1YWxTdHlsZSwgb25DbGljazogb25DbGljaywgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBzdHlsZTogY2hlY2ttYXJrQ29udGFpbmVyLCBjaGlsZHJlbjogcmF0ZSA9PT0gc2VsZWN0ZWRSYXRlID8ganN4KENoZWNrbWFyaywge30pIDogbnVsbCB9KSwgcmF0ZS50b0ZpeGVkKDEpLCBcInhcIl0gfSwgcmF0ZSkpO1xufTtcbmNvbnN0IFBsYXliYWNrUG9wdXAgPSAoeyBzZXRJc0NvbXBvbmVudFZpc2libGUsIHBsYXliYWNrUmF0ZXMsIGNhbnZhc1NpemUgfSkgPT4ge1xuICAgIGNvbnN0IHsgc2V0UGxheWJhY2tSYXRlLCBwbGF5YmFja1JhdGUgfSA9IHVzZUNvbnRleHQoSW50ZXJuYWxzLlRpbWVsaW5lLlRpbWVsaW5lQ29udGV4dCk7XG4gICAgY29uc3QgW2tleWJvYXJkU2VsZWN0ZWRSYXRlLCBzZXRLZXlib2FyZFNlbGVjdGVkUmF0ZV0gPSB1c2VTdGF0ZShwbGF5YmFja1JhdGUpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGlmIChlLmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gcGxheWJhY2tSYXRlcy5maW5kSW5kZXgoKHJhdGUpID0+IHJhdGUgPT09IGtleWJvYXJkU2VsZWN0ZWRSYXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0S2V5Ym9hcmRTZWxlY3RlZFJhdGUocGxheWJhY2tSYXRlc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlib2FyZFNlbGVjdGVkUmF0ZShwbGF5YmFja1JhdGVzW2N1cnJlbnRJbmRleCAtIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBwbGF5YmFja1JhdGVzLmZpbmRJbmRleCgocmF0ZSkgPT4gcmF0ZSA9PT0ga2V5Ym9hcmRTZWxlY3RlZFJhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IHBsYXliYWNrUmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEtleWJvYXJkU2VsZWN0ZWRSYXRlKHBsYXliYWNrUmF0ZXNbcGxheWJhY2tSYXRlcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlib2FyZFNlbGVjdGVkUmF0ZShwbGF5YmFja1JhdGVzW2N1cnJlbnRJbmRleCArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgIHNldFBsYXliYWNrUmF0ZShrZXlib2FyZFNlbGVjdGVkUmF0ZSk7XG4gICAgICAgICAgICAgICAgc2V0SXNDb21wb25lbnRWaXNpYmxlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGxpc3RlbmVyKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBsYXliYWNrUmF0ZXMsXG4gICAgICAgIGtleWJvYXJkU2VsZWN0ZWRSYXRlLFxuICAgICAgICBzZXRQbGF5YmFja1JhdGUsXG4gICAgICAgIHNldElzQ29tcG9uZW50VmlzaWJsZSxcbiAgICBdKTtcbiAgICBjb25zdCBvblNlbGVjdCA9IHVzZUNhbGxiYWNrKChyYXRlKSA9PiB7XG4gICAgICAgIHNldFBsYXliYWNrUmF0ZShyYXRlKTtcbiAgICAgICAgc2V0SXNDb21wb25lbnRWaXNpYmxlKGZhbHNlKTtcbiAgICB9LCBbc2V0SXNDb21wb25lbnRWaXNpYmxlLCBzZXRQbGF5YmFja1JhdGVdKTtcbiAgICBjb25zdCBwbGF5YmFja1BvcHVwID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHJpZ2h0OiAwLFxuICAgICAgICAgICAgd2lkdGg6IDEyNSxcbiAgICAgICAgICAgIG1heEhlaWdodDogY2FudmFzU2l6ZS5oZWlnaHQgLSBUSFJFU0hPTEQgLSBCT1RUT00sXG4gICAgICAgICAgICBib3R0b206IDM1LFxuICAgICAgICAgICAgYmFja2dyb3VuZDogJyNmZmYnLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiA0LFxuICAgICAgICAgICAgb3ZlcmZsb3c6ICdhdXRvJyxcbiAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXG4gICAgICAgIH07XG4gICAgfSwgW2NhbnZhc1NpemUuaGVpZ2h0XSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBzdHlsZTogcGxheWJhY2tQb3B1cCwgY2hpbGRyZW46IHBsYXliYWNrUmF0ZXMubWFwKChyYXRlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGpzeChQbGF5YmFja3JhdGVPcHRpb24sIHsgc2VsZWN0ZWRSYXRlOiBwbGF5YmFja1JhdGUsIG9uU2VsZWN0OiBvblNlbGVjdCwgcmF0ZTogcmF0ZSwga2V5Ym9hcmRTZWxlY3RlZFJhdGU6IGtleWJvYXJkU2VsZWN0ZWRSYXRlIH0sIHJhdGUpKTtcbiAgICAgICAgfSkgfSkpO1xufTtcbmNvbnN0IGxhYmVsID0ge1xuICAgIGZvbnRTaXplOiAxMyxcbiAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgY29sb3I6ICd3aGl0ZScsXG4gICAgYm9yZGVyOiAnMnB4IHNvbGlkIHdoaXRlJyxcbiAgICBib3JkZXJSYWRpdXM6IDIwLFxuICAgIHBhZGRpbmdMZWZ0OiA4LFxuICAgIHBhZGRpbmdSaWdodDogOCxcbiAgICBwYWRkaW5nVG9wOiAyLFxuICAgIHBhZGRpbmdCb3R0b206IDIsXG59O1xuY29uc3QgcGxheWVyQnV0dG9uU3R5bGUgPSB7XG4gICAgYXBwZWFyYW5jZTogJ25vbmUnLFxuICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50JyxcbiAgICBib3JkZXI6ICdub25lJyxcbiAgICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgICBwYWRkaW5nTGVmdDogMCxcbiAgICBwYWRkaW5nUmlnaHQ6IDAsXG4gICAgcGFkZGluZ1RvcDogNixcbiAgICBwYWRkaW5nQm90dG9tOiA2LFxuICAgIGhlaWdodDogMzcsXG4gICAgZGlzcGxheTogJ2lubGluZS1mbGV4JyxcbiAgICBtYXJnaW5Cb3R0b206IDAsXG4gICAgbWFyZ2luVG9wOiAwLFxuICAgIGFsaWduSXRlbXM6ICdjZW50ZXInLFxufTtcbmNvbnN0IGJ1dHRvbiA9IHtcbiAgICAuLi5wbGF5ZXJCdXR0b25TdHlsZSxcbiAgICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbn07XG5jb25zdCBQbGF5YmFja3JhdGVDb250cm9sID0gKHsgcGxheWJhY2tSYXRlcywgY2FudmFzU2l6ZSB9KSA9PiB7XG4gICAgY29uc3QgeyByZWYsIGlzQ29tcG9uZW50VmlzaWJsZSwgc2V0SXNDb21wb25lbnRWaXNpYmxlIH0gPSB1c2VDb21wb25lbnRWaXNpYmxlKGZhbHNlKTtcbiAgICBjb25zdCB7IHBsYXliYWNrUmF0ZSB9ID0gdXNlQ29udGV4dChJbnRlcm5hbHMuVGltZWxpbmUuVGltZWxpbmVDb250ZXh0KTtcbiAgICBjb25zdCBvbkNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBzZXRJc0NvbXBvbmVudFZpc2libGUoIWlzQ29tcG9uZW50VmlzaWJsZSk7XG4gICAgfSwgW2lzQ29tcG9uZW50VmlzaWJsZSwgc2V0SXNDb21wb25lbnRWaXNpYmxlXSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyByZWY6IHJlZiwgY2hpbGRyZW46IGpzeHMoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBcImFyaWEtbGFiZWxcIjogXCJDaGFuZ2UgcGxheWJhY2sgcmF0ZVwiLCBzdHlsZTogYnV0dG9uLCBvbkNsaWNrOiBvbkNsaWNrLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBzdHlsZTogbGFiZWwsIGNoaWxkcmVuOiBbcGxheWJhY2tSYXRlLCBcInhcIl0gfSksIGlzQ29tcG9uZW50VmlzaWJsZSAmJiAoanN4KFBsYXliYWNrUG9wdXAsIHsgY2FudmFzU2l6ZTogY2FudmFzU2l6ZSwgcGxheWJhY2tSYXRlczogcGxheWJhY2tSYXRlcywgc2V0SXNDb21wb25lbnRWaXNpYmxlOiBzZXRJc0NvbXBvbmVudFZpc2libGUgfSkpXSB9KSB9KSk7XG59O1xuXG5jb25zdCBnZXRGcmFtZUZyb21YID0gKGNsaWVudFgsIGR1cmF0aW9uSW5GcmFtZXMsIHdpZHRoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBvcyA9IGNsaWVudFg7XG4gICAgY29uc3QgZnJhbWUgPSBNYXRoLnJvdW5kKGludGVycG9sYXRlKHBvcywgWzAsIHdpZHRoXSwgWzAsIChfYSA9IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwXSwge1xuICAgICAgICBleHRyYXBvbGF0ZUxlZnQ6ICdjbGFtcCcsXG4gICAgICAgIGV4dHJhcG9sYXRlUmlnaHQ6ICdjbGFtcCcsXG4gICAgfSkpO1xuICAgIHJldHVybiBmcmFtZTtcbn07XG5jb25zdCBCQVJfSEVJR0hUID0gNTtcbmNvbnN0IEtOT0JfU0laRSA9IDEyO1xuY29uc3QgVkVSVElDQUxfUEFERElORyA9IDQ7XG5jb25zdCBjb250YWluZXJTdHlsZSQxID0ge1xuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICBwYWRkaW5nVG9wOiBWRVJUSUNBTF9QQURESU5HLFxuICAgIHBhZGRpbmdCb3R0b206IFZFUlRJQ0FMX1BBRERJTkcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gICAgY3Vyc29yOiAncG9pbnRlcicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgdG91Y2hBY3Rpb246ICdub25lJyxcbn07XG5jb25zdCBiYXJCYWNrZ3JvdW5kID0ge1xuICAgIGhlaWdodDogQkFSX0hFSUdIVCxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpJyxcbiAgICB3aWR0aDogJzEwMCUnLFxuICAgIGJvcmRlclJhZGl1czogQkFSX0hFSUdIVCAvIDIsXG59O1xuY29uc3QgZmluZEJvZHlJbldoaWNoRGl2SXNMb2NhdGVkID0gKGRpdikgPT4ge1xuICAgIGxldCBjdXJyZW50ID0gZGl2O1xuICAgIHdoaWxlIChjdXJyZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59O1xuY29uc3QgUGxheWVyU2Vla0JhciA9ICh7IGR1cmF0aW9uSW5GcmFtZXMsIG9uU2Vla0VuZCwgb25TZWVrU3RhcnQsIGluRnJhbWUsIG91dEZyYW1lIH0pID0+IHtcbiAgICBjb25zdCBjb250YWluZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYmFySG92ZXJlZCA9IHVzZUhvdmVyU3RhdGUoY29udGFpbmVyUmVmKTtcbiAgICBjb25zdCBzaXplID0gdXNlRWxlbWVudFNpemUoY29udGFpbmVyUmVmLCB7XG4gICAgICAgIHRyaWdnZXJPbldpbmRvd1Jlc2l6ZTogdHJ1ZSxcbiAgICAgICAgc2hvdWxkQXBwbHlDc3NUcmFuc2Zvcm1zOiB0cnVlLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgc2VlaywgcGxheSwgcGF1c2UsIHBsYXlpbmcgfSA9IHVzZVBsYXllcigpO1xuICAgIGNvbnN0IGZyYW1lID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IHVzZVN0YXRlKHtcbiAgICAgICAgZHJhZ2dpbmc6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IG9uUG9pbnRlckRvd24gPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxheWVyIGhhcyBubyBzaXplJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2ZyYW1lID0gZ2V0RnJhbWVGcm9tWChlLmNsaWVudFggLSBzaXplLmxlZnQsIGR1cmF0aW9uSW5GcmFtZXMsIHNpemUud2lkdGgpO1xuICAgICAgICBwYXVzZSgpO1xuICAgICAgICBzZWVrKF9mcmFtZSk7XG4gICAgICAgIHNldERyYWdnaW5nKHtcbiAgICAgICAgICAgIGRyYWdnaW5nOiB0cnVlLFxuICAgICAgICAgICAgd2FzUGxheWluZzogcGxheWluZyxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2Vla1N0YXJ0KCk7XG4gICAgfSwgW3NpemUsIGR1cmF0aW9uSW5GcmFtZXMsIHBhdXNlLCBzZWVrLCBwbGF5aW5nLCBvblNlZWtTdGFydF0pO1xuICAgIGNvbnN0IG9uUG9pbnRlck1vdmUgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGF5ZXIgaGFzIG5vIHNpemUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWRyYWdnaW5nLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX2ZyYW1lID0gZ2V0RnJhbWVGcm9tWChlLmNsaWVudFggLSAoKF9hID0gc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLmxlZnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApLCBkdXJhdGlvbkluRnJhbWVzLCBzaXplLndpZHRoKTtcbiAgICAgICAgc2VlayhfZnJhbWUpO1xuICAgIH0sIFtkcmFnZ2luZy5kcmFnZ2luZywgZHVyYXRpb25JbkZyYW1lcywgc2Vlaywgc2l6ZV0pO1xuICAgIGNvbnN0IG9uUG9pbnRlclVwID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXREcmFnZ2luZyh7XG4gICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWRyYWdnaW5nLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRyYWdnaW5nLndhc1BsYXlpbmcpIHtcbiAgICAgICAgICAgIHBsYXkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgb25TZWVrRW5kKCk7XG4gICAgfSwgW2RyYWdnaW5nLCBvblNlZWtFbmQsIHBhdXNlLCBwbGF5XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFkcmFnZ2luZy5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBmaW5kQm9keUluV2hpY2hEaXZJc0xvY2F0ZWQoY29udGFpbmVyUmVmLmN1cnJlbnQpO1xuICAgICAgICBib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJtb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgICAgIGJvZHkuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgb25Qb2ludGVyVXApO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVybW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICAgICAgYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBvblBvaW50ZXJVcCk7XG4gICAgICAgIH07XG4gICAgfSwgW2RyYWdnaW5nLmRyYWdnaW5nLCBvblBvaW50ZXJNb3ZlLCBvblBvaW50ZXJVcF0pO1xuICAgIGNvbnN0IGtub2JTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWlnaHQ6IEtOT0JfU0laRSxcbiAgICAgICAgICAgIHdpZHRoOiBLTk9CX1NJWkUsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IEtOT0JfU0laRSAvIDIsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogVkVSVElDQUxfUEFERElORyAtIEtOT0JfU0laRSAvIDIgKyA1IC8gMixcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgIGxlZnQ6IE1hdGgubWF4KDAsIChmcmFtZSAvIE1hdGgubWF4KDEsIGR1cmF0aW9uSW5GcmFtZXMgLSAxKSkgKiAoKF9hID0gc2l6ZSA9PT0gbnVsbCB8fCBzaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaXplLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAtXG4gICAgICAgICAgICAgICAgS05PQl9TSVpFIC8gMiksXG4gICAgICAgICAgICBib3hTaGFkb3c6ICcwIDAgMnB4IGJsYWNrJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IE51bWJlcihiYXJIb3ZlcmVkKSxcbiAgICAgICAgfTtcbiAgICB9LCBbYmFySG92ZXJlZCwgZHVyYXRpb25JbkZyYW1lcywgZnJhbWUsIHNpemVdKTtcbiAgICBjb25zdCBmaWxsU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlaWdodDogQkFSX0hFSUdIVCxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMSknLFxuICAgICAgICAgICAgd2lkdGg6ICgoZnJhbWUgLSAoaW5GcmFtZSAhPT0gbnVsbCAmJiBpbkZyYW1lICE9PSB2b2lkIDAgPyBpbkZyYW1lIDogMCkpIC8gKGR1cmF0aW9uSW5GcmFtZXMgLSAxKSkgKiAxMDAgKyAnJScsXG4gICAgICAgICAgICBtYXJnaW5MZWZ0OiAoKGluRnJhbWUgIT09IG51bGwgJiYgaW5GcmFtZSAhPT0gdm9pZCAwID8gaW5GcmFtZSA6IDApIC8gKGR1cmF0aW9uSW5GcmFtZXMgLSAxKSkgKiAxMDAgKyAnJScsXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IEJBUl9IRUlHSFQgLyAyLFxuICAgICAgICB9O1xuICAgIH0sIFtkdXJhdGlvbkluRnJhbWVzLCBmcmFtZSwgaW5GcmFtZV0pO1xuICAgIGNvbnN0IGFjdGl2ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBCQVJfSEVJR0hULFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KScsXG4gICAgICAgICAgICB3aWR0aDogKCgob3V0RnJhbWUgIT09IG51bGwgJiYgb3V0RnJhbWUgIT09IHZvaWQgMCA/IG91dEZyYW1lIDogZHVyYXRpb25JbkZyYW1lcyAtIDEpIC0gKGluRnJhbWUgIT09IG51bGwgJiYgaW5GcmFtZSAhPT0gdm9pZCAwID8gaW5GcmFtZSA6IDApKSAvXG4gICAgICAgICAgICAgICAgKGR1cmF0aW9uSW5GcmFtZXMgLSAxKSkgKlxuICAgICAgICAgICAgICAgIDEwMCArXG4gICAgICAgICAgICAgICAgJyUnLFxuICAgICAgICAgICAgbWFyZ2luTGVmdDogKChpbkZyYW1lICE9PSBudWxsICYmIGluRnJhbWUgIT09IHZvaWQgMCA/IGluRnJhbWUgOiAwKSAvIChkdXJhdGlvbkluRnJhbWVzIC0gMSkpICogMTAwICsgJyUnLFxuICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiBCQVJfSEVJR0hUIC8gMixcbiAgICAgICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICB9O1xuICAgIH0sIFtkdXJhdGlvbkluRnJhbWVzLCBpbkZyYW1lLCBvdXRGcmFtZV0pO1xuICAgIHJldHVybiAoanN4cyhcImRpdlwiLCB7IHJlZjogY29udGFpbmVyUmVmLCBvblBvaW50ZXJEb3duOiBvblBvaW50ZXJEb3duLCBzdHlsZTogY29udGFpbmVyU3R5bGUkMSwgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgc3R5bGU6IGJhckJhY2tncm91bmQsIGNoaWxkcmVuOiBbanN4KFwiZGl2XCIsIHsgc3R5bGU6IGFjdGl2ZSB9KSwganN4KFwiZGl2XCIsIHsgc3R5bGU6IGZpbGxTdHlsZSB9KV0gfSksIGpzeChcImRpdlwiLCB7IHN0eWxlOiBrbm9iU3R5bGUgfSldIH0pKTtcbn07XG5cbmNvbnN0IFhfU1BBQ0VSID0gMTA7XG5jb25zdCBYX1BBRERJTkcgPSAxMjtcbmNvbnN0IHVzZVZpZGVvQ29udHJvbHNSZXNpemUgPSAoeyBhbGxvd0Z1bGxzY3JlZW46IGFsbG93RnVsbFNjcmVlbiwgcGxheWVyV2lkdGgsIH0pID0+IHtcbiAgICBjb25zdCByZXNpemVJbmZvID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBsYXlQYXVzZUljb25TaXplID0gSUNPTl9TSVpFO1xuICAgICAgICBjb25zdCB2b2x1bWVJY29uU2l6ZSA9IElDT05fU0laRTtcbiAgICAgICAgY29uc3QgX2Z1bGxzY3JlZW5JY29uU2l6ZSA9IGFsbG93RnVsbFNjcmVlbiA/IGZ1bGxzY3JlZW5JY29uU2l6ZSA6IDA7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzU2l6ZSA9IHZvbHVtZUljb25TaXplICtcbiAgICAgICAgICAgIHBsYXlQYXVzZUljb25TaXplICtcbiAgICAgICAgICAgIF9mdWxsc2NyZWVuSWNvblNpemUgK1xuICAgICAgICAgICAgWF9QQURESU5HICogMiArXG4gICAgICAgICAgICBYX1NQQUNFUiAqIDI7XG4gICAgICAgIGNvbnN0IG1heFRpbWVMYWJlbFdpZHRoID0gcGxheWVyV2lkdGggLSBlbGVtZW50c1NpemU7XG4gICAgICAgIGNvbnN0IG1heFRpbWVMYWJlbFdpZHRoV2l0aG91dE5lZ2F0aXZlVmFsdWUgPSBNYXRoLm1heChtYXhUaW1lTGFiZWxXaWR0aCwgMCk7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVRpbWVMYWJlbFdpZHRoSWZWb2x1bWVPcGVuID0gbWF4VGltZUxhYmVsV2lkdGhXaXRob3V0TmVnYXRpdmVWYWx1ZSAtIFZPTFVNRV9TTElERVJfV0lEVEg7XG4gICAgICAgIC8vIElmIG1heCBsYWJlbCB3aWR0aCBpcyBsb3dlciB0aGFuIHRoZSB2b2x1bWUgd2lkdGhcbiAgICAgICAgLy8gdGhlbiBpdCBtZWFucyB3ZSBuZWVkIHRvIHRha2UgaXQncyB3aWR0aCBhcyB0aGUgbWF4IGxhYmVsIHdpZHRoXG4gICAgICAgIC8vIG90aGVyd2lzZSB3ZSB0b29rIHRoZSBhdmFpbGFibGUgd2lkdGggd2hlbiB2b2x1bWUgb3BlblxuICAgICAgICBjb25zdCBjb21wdXRlZExhYmVsV2lkdGggPSBhdmFpbGFibGVUaW1lTGFiZWxXaWR0aElmVm9sdW1lT3BlbiA8IFZPTFVNRV9TTElERVJfV0lEVEhcbiAgICAgICAgICAgID8gbWF4VGltZUxhYmVsV2lkdGhXaXRob3V0TmVnYXRpdmVWYWx1ZVxuICAgICAgICAgICAgOiBhdmFpbGFibGVUaW1lTGFiZWxXaWR0aElmVm9sdW1lT3BlbjtcbiAgICAgICAgY29uc3QgbWluV2lkdGhGb3JIb3Jpem9udGFsRGlzcGxheSA9IGNvbXB1dGVkTGFiZWxXaWR0aCArIGVsZW1lbnRzU2l6ZSArIFZPTFVNRV9TTElERVJfV0lEVEg7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlciA9IHBsYXllcldpZHRoIDwgbWluV2lkdGhGb3JIb3Jpem9udGFsRGlzcGxheTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1heFRpbWVMYWJlbFdpZHRoOiBtYXhUaW1lTGFiZWxXaWR0aFdpdGhvdXROZWdhdGl2ZVZhbHVlID09PSAwXG4gICAgICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICAgICAgOiBtYXhUaW1lTGFiZWxXaWR0aFdpdGhvdXROZWdhdGl2ZVZhbHVlLFxuICAgICAgICAgICAgZGlzcGxheVZlcnRpY2FsVm9sdW1lU2xpZGVyLFxuICAgICAgICB9O1xuICAgIH0sIFthbGxvd0Z1bGxTY3JlZW4sIHBsYXllcldpZHRoXSk7XG4gICAgcmV0dXJuIHJlc2l6ZUluZm87XG59O1xuXG5jb25zdCBncmFkaWVudFN0ZXBzID0gW1xuICAgIDAsIDAuMDEzLCAwLjA0OSwgMC4xMDQsIDAuMTc1LCAwLjI1OSwgMC4zNTIsIDAuNDUsIDAuNTUsIDAuNjQ4LCAwLjc0MSwgMC44MjUsXG4gICAgMC44OTYsIDAuOTUxLCAwLjk4Nyxcbl07XG5jb25zdCBncmFkaWVudE9wYWNpdGllcyA9IFtcbiAgICAwLCA4LjEsIDE1LjUsIDIyLjUsIDI5LCAzNS4zLCA0MS4yLCA0Ny4xLCA1Mi45LCA1OC44LCA2NC43LCA3MSwgNzcuNSwgODQuNSxcbiAgICA5MS45LFxuXTtcbmNvbnN0IGdsb2JhbEdyYWRpZW50T3BhY2l0eSA9IDEgLyAwLjc7XG5jb25zdCBjb250YWluZXJTdHlsZSA9IHtcbiAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBib3R0b206IDAsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBwYWRkaW5nVG9wOiA0MCxcbiAgICBwYWRkaW5nQm90dG9tOiAxMCxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IGBsaW5lYXItZ3JhZGllbnQodG8gYm90dG9tLCR7Z3JhZGllbnRTdGVwc1xuICAgICAgICAubWFwKChnLCBpKSA9PiB7XG4gICAgICAgIHJldHVybiBgaHNsYSgwLCAwJSwgMCUsICR7Z30pICR7Z3JhZGllbnRPcGFjaXRpZXNbaV0gKiBnbG9iYWxHcmFkaWVudE9wYWNpdHl9JWA7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oJywgJyl9LCBoc2woMCwgMCUsIDAlKSAxMDAlKWAsXG4gICAgYmFja2dyb3VuZFNpemU6ICdhdXRvIDE0NXB4JyxcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgcGFkZGluZ1JpZ2h0OiBYX1BBRERJTkcsXG4gICAgcGFkZGluZ0xlZnQ6IFhfUEFERElORyxcbiAgICBmbGV4RGlyZWN0aW9uOiAnY29sdW1uJyxcbiAgICB0cmFuc2l0aW9uOiAnb3BhY2l0eSAwLjNzJyxcbn07XG5jb25zdCBjb250cm9sc1JvdyA9IHtcbiAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgZmxleERpcmVjdGlvbjogJ3JvdycsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxufTtcbmNvbnN0IGxlZnRQYXJ0U3R5bGUgPSB7XG4gICAgZGlzcGxheTogJ2ZsZXgnLFxuICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxuICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbn07XG5jb25zdCB4U3BhY2VyID0ge1xuICAgIHdpZHRoOiAxMixcbn07XG5jb25zdCB5U3BhY2VyID0ge1xuICAgIGhlaWdodDogOCxcbn07XG5jb25zdCBmbGV4MSA9IHtcbiAgICBmbGV4OiAxLFxufTtcbmNvbnN0IGZ1bGxzY3JlZW4gPSB7fTtcbmNvbnN0IFBsYXlQYXVzZUJ1dHRvbiA9ICh7IHBsYXlpbmcgfSkgPT4gcGxheWluZyA/IGpzeChQYXVzZUljb24sIHt9KSA6IGpzeChQbGF5SWNvbiwge30pO1xuY29uc3QgQ29udHJvbHMgPSAoeyBkdXJhdGlvbkluRnJhbWVzLCBpc0Z1bGxzY3JlZW4sIGZwcywgcGxheWVyLCBzaG93Vm9sdW1lQ29udHJvbHMsIG9uRnVsbHNjcmVlbkJ1dHRvbkNsaWNrLCBhbGxvd0Z1bGxzY3JlZW4sIG9uRXhpdEZ1bGxzY3JlZW5CdXR0b25DbGljaywgc3BhY2VLZXlUb1BsYXlPclBhdXNlLCBvblNlZWtFbmQsIG9uU2Vla1N0YXJ0LCBpbkZyYW1lLCBvdXRGcmFtZSwgaW5pdGlhbGx5U2hvd0NvbnRyb2xzLCBjYW52YXNTaXplLCByZW5kZXJQbGF5UGF1c2VCdXR0b24sIHJlbmRlckZ1bGxzY3JlZW5CdXR0b24sIGFsd2F5c1Nob3dDb250cm9scywgc2hvd1BsYXliYWNrUmF0ZUNvbnRyb2wsIGNvbnRhaW5lclJlZiwgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwbGF5QnV0dG9uUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGZyYW1lID0gSW50ZXJuYWxzLlRpbWVsaW5lLnVzZVRpbWVsaW5lUG9zaXRpb24oKTtcbiAgICBjb25zdCBbc3VwcG9ydHNGdWxsc2NyZWVuLCBzZXRTdXBwb3J0c0Z1bGxzY3JlZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IGhvdmVyZWQgPSB1c2VIb3ZlclN0YXRlKGNvbnRhaW5lclJlZik7XG4gICAgY29uc3QgeyBtYXhUaW1lTGFiZWxXaWR0aCwgZGlzcGxheVZlcnRpY2FsVm9sdW1lU2xpZGVyIH0gPSB1c2VWaWRlb0NvbnRyb2xzUmVzaXplKHtcbiAgICAgICAgYWxsb3dGdWxsc2NyZWVuLFxuICAgICAgICBwbGF5ZXJXaWR0aDogKF9hID0gY2FudmFzU2l6ZSA9PT0gbnVsbCB8fCBjYW52YXNTaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNTaXplLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgIH0pO1xuICAgIGNvbnN0IFtzaG91bGRTaG93SW5pdGlhbGx5LCBzZXRJbml0aWFsbHlTaG93Q29udHJvbHNdID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGluaXRpYWxseVNob3dDb250cm9scyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5pdGlhbGx5U2hvd0NvbnRyb2xzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbGx5U2hvd0NvbnRyb2xzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgaWYgKGluaXRpYWxseVNob3dDb250cm9scyAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXRpYWxseVNob3dDb250cm9scyBtdXN0IGJlIGFuIGludGVnZXIgb3IgYSBib29sZWFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGluaXRpYWxseVNob3dDb250cm9scykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXRpYWxseVNob3dDb250cm9scyBtdXN0IG5vdCBiZSBOYU4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluaXRpYWxseVNob3dDb250cm9scykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luaXRpYWxseVNob3dDb250cm9scyBtdXN0IGJlIGZpbml0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluaXRpYWxseVNob3dDb250cm9scyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbml0aWFsbHlTaG93Q29udHJvbHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbml0aWFsbHlTaG93Q29udHJvbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5pdGlhbGx5U2hvd0NvbnRyb2xzIG11c3QgYmUgYSBudW1iZXIgb3IgYSBib29sZWFuJyk7XG4gICAgfSk7XG4gICAgY29uc3QgY29udGFpbmVyQ3NzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIC8vIEhpZGUgaWYgcGxheWluZyBhbmQgbW91c2Ugb3V0c2lkZVxuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gaG92ZXJlZCB8fCAhcGxheWVyLnBsYXlpbmcgfHwgc2hvdWxkU2hvd0luaXRpYWxseSB8fCBhbHdheXNTaG93Q29udHJvbHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgIG9wYWNpdHk6IE51bWJlcihzaG91bGRTaG93KSxcbiAgICAgICAgfTtcbiAgICB9LCBbaG92ZXJlZCwgc2hvdWxkU2hvd0luaXRpYWxseSwgcGxheWVyLnBsYXlpbmcsIGFsd2F5c1Nob3dDb250cm9sc10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwbGF5QnV0dG9uUmVmLmN1cnJlbnQgJiYgc3BhY2VLZXlUb1BsYXlPclBhdXNlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHN3aXRjaGVzIGZvY3VzIHRvIHBsYXkgYnV0dG9uIHdoZW4gcGxheWVyLnBsYXlpbmcgZmxhZyBjaGFuZ2VzXG4gICAgICAgICAgICBwbGF5QnV0dG9uUmVmLmN1cnJlbnQuZm9jdXMoe1xuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtwbGF5ZXIucGxheWluZywgc3BhY2VLZXlUb1BsYXlPclBhdXNlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBNdXN0IGJlIGhhbmRsZWQgY2xpZW50LXNpZGUgdG8gYXZvaWQgU1NSIGh5ZHJhdGlvbiBtaXNtYXRjaFxuICAgICAgICBzZXRTdXBwb3J0c0Z1bGxzY3JlZW4oKF9hID0gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIChkb2N1bWVudC5mdWxsc2NyZWVuRW5hYmxlZCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRW5hYmxlZCkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmYWxzZSk7XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRTaG93SW5pdGlhbGx5ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWUgPSBzaG91bGRTaG93SW5pdGlhbGx5ID09PSB0cnVlID8gMjAwMCA6IHNob3VsZFNob3dJbml0aWFsbHk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHNldEluaXRpYWxseVNob3dDb250cm9scyhmYWxzZSk7XG4gICAgICAgIH0sIHRpbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2hvdWxkU2hvd0luaXRpYWxseV0pO1xuICAgIGNvbnN0IHRpbWVMYWJlbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29sb3I6ICd3aGl0ZScsXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICAgICAgICBmb250U2l6ZTogMTQsXG4gICAgICAgICAgICBtYXhXaWR0aDogbWF4VGltZUxhYmVsV2lkdGggPT09IG51bGwgPyB1bmRlZmluZWQgOiBtYXhUaW1lTGFiZWxXaWR0aCxcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICAgICAgICAgIHRleHRPdmVyZmxvdzogJ2VsbGlwc2lzJyxcbiAgICAgICAgfTtcbiAgICB9LCBbbWF4VGltZUxhYmVsV2lkdGhdKTtcbiAgICBjb25zdCBwbGF5YmFja1JhdGVzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmIChzaG93UGxheWJhY2tSYXRlQ29udHJvbCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIFswLjUsIDAuOCwgMSwgMS4yLCAxLjUsIDEuOCwgMiwgMi41LCAzXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzaG93UGxheWJhY2tSYXRlQ29udHJvbCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmF0ZSBvZiBzaG93UGxheWJhY2tSYXRlQ29udHJvbCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmF0ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVyeSBpdGVtIGluIHNob3dQbGF5YmFja1JhdGVDb250cm9sIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJhdGUgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZXJ5IGl0ZW0gaW4gc2hvd1BsYXliYWNrUmF0ZUNvbnRyb2wgbXVzdCBiZSBwb3NpdGl2ZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzaG93UGxheWJhY2tSYXRlQ29udHJvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LCBbc2hvd1BsYXliYWNrUmF0ZUNvbnRyb2xdKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBzdHlsZTogY29udGFpbmVyQ3NzLCBjaGlsZHJlbjogW2pzeHMoXCJkaXZcIiwgeyBzdHlsZTogY29udHJvbHNSb3csIGNoaWxkcmVuOiBbanN4cyhcImRpdlwiLCB7IHN0eWxlOiBsZWZ0UGFydFN0eWxlLCBjaGlsZHJlbjogW2pzeChcImJ1dHRvblwiLCB7IHJlZjogcGxheUJ1dHRvblJlZiwgdHlwZTogXCJidXR0b25cIiwgc3R5bGU6IHBsYXllckJ1dHRvblN0eWxlLCBvbkNsaWNrOiBwbGF5ZXIucGxheWluZyA/IHBsYXllci5wYXVzZSA6IHBsYXllci5wbGF5LCBcImFyaWEtbGFiZWxcIjogcGxheWVyLnBsYXlpbmcgPyAnUGF1c2UgdmlkZW8nIDogJ1BsYXkgdmlkZW8nLCB0aXRsZTogcGxheWVyLnBsYXlpbmcgPyAnUGF1c2UgdmlkZW8nIDogJ1BsYXkgdmlkZW8nLCBjaGlsZHJlbjogcmVuZGVyUGxheVBhdXNlQnV0dG9uID09PSBudWxsID8gKGpzeChQbGF5UGF1c2VCdXR0b24sIHsgcGxheWluZzogcGxheWVyLnBsYXlpbmcgfSkpIDogKHJlbmRlclBsYXlQYXVzZUJ1dHRvbih7IHBsYXlpbmc6IHBsYXllci5wbGF5aW5nIH0pKSB9KSwgc2hvd1ZvbHVtZUNvbnRyb2xzID8gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBzdHlsZTogeFNwYWNlciB9KSwganN4KE1lZGlhVm9sdW1lU2xpZGVyLCB7IGRpc3BsYXlWZXJ0aWNhbFZvbHVtZVNsaWRlcjogZGlzcGxheVZlcnRpY2FsVm9sdW1lU2xpZGVyIH0pXSB9KSkgOiBudWxsLCBqc3goXCJkaXZcIiwgeyBzdHlsZTogeFNwYWNlciB9KSwganN4cyhcImRpdlwiLCB7IHN0eWxlOiB0aW1lTGFiZWwsIGNoaWxkcmVuOiBbZm9ybWF0VGltZShmcmFtZSAvIGZwcyksIFwiIC8gXCIsIGZvcm1hdFRpbWUoZHVyYXRpb25JbkZyYW1lcyAvIGZwcyldIH0pLCBqc3goXCJkaXZcIiwgeyBzdHlsZTogeFNwYWNlciB9KV0gfSksIGpzeChcImRpdlwiLCB7IHN0eWxlOiBmbGV4MSB9KSwgcGxheWJhY2tSYXRlcyAmJiBjYW52YXNTaXplICYmIChqc3goUGxheWJhY2tyYXRlQ29udHJvbCwgeyBjYW52YXNTaXplOiBjYW52YXNTaXplLCBwbGF5YmFja1JhdGVzOiBwbGF5YmFja1JhdGVzIH0pKSwgcGxheWJhY2tSYXRlcyAmJiBzdXBwb3J0c0Z1bGxzY3JlZW4gJiYgYWxsb3dGdWxsc2NyZWVuID8gKGpzeChcImRpdlwiLCB7IHN0eWxlOiB4U3BhY2VyIH0pKSA6IG51bGwsIGpzeChcImRpdlwiLCB7IHN0eWxlOiBmdWxsc2NyZWVuLCBjaGlsZHJlbjogc3VwcG9ydHNGdWxsc2NyZWVuICYmIGFsbG93RnVsbHNjcmVlbiA/IChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBcImFyaWEtbGFiZWxcIjogaXNGdWxsc2NyZWVuID8gJ0V4aXQgZnVsbHNjcmVlbicgOiAnRW50ZXIgRnVsbHNjcmVlbicsIHRpdGxlOiBpc0Z1bGxzY3JlZW4gPyAnRXhpdCBmdWxsc2NyZWVuJyA6ICdFbnRlciBGdWxsc2NyZWVuJywgc3R5bGU6IHBsYXllckJ1dHRvblN0eWxlLCBvbkNsaWNrOiBpc0Z1bGxzY3JlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBvbkV4aXRGdWxsc2NyZWVuQnV0dG9uQ2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBvbkZ1bGxzY3JlZW5CdXR0b25DbGljaywgY2hpbGRyZW46IHJlbmRlckZ1bGxzY3JlZW5CdXR0b24gPT09IG51bGwgPyAoanN4KEZ1bGxzY3JlZW5JY29uLCB7IGlzRnVsbHNjcmVlbjogaXNGdWxsc2NyZWVuIH0pKSA6IChyZW5kZXJGdWxsc2NyZWVuQnV0dG9uKHsgaXNGdWxsc2NyZWVuIH0pKSB9KSkgOiBudWxsIH0pXSB9KSwganN4KFwiZGl2XCIsIHsgc3R5bGU6IHlTcGFjZXIgfSksIGpzeChQbGF5ZXJTZWVrQmFyLCB7IG9uU2Vla0VuZDogb25TZWVrRW5kLCBvblNlZWtTdGFydDogb25TZWVrU3RhcnQsIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXMsIGluRnJhbWU6IGluRnJhbWUsIG91dEZyYW1lOiBvdXRGcmFtZSB9KV0gfSkpO1xufTtcblxuY29uc3QgSVNfTk9ERSA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCc7XG5cbmNvbnN0IGNhbmNlbGxhYmxlUHJvbWlzZSA9IChwcm9taXNlKSA9PiB7XG4gICAgbGV0IGlzQ2FuY2VsZWQgPSBmYWxzZTtcbiAgICBjb25zdCB3cmFwcGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgcHJvbWlzZVxuICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDYW5jZWxlZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdCh7IGlzQ2FuY2VsZWQsIHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUodmFsdWUpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmVqZWN0KHsgaXNDYW5jZWxlZCwgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb21pc2U6IHdyYXBwZWRQcm9taXNlLFxuICAgICAgICBjYW5jZWw6ICgpID0+IHtcbiAgICAgICAgICAgIGlzQ2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICB9LFxuICAgIH07XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm9taXNlLWV4ZWN1dG9yLXJldHVybiAqL1xuY29uc3QgZGVsYXkgPSAobikgPT4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgbikpO1xuXG5jb25zdCB1c2VDYW5jZWxsYWJsZVByb21pc2VzID0gKCkgPT4ge1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlcyA9IHVzZVJlZihbXSk7XG4gICAgY29uc3QgYXBwZW5kUGVuZGluZ1Byb21pc2UgPSB1c2VDYWxsYmFjaygocHJvbWlzZSkgPT4ge1xuICAgICAgICBwZW5kaW5nUHJvbWlzZXMuY3VycmVudCA9IFsuLi5wZW5kaW5nUHJvbWlzZXMuY3VycmVudCwgcHJvbWlzZV07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHJlbW92ZVBlbmRpbmdQcm9taXNlID0gdXNlQ2FsbGJhY2soKHByb21pc2UpID0+IHtcbiAgICAgICAgcGVuZGluZ1Byb21pc2VzLmN1cnJlbnQgPSBwZW5kaW5nUHJvbWlzZXMuY3VycmVudC5maWx0ZXIoKHApID0+IHAgIT09IHByb21pc2UpO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjbGVhclBlbmRpbmdQcm9taXNlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHBlbmRpbmdQcm9taXNlcy5jdXJyZW50Lm1hcCgocCkgPT4gcC5jYW5jZWwoKSksIFtdKTtcbiAgICBjb25zdCBhcGkgPSB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGFwcGVuZFBlbmRpbmdQcm9taXNlLFxuICAgICAgICByZW1vdmVQZW5kaW5nUHJvbWlzZSxcbiAgICAgICAgY2xlYXJQZW5kaW5nUHJvbWlzZXMsXG4gICAgfSksIFthcHBlbmRQZW5kaW5nUHJvbWlzZSwgY2xlYXJQZW5kaW5nUHJvbWlzZXMsIHJlbW92ZVBlbmRpbmdQcm9taXNlXSk7XG4gICAgcmV0dXJuIGFwaTtcbn07XG5cbmNvbnN0IHVzZUNsaWNrUHJldmVudGlvbk9uRG91YmxlQ2xpY2sgPSAob25DbGljaywgb25Eb3VibGVDbGljaywgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW4pID0+IHtcbiAgICBjb25zdCBhcGkgPSB1c2VDYW5jZWxsYWJsZVByb21pc2VzKCk7XG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhhc3luYyAoZSkgPT4ge1xuICAgICAgICBhcGkuY2xlYXJQZW5kaW5nUHJvbWlzZXMoKTtcbiAgICAgICAgY29uc3Qgd2FpdEZvckNsaWNrID0gY2FuY2VsbGFibGVQcm9taXNlKGRlbGF5KDIwMCkpO1xuICAgICAgICBhcGkuYXBwZW5kUGVuZGluZ1Byb21pc2Uod2FpdEZvckNsaWNrKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHdhaXRGb3JDbGljay5wcm9taXNlO1xuICAgICAgICAgICAgYXBpLnJlbW92ZVBlbmRpbmdQcm9taXNlKHdhaXRGb3JDbGljayk7XG4gICAgICAgICAgICBvbkNsaWNrKGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvckluZm8pIHtcbiAgICAgICAgICAgIGNvbnN0IGluZm8gPSBlcnJvckluZm87XG4gICAgICAgICAgICBhcGkucmVtb3ZlUGVuZGluZ1Byb21pc2Uod2FpdEZvckNsaWNrKTtcbiAgICAgICAgICAgIGlmICghaW5mby5pc0NhbmNlbGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgaW5mby5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFthcGksIG9uQ2xpY2tdKTtcbiAgICBjb25zdCBoYW5kbGVEb3VibGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgYXBpLmNsZWFyUGVuZGluZ1Byb21pc2VzKCk7XG4gICAgICAgIG9uRG91YmxlQ2xpY2soKTtcbiAgICB9LCBbYXBpLCBvbkRvdWJsZUNsaWNrXSk7XG4gICAgY29uc3QgcmV0dXJuVmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFkb3VibGVDbGlja1RvRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgcmV0dXJuIFtvbkNsaWNrLCBvbkRvdWJsZUNsaWNrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW2hhbmRsZUNsaWNrLCBoYW5kbGVEb3VibGVDbGlja107XG4gICAgfSwgW1xuICAgICAgICBkb3VibGVDbGlja1RvRnVsbHNjcmVlbixcbiAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgIGhhbmRsZURvdWJsZUNsaWNrLFxuICAgICAgICBvbkNsaWNrLFxuICAgICAgICBvbkRvdWJsZUNsaWNrLFxuICAgIF0pO1xuICAgIHJldHVybiByZXR1cm5WYWx1ZTtcbn07XG5cbmNvbnN0IHJlYWN0VmVyc2lvbiQxID0gUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuaWYgKHJlYWN0VmVyc2lvbiQxID09PSAnMCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZlcnNpb24gJHtyZWFjdFZlcnNpb24kMX0gb2YgXCJyZWFjdFwiIGlzIG5vdCBzdXBwb3J0ZWQgYnkgUmVtb3Rpb25gKTtcbn1cbmNvbnN0IGRvZXNSZWFjdFZlcnNpb25TdXBwb3J0U3VzcGVuc2UkMSA9IHBhcnNlSW50KHJlYWN0VmVyc2lvbiQxLCAxMCkgPj0gMTg7XG5jb25zdCBQbGF5ZXJVSSA9ICh7IGNvbnRyb2xzLCBzdHlsZSwgbG9vcCwgYXV0b1BsYXksIGFsbG93RnVsbHNjcmVlbiwgaW5wdXRQcm9wcywgY2xpY2tUb1BsYXksIHNob3dWb2x1bWVDb250cm9scywgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW4sIHNwYWNlS2V5VG9QbGF5T3JQYXVzZSwgZXJyb3JGYWxsYmFjaywgcGxheWJhY2tSYXRlLCByZW5kZXJMb2FkaW5nLCByZW5kZXJQb3N0ZXIsIGNsYXNzTmFtZSwgbW92ZVRvQmVnaW5uaW5nV2hlbkVuZGVkLCBzaG93UG9zdGVyV2hlblVucGxheWVkLCBzaG93UG9zdGVyV2hlbkVuZGVkLCBzaG93UG9zdGVyV2hlblBhdXNlZCwgaW5GcmFtZSwgb3V0RnJhbWUsIGluaXRpYWxseVNob3dDb250cm9scywgcmVuZGVyRnVsbHNjcmVlbjogcmVuZGVyRnVsbHNjcmVlbkJ1dHRvbiwgcmVuZGVyUGxheVBhdXNlQnV0dG9uLCBhbHdheXNTaG93Q29udHJvbHMsIHNob3dQbGF5YmFja1JhdGVDb250cm9sLCB9LCByZWYpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBjb25maWcgPSBJbnRlcm5hbHMudXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCB2aWRlbyA9IEludGVybmFscy51c2VWaWRlbygpO1xuICAgIGNvbnN0IGNvbnRhaW5lciA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBjYW52YXNTaXplID0gdXNlRWxlbWVudFNpemUoY29udGFpbmVyLCB7XG4gICAgICAgIHRyaWdnZXJPbldpbmRvd1Jlc2l6ZTogZmFsc2UsXG4gICAgICAgIHNob3VsZEFwcGx5Q3NzVHJhbnNmb3JtczogZmFsc2UsXG4gICAgfSk7XG4gICAgY29uc3QgW2hhc1BhdXNlZFRvUmVzdW1lLCBzZXRIYXNQYXVzZWRUb1Jlc3VtZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3Nob3VsZEF1dG9wbGF5LCBzZXRTaG91bGRBdXRvUGxheV0gPSB1c2VTdGF0ZShhdXRvUGxheSk7XG4gICAgY29uc3QgW2lzRnVsbHNjcmVlbiwgc2V0SXNGdWxsc2NyZWVuXSA9IHVzZVN0YXRlKCgpID0+IGZhbHNlKTtcbiAgICBjb25zdCBbc2Vla2luZywgc2V0U2Vla2luZ10gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgdXNlUGxheWJhY2soe1xuICAgICAgICBsb29wLFxuICAgICAgICBwbGF5YmFja1JhdGUsXG4gICAgICAgIG1vdmVUb0JlZ2lubmluZ1doZW5FbmRlZCxcbiAgICAgICAgaW5GcmFtZSxcbiAgICAgICAgb3V0RnJhbWUsXG4gICAgfSk7XG4gICAgY29uc3QgcGxheWVyID0gdXNlUGxheWVyKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGhhc1BhdXNlZFRvUmVzdW1lICYmICFwbGF5ZXIucGxheWluZykge1xuICAgICAgICAgICAgc2V0SGFzUGF1c2VkVG9SZXN1bWUoZmFsc2UpO1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgfVxuICAgIH0sIFtoYXNQYXVzZWRUb1Jlc3VtZSwgcGxheWVyXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBjb250YWluZXI7XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRnVsbHNjcmVlbkNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNldElzRnVsbHNjcmVlbihkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCA9PT0gY3VycmVudCB8fFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50ID09PSBjdXJyZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIG9uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBvbkZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIG9uRnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd3ZWJraXRmdWxsc2NyZWVuY2hhbmdlJywgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3QgdG9nZ2xlID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgaWYgKHBsYXllci5pc1BsYXlpbmcoKSkge1xuICAgICAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwbGF5ZXIucGxheShlKTtcbiAgICAgICAgfVxuICAgIH0sIFtwbGF5ZXJdKTtcbiAgICBjb25zdCByZXF1ZXN0RnVsbHNjcmVlbiA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKCFhbGxvd0Z1bGxzY3JlZW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxsb3dGdWxsc2NyZWVuIGlzIGZhbHNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3VwcG9ydHNGdWxsU2NyZWVuID0gZG9jdW1lbnQuZnVsbHNjcmVlbkVuYWJsZWQgfHwgZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVuYWJsZWQ7XG4gICAgICAgIGlmICghc3VwcG9ydHNGdWxsU2NyZWVuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3dzZXIgZG9lc250IHN1cHBvcnQgZnVsbHNjcmVlbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGFpbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gcGxheWVyIHJlZiBmb3VuZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250YWluZXIuY3VycmVudC53ZWJraXRSZXF1ZXN0RnVsbFNjcmVlbikge1xuICAgICAgICAgICAgY29udGFpbmVyLmN1cnJlbnQud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5jdXJyZW50LnJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9LCBbYWxsb3dGdWxsc2NyZWVuXSk7XG4gICAgY29uc3QgZXhpdEZ1bGxzY3JlZW4gPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC53ZWJraXRFeGl0RnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZG9jdW1lbnQud2Via2l0RXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmV4aXRGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBjb250YWluZXI7XG4gICAgICAgIGlmICghY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bGxzY3JlZW5DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gKF9hID0gZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50O1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudCA9PT0gY29udGFpbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZW1pdHRlci5kaXNwYXRjaEZ1bGxzY3JlZW5DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpc0Z1bGxzY3JlZW46IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwbGF5ZXIuZW1pdHRlci5kaXNwYXRjaEZ1bGxzY3JlZW5DaGFuZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpc0Z1bGxzY3JlZW46IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBmdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdmdWxsc2NyZWVuY2hhbmdlJywgZnVsbHNjcmVlbkNoYW5nZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3dlYmtpdGZ1bGxzY3JlZW5jaGFuZ2UnLCBmdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnVsbHNjcmVlbmNoYW5nZScsIGZ1bGxzY3JlZW5DaGFuZ2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtwbGF5ZXIuZW1pdHRlcl0pO1xuICAgIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXMgPSAoX2EgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuZHVyYXRpb25JbkZyYW1lcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICBjb25zdCBsYXlvdXQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFjb25maWcgfHwgIWNhbnZhc1NpemUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDYW52YXNUcmFuc2Zvcm1hdGlvbih7XG4gICAgICAgICAgICBjYW52YXNTaXplLFxuICAgICAgICAgICAgY29tcG9zaXRpb25IZWlnaHQ6IGNvbmZpZy5oZWlnaHQsXG4gICAgICAgICAgICBjb21wb3NpdGlvbldpZHRoOiBjb25maWcud2lkdGgsXG4gICAgICAgICAgICBwcmV2aWV3U2l6ZTogJ2F1dG8nLFxuICAgICAgICB9KTtcbiAgICB9LCBbY2FudmFzU2l6ZSwgY29uZmlnXSk7XG4gICAgY29uc3Qgc2NhbGUgPSAoX2IgPSBsYXlvdXQgPT09IG51bGwgfHwgbGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXQuc2NhbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDE7XG4gICAgY29uc3QgaW5pdGlhbFNjYWxlSWdub3JlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpbml0aWFsU2NhbGVJZ25vcmVkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGluaXRpYWxTY2FsZUlnbm9yZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGxheWVyLmVtaXR0ZXIuZGlzcGF0Y2hTY2FsZUNoYW5nZShzY2FsZSk7XG4gICAgfSwgW3BsYXllci5lbWl0dGVyLCBzY2FsZV0pO1xuICAgIGNvbnN0IHsgc2V0TWVkaWFWb2x1bWUsIHNldE1lZGlhTXV0ZWQgfSA9IHVzZUNvbnRleHQoSW50ZXJuYWxzLlNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gICAgY29uc3QgeyBtZWRpYU11dGVkLCBtZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dChJbnRlcm5hbHMuTWVkaWFWb2x1bWVDb250ZXh0KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBwbGF5ZXIuZW1pdHRlci5kaXNwYXRjaFZvbHVtZUNoYW5nZShtZWRpYVZvbHVtZSk7XG4gICAgfSwgW3BsYXllci5lbWl0dGVyLCBtZWRpYVZvbHVtZV0pO1xuICAgIGNvbnN0IGlzTXV0ZWQgPSBtZWRpYU11dGVkIHx8IG1lZGlhVm9sdW1lID09PSAwO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHBsYXllci5lbWl0dGVyLmRpc3BhdGNoTXV0ZUNoYW5nZSh7XG4gICAgICAgICAgICBpc011dGVkLFxuICAgICAgICB9KTtcbiAgICB9LCBbcGxheWVyLmVtaXR0ZXIsIGlzTXV0ZWRdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAgICAgcGxheTogcGxheWVyLnBsYXksXG4gICAgICAgICAgICBwYXVzZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmLCBhZnRlciAuc2VlaygpLWluZywgdGhlIHBsYXllciB3YXMgZXhwbGljaXRseSBwYXVzZWQsIHdlIGRvbid0IHJlc3VtZVxuICAgICAgICAgICAgICAgIHNldEhhc1BhdXNlZFRvUmVzdW1lKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBwbGF5ZXIucGF1c2UoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGUsXG4gICAgICAgICAgICBnZXRDb250YWluZXJOb2RlOiAoKSA9PiBjb250YWluZXIuY3VycmVudCxcbiAgICAgICAgICAgIGdldEN1cnJlbnRGcmFtZTogcGxheWVyLmdldEN1cnJlbnRGcmFtZSxcbiAgICAgICAgICAgIGlzUGxheWluZzogKCkgPT4gcGxheWVyLnBsYXlpbmcsXG4gICAgICAgICAgICBzZWVrVG86IChmKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdEZyYW1lID0gZHVyYXRpb25JbkZyYW1lcyAtIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgZnJhbWVUb1NlZWtUbyA9IE1hdGgubWF4KDAsIE1hdGgubWluKGxhc3RGcmFtZSwgZikpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnRpbnVlIHBsYXlpbmcgYWZ0ZXIgc2Vla2luZyBpZiB0aGUgcGxheWVyIHdhcyBwbGF5aW5nIGJlZm9yZVxuICAgICAgICAgICAgICAgIGlmIChwbGF5ZXIuaXNQbGF5aW5nKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF1c2VUb1Jlc3VtZSA9IGZyYW1lVG9TZWVrVG8gIT09IGxhc3RGcmFtZSB8fCBsb29wO1xuICAgICAgICAgICAgICAgICAgICBzZXRIYXNQYXVzZWRUb1Jlc3VtZShwYXVzZVRvUmVzdW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcmFtZVRvU2Vla1RvID09PSBsYXN0RnJhbWUgJiYgIWxvb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgcGxheWVyLmVtaXR0ZXIuZGlzcGF0Y2hFbmRlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwbGF5ZXIuc2VlayhmcmFtZVRvU2Vla1RvKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0Z1bGxzY3JlZW46ICgpID0+IGlzRnVsbHNjcmVlbixcbiAgICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuLFxuICAgICAgICAgICAgZXhpdEZ1bGxzY3JlZW4sXG4gICAgICAgICAgICBnZXRWb2x1bWU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFNdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lZGlhVm9sdW1lO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldFZvbHVtZTogKHZvbCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygdm9sICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzZXRWb2x1bWUoKSB0YWtlcyBhIG51bWJlciwgZ290IHZhbHVlIG9mIHR5cGUgJHt0eXBlb2Ygdm9sfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaXNOYU4odm9sKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzZXRWb2x1bWUoKSBnb3QgYSBudW1iZXIgdGhhdCBpcyBOYU4uIFZvbHVtZSBtdXN0IGJlIGJldHdlZW4gMCBhbmQgMS5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZvbCA8IDAgfHwgdm9sID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBzZXRWb2x1bWUoKSBnb3QgYSBudW1iZXIgdGhhdCBpcyBvdXQgb2YgcmFuZ2UuIE11c3QgYmUgYmV0d2VlbiAwIGFuZCAxLCBnb3QgJHt0eXBlb2Ygdm9sfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRNZWRpYVZvbHVtZSh2b2wpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTXV0ZWQ6ICgpID0+IGlzTXV0ZWQsXG4gICAgICAgICAgICBtdXRlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0TWVkaWFNdXRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bm11dGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRNZWRpYU11dGVkKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRTY2FsZTogKCkgPT4gc2NhbGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHBsYXllci5lbWl0dGVyLCBtZXRob2RzKTtcbiAgICB9LCBbXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGV4aXRGdWxsc2NyZWVuLFxuICAgICAgICBpc0Z1bGxzY3JlZW4sXG4gICAgICAgIGxvb3AsXG4gICAgICAgIG1lZGlhTXV0ZWQsXG4gICAgICAgIGlzTXV0ZWQsXG4gICAgICAgIG1lZGlhVm9sdW1lLFxuICAgICAgICBwbGF5ZXIsXG4gICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuLFxuICAgICAgICBzZXRNZWRpYU11dGVkLFxuICAgICAgICBzZXRNZWRpYVZvbHVtZSxcbiAgICAgICAgdG9nZ2xlLFxuICAgICAgICBzY2FsZSxcbiAgICBdKTtcbiAgICBjb25zdCBWaWRlb0NvbXBvbmVudCA9IHZpZGVvID8gdmlkZW8uY29tcG9uZW50IDogbnVsbDtcbiAgICBjb25zdCBvdXRlclN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVPdXRlclN0eWxlKHsgY2FudmFzU2l6ZSwgY29uZmlnLCBzdHlsZSB9KTtcbiAgICB9LCBbY2FudmFzU2l6ZSwgY29uZmlnLCBzdHlsZV0pO1xuICAgIGNvbnN0IG91dGVyID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVPdXRlcih7IGNvbmZpZywgbGF5b3V0LCBzY2FsZSB9KTtcbiAgICB9LCBbY29uZmlnLCBsYXlvdXQsIHNjYWxlXSk7XG4gICAgY29uc3QgY29udGFpbmVyU3R5bGUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNvbnRhaW5lclN0eWxlKHsgY2FudmFzU2l6ZSwgY29uZmlnLCBsYXlvdXQsIHNjYWxlIH0pO1xuICAgIH0sIFtjYW52YXNTaXplLCBjb25maWcsIGxheW91dCwgc2NhbGVdKTtcbiAgICBjb25zdCBvbkVycm9yID0gdXNlQ2FsbGJhY2soKGVycm9yKSA9PiB7XG4gICAgICAgIHBsYXllci5wYXVzZSgpO1xuICAgICAgICAvLyBQYXkgYXR0ZW50aW9uIHRvIGB0aGlzIGNvbnRleHRgXG4gICAgICAgIHBsYXllci5lbWl0dGVyLmRpc3BhdGNoRXJyb3IoZXJyb3IpO1xuICAgIH0sIFtwbGF5ZXJdKTtcbiAgICBjb25zdCBvbkZ1bGxzY3JlZW5CdXR0b25DbGljayA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgfSwgW3JlcXVlc3RGdWxsc2NyZWVuXSk7XG4gICAgY29uc3Qgb25FeGl0RnVsbHNjcmVlbkJ1dHRvbkNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICB9LCBbZXhpdEZ1bGxzY3JlZW5dKTtcbiAgICBjb25zdCBvblNpbmdsZUNsaWNrID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgdG9nZ2xlKGUpO1xuICAgIH0sIFt0b2dnbGVdKTtcbiAgICBjb25zdCBvblNlZWtTdGFydCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgc2V0U2Vla2luZyh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25TZWVrRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICBzZXRTZWVraW5nKGZhbHNlKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgb25Eb3VibGVDbGljayA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgaWYgKGlzRnVsbHNjcmVlbikge1xuICAgICAgICAgICAgZXhpdEZ1bGxzY3JlZW4oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RGdWxsc2NyZWVuKCk7XG4gICAgICAgIH1cbiAgICB9LCBbZXhpdEZ1bGxzY3JlZW4sIGlzRnVsbHNjcmVlbiwgcmVxdWVzdEZ1bGxzY3JlZW5dKTtcbiAgICBjb25zdCBbaGFuZGxlQ2xpY2ssIGhhbmRsZURvdWJsZUNsaWNrXSA9IHVzZUNsaWNrUHJldmVudGlvbk9uRG91YmxlQ2xpY2sob25TaW5nbGVDbGljaywgb25Eb3VibGVDbGljaywgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW4pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRBdXRvcGxheSkge1xuICAgICAgICAgICAgcGxheWVyLnBsYXkoKTtcbiAgICAgICAgICAgIHNldFNob3VsZEF1dG9QbGF5KGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0sIFtzaG91bGRBdXRvcGxheSwgcGxheWVyXSk7XG4gICAgY29uc3QgbG9hZGluZ01hcmt1cCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVuZGVyTG9hZGluZ1xuICAgICAgICAgICAgPyByZW5kZXJMb2FkaW5nKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBvdXRlclN0eWxlLndpZHRoLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9LCBbb3V0ZXJTdHlsZS5oZWlnaHQsIG91dGVyU3R5bGUud2lkdGgsIHJlbmRlckxvYWRpbmddKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcG9zdGVyID0gcmVuZGVyUG9zdGVyXG4gICAgICAgID8gcmVuZGVyUG9zdGVyKHtcbiAgICAgICAgICAgIGhlaWdodDogb3V0ZXJTdHlsZS5oZWlnaHQsXG4gICAgICAgICAgICB3aWR0aDogb3V0ZXJTdHlsZS53aWR0aCxcbiAgICAgICAgfSlcbiAgICAgICAgOiBudWxsO1xuICAgIGlmIChwb3N0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZW5kZXJQb3N0ZXIoKSBtdXN0IHJldHVybiBhIFJlYWN0IGVsZW1lbnQsIGJ1dCB1bmRlZmluZWQgd2FzIHJldHVybmVkJyk7XG4gICAgfVxuICAgIGNvbnN0IHNob3VsZFNob3dQb3N0ZXIgPSBwb3N0ZXIgJiZcbiAgICAgICAgW1xuICAgICAgICAgICAgc2hvd1Bvc3RlcldoZW5QYXVzZWQgJiYgIXBsYXllci5pc1BsYXlpbmcoKSAmJiAhc2Vla2luZyxcbiAgICAgICAgICAgIHNob3dQb3N0ZXJXaGVuRW5kZWQgJiYgcGxheWVyLmlzTGFzdEZyYW1lICYmICFwbGF5ZXIuaXNQbGF5aW5nKCksXG4gICAgICAgICAgICBzaG93UG9zdGVyV2hlblVucGxheWVkICYmICFwbGF5ZXIuaGFzUGxheWVkICYmICFwbGF5ZXIuaXNQbGF5aW5nKCksXG4gICAgICAgIF0uc29tZShCb29sZWFuKTtcbiAgICBjb25zdCBjb250ZW50ID0gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJkaXZcIiwgeyBzdHlsZTogb3V0ZXIsIG9uQ2xpY2s6IGNsaWNrVG9QbGF5ID8gaGFuZGxlQ2xpY2sgOiB1bmRlZmluZWQsIG9uRG91YmxlQ2xpY2s6IGRvdWJsZUNsaWNrVG9GdWxsc2NyZWVuID8gaGFuZGxlRG91YmxlQ2xpY2sgOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNsYXNzTmFtZTogUExBWUVSX0NTU19DTEFTU05BTUUsIGNoaWxkcmVuOiBWaWRlb0NvbXBvbmVudCA/IChqc3goRXJyb3JCb3VuZGFyeSwgeyBvbkVycm9yOiBvbkVycm9yLCBlcnJvckZhbGxiYWNrOiBlcnJvckZhbGxiYWNrLCBjaGlsZHJlbjoganN4KEludGVybmFscy5DbGlwQ29tcG9zaXRpb24sIHsgY2hpbGRyZW46IGpzeChWaWRlb0NvbXBvbmVudCwgeyAuLi4oKF9jID0gdmlkZW8gPT09IG51bGwgfHwgdmlkZW8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvLnByb3BzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSksIC4uLihpbnB1dFByb3BzICE9PSBudWxsICYmIGlucHV0UHJvcHMgIT09IHZvaWQgMCA/IGlucHV0UHJvcHMgOiB7fSkgfSkgfSkgfSkpIDogbnVsbCB9KSB9KSwgc2hvdWxkU2hvd1Bvc3RlciA/IChqc3goXCJkaXZcIiwgeyBzdHlsZTogb3V0ZXIsIG9uQ2xpY2s6IGNsaWNrVG9QbGF5ID8gaGFuZGxlQ2xpY2sgOiB1bmRlZmluZWQsIG9uRG91YmxlQ2xpY2s6IGRvdWJsZUNsaWNrVG9GdWxsc2NyZWVuID8gaGFuZGxlRG91YmxlQ2xpY2sgOiB1bmRlZmluZWQsIGNoaWxkcmVuOiBwb3N0ZXIgfSkpIDogbnVsbCwgY29udHJvbHMgPyAoanN4KENvbnRyb2xzLCB7IGZwczogY29uZmlnLmZwcywgZHVyYXRpb25JbkZyYW1lczogY29uZmlnLmR1cmF0aW9uSW5GcmFtZXMsIHBsYXllcjogcGxheWVyLCBjb250YWluZXJSZWY6IGNvbnRhaW5lciwgb25GdWxsc2NyZWVuQnV0dG9uQ2xpY2s6IG9uRnVsbHNjcmVlbkJ1dHRvbkNsaWNrLCBpc0Z1bGxzY3JlZW46IGlzRnVsbHNjcmVlbiwgYWxsb3dGdWxsc2NyZWVuOiBhbGxvd0Z1bGxzY3JlZW4sIHNob3dWb2x1bWVDb250cm9sczogc2hvd1ZvbHVtZUNvbnRyb2xzLCBvbkV4aXRGdWxsc2NyZWVuQnV0dG9uQ2xpY2s6IG9uRXhpdEZ1bGxzY3JlZW5CdXR0b25DbGljaywgc3BhY2VLZXlUb1BsYXlPclBhdXNlOiBzcGFjZUtleVRvUGxheU9yUGF1c2UsIG9uU2Vla0VuZDogb25TZWVrRW5kLCBvblNlZWtTdGFydDogb25TZWVrU3RhcnQsIGluRnJhbWU6IGluRnJhbWUsIG91dEZyYW1lOiBvdXRGcmFtZSwgaW5pdGlhbGx5U2hvd0NvbnRyb2xzOiBpbml0aWFsbHlTaG93Q29udHJvbHMsIGNhbnZhc1NpemU6IGNhbnZhc1NpemUsIHJlbmRlckZ1bGxzY3JlZW5CdXR0b246IHJlbmRlckZ1bGxzY3JlZW5CdXR0b24sIHJlbmRlclBsYXlQYXVzZUJ1dHRvbjogcmVuZGVyUGxheVBhdXNlQnV0dG9uLCBhbHdheXNTaG93Q29udHJvbHM6IGFsd2F5c1Nob3dDb250cm9scywgc2hvd1BsYXliYWNrUmF0ZUNvbnRyb2w6IHNob3dQbGF5YmFja1JhdGVDb250cm9sIH0pKSA6IG51bGxdIH0pKTtcbiAgICBpZiAoSVNfTk9ERSAmJiAhZG9lc1JlYWN0VmVyc2lvblN1cHBvcnRTdXNwZW5zZSQxKSB7XG4gICAgICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgcmVmOiBjb250YWluZXIsIHN0eWxlOiBvdXRlclN0eWxlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgY2hpbGRyZW46IGNvbnRlbnQgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyLCBzdHlsZTogb3V0ZXJTdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGNoaWxkcmVuOiBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGxvYWRpbmdNYXJrdXAsIGNoaWxkcmVuOiBjb250ZW50IH0pIH0pKTtcbn07XG52YXIgUGxheWVyVUkkMSA9IGZvcndhcmRSZWYoUGxheWVyVUkpO1xuXG5jb25zdCBWT0xVTUVfUEVSU0lTVEFOQ0VfS0VZID0gJ3JlbW90aW9uLnZvbHVtZVByZWZlcmVuY2UnO1xuY29uc3QgcGVyc2lzdFZvbHVtZSA9ICh2b2x1bWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oVk9MVU1FX1BFUlNJU1RBTkNFX0tFWSwgU3RyaW5nKHZvbHVtZSkpO1xufTtcbmNvbnN0IGdldFByZWZlcnJlZFZvbHVtZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGNvbnN0IHZhbCA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShWT0xVTUVfUEVSU0lTVEFOQ0VfS0VZKTtcbiAgICByZXR1cm4gdmFsID8gTnVtYmVyKHZhbCkgOiAxO1xufTtcblxuY29uc3QgUExBWUVSX0NPTVBfSUQgPSAncGxheWVyLWNvbXAnO1xuY29uc3QgU2hhcmVkUGxheWVyQ29udGV4dHMgPSAoeyBjaGlsZHJlbiwgdGltZWxpbmVDb250ZXh0LCBmcHMsIGNvbXBvc2l0aW9uSGVpZ2h0LCBjb21wb3NpdGlvbldpZHRoLCBkdXJhdGlvbkluRnJhbWVzLCBjb21wb25lbnQsIG51bWJlck9mU2hhcmVkQXVkaW9UYWdzLCBpbml0aWFsbHlNdXRlZCwgfSkgPT4ge1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uTWFuYWdlckNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uczogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogY29tcG9zaXRpb25IZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb21wb3NpdGlvbldpZHRoLFxuICAgICAgICAgICAgICAgICAgICBmcHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBQTEFZRVJfQ09NUF9JRCxcbiAgICAgICAgICAgICAgICAgICAgbm9uY2U6IDc3NyxcbiAgICAgICAgICAgICAgICAgICAgZm9sZGVyTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Rm9sZGVyTmFtZTogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZvbGRlcnM6IFtdLFxuICAgICAgICAgICAgcmVnaXN0ZXJGb2xkZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVucmVnaXN0ZXJGb2xkZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHJlZ2lzdGVyQ29tcG9zaXRpb246ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbjogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGE6IG51bGwsXG4gICAgICAgICAgICBzZXRDdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YTogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2FudmFzQ29udGVudDogeyB0eXBlOiAnY29tcG9zaXRpb24nLCBjb21wb3NpdGlvbklkOiAncGxheWVyLWNvbXAnIH0sXG4gICAgICAgICAgICBzZXRDYW52YXNDb250ZW50OiAoKSA9PiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH0sIFtjb21wb25lbnQsIGR1cmF0aW9uSW5GcmFtZXMsIGNvbXBvc2l0aW9uSGVpZ2h0LCBjb21wb3NpdGlvbldpZHRoLCBmcHNdKTtcbiAgICBjb25zdCBbbWVkaWFNdXRlZCwgc2V0TWVkaWFNdXRlZF0gPSB1c2VTdGF0ZSgoKSA9PiBpbml0aWFsbHlNdXRlZCk7XG4gICAgY29uc3QgW21lZGlhVm9sdW1lLCBzZXRNZWRpYVZvbHVtZV0gPSB1c2VTdGF0ZSgoKSA9PiBnZXRQcmVmZXJyZWRWb2x1bWUoKSk7XG4gICAgY29uc3QgbWVkaWFWb2x1bWVDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lZGlhTXV0ZWQsXG4gICAgICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgfTtcbiAgICB9LCBbbWVkaWFNdXRlZCwgbWVkaWFWb2x1bWVdKTtcbiAgICBjb25zdCBzZXRNZWRpYVZvbHVtZUFuZFBlcnNpc3QgPSB1c2VDYWxsYmFjaygodm9sKSA9PiB7XG4gICAgICAgIHNldE1lZGlhVm9sdW1lKHZvbCk7XG4gICAgICAgIHBlcnNpc3RWb2x1bWUodm9sKTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2V0TWVkaWFWb2x1bWVDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldE1lZGlhTXV0ZWQsXG4gICAgICAgICAgICBzZXRNZWRpYVZvbHVtZTogc2V0TWVkaWFWb2x1bWVBbmRQZXJzaXN0LFxuICAgICAgICB9O1xuICAgIH0sIFtzZXRNZWRpYVZvbHVtZUFuZFBlcnNpc3RdKTtcbiAgICByZXR1cm4gKGpzeChJbnRlcm5hbHMuQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goSW50ZXJuYWxzLlRpbWVsaW5lLlRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGltZWxpbmVDb250ZXh0LCBjaGlsZHJlbjoganN4KEludGVybmFscy5Db21wb3NpdGlvbk1hbmFnZXIuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbXBvc2l0aW9uTWFuYWdlckNvbnRleHQsIGNoaWxkcmVuOiBqc3goSW50ZXJuYWxzLlJlc29sdmVDb21wb3NpdGlvbkNvbmZpZywgeyBjaGlsZHJlbjoganN4KEludGVybmFscy5QcmVmZXRjaFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goSW50ZXJuYWxzLkR1cmF0aW9uc0NvbnRleHRQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KEludGVybmFscy5NZWRpYVZvbHVtZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IG1lZGlhVm9sdW1lQ29udGV4dFZhbHVlLCBjaGlsZHJlbjoganN4KEludGVybmFscy5OYXRpdmVMYXllcnNQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KEludGVybmFscy5TZXRNZWRpYVZvbHVtZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHNldE1lZGlhVm9sdW1lQ29udGV4dFZhbHVlLCBjaGlsZHJlbjoganN4KEludGVybmFscy5TaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciwgeyBudW1iZXJPZkF1ZGlvVGFnczogbnVtYmVyT2ZTaGFyZWRBdWRpb1RhZ3MsIGNvbXBvbmVudDogY29tcG9uZW50LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkgfSkgfSkgfSkgfSkgfSkgfSkgfSkpO1xufTtcblxuY29uc3QgdmFsaWRhdGVTaW5nbGVGcmFtZSA9IChmcmFtZSwgdmFyaWFibGVOYW1lKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gJ3VuZGVmaW5lZCcgfHwgZnJhbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZyYW1lICE9PSBudWxsICYmIGZyYW1lICE9PSB2b2lkIDAgPyBmcmFtZSA6IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJhbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHt2YXJpYWJsZU5hbWV9XCIgbXVzdCBiZSBhIG51bWJlciwgYnV0IGlzICR7SlNPTi5zdHJpbmdpZnkoZnJhbWUpfWApO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKGZyYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcIiR7dmFyaWFibGVOYW1lfVwiIG11c3Qgbm90IGJlIE5hTiwgYnV0IGlzICR7SlNPTi5zdHJpbmdpZnkoZnJhbWUpfWApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgXCIke3ZhcmlhYmxlTmFtZX1cIiBtdXN0IGJlIGZpbml0ZSwgYnV0IGlzICR7SlNPTi5zdHJpbmdpZnkoZnJhbWUpfWApO1xuICAgIH1cbiAgICBpZiAoZnJhbWUgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFwiJHt2YXJpYWJsZU5hbWV9XCIgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgaXMgJHtKU09OLnN0cmluZ2lmeShmcmFtZSl9YCk7XG4gICAgfVxuICAgIHJldHVybiBmcmFtZTtcbn07XG5jb25zdCB2YWxpZGF0ZUluT3V0RnJhbWVzID0gKHsgaW5GcmFtZSwgZHVyYXRpb25JbkZyYW1lcywgb3V0RnJhbWUsIH0pID0+IHtcbiAgICBjb25zdCB2YWxpZGF0ZWRJbkZyYW1lID0gdmFsaWRhdGVTaW5nbGVGcmFtZShpbkZyYW1lLCAnaW5GcmFtZScpO1xuICAgIGNvbnN0IHZhbGlkYXRlZE91dEZyYW1lID0gdmFsaWRhdGVTaW5nbGVGcmFtZShvdXRGcmFtZSwgJ291dEZyYW1lJyk7XG4gICAgaWYgKHZhbGlkYXRlZEluRnJhbWUgPT09IG51bGwgJiYgdmFsaWRhdGVkT3V0RnJhbWUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBNdXN0IG5vdCBiZSBvdmVyIHRoZSBkdXJhdGlvblxuICAgIGlmICh2YWxpZGF0ZWRJbkZyYW1lICE9PSBudWxsICYmIHZhbGlkYXRlZEluRnJhbWUgPiBkdXJhdGlvbkluRnJhbWVzIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2luRnJhbWUgbXVzdCBiZSBsZXNzIHRoYW4gKGR1cmF0aW9uSW5GcmFtZXMgLSAxKSwgYnV0IGlzICcgK1xuICAgICAgICAgICAgdmFsaWRhdGVkSW5GcmFtZSk7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZWRPdXRGcmFtZSAhPT0gbnVsbCAmJiB2YWxpZGF0ZWRPdXRGcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignb3V0RnJhbWUgbXVzdCBiZSBsZXNzIHRoYW4gKGR1cmF0aW9uSW5GcmFtZXMgLSAxKSwgYnV0IGlzICcgK1xuICAgICAgICAgICAgdmFsaWRhdGVkT3V0RnJhbWUpO1xuICAgIH1cbiAgICAvLyBNdXN0IG5vdCBiZSB1bmRlciAwXG4gICAgaWYgKHZhbGlkYXRlZEluRnJhbWUgIT09IG51bGwgJiYgdmFsaWRhdGVkSW5GcmFtZSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbkZyYW1lIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAsIGJ1dCBpcyAnICsgdmFsaWRhdGVkSW5GcmFtZSk7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZWRPdXRGcmFtZSAhPT0gbnVsbCAmJiB2YWxpZGF0ZWRPdXRGcmFtZSA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgb3V0RnJhbWUgbXVzdCBiZSBncmVhdGVyIHRoYW4gMCwgYnV0IGlzICR7dmFsaWRhdGVkT3V0RnJhbWV9LiBJZiB5b3Ugd2FudCB0byByZW5kZXIgYSBzaW5nbGUgZnJhbWUsIHVzZSA8VGh1bWJuYWlsIC8+IGluc3RlYWQuYCk7XG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZWRPdXRGcmFtZSAhPT0gbnVsbCAmJlxuICAgICAgICB2YWxpZGF0ZWRJbkZyYW1lICE9PSBudWxsICYmXG4gICAgICAgIHZhbGlkYXRlZE91dEZyYW1lIDw9IHZhbGlkYXRlZEluRnJhbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRGcmFtZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBpbkZyYW1lLCBidXQgaXMgJyArXG4gICAgICAgICAgICB2YWxpZGF0ZWRPdXRGcmFtZSArXG4gICAgICAgICAgICAnIDw9ICcgK1xuICAgICAgICAgICAgdmFsaWRhdGVkSW5GcmFtZSk7XG4gICAgfVxufTtcblxuY29uc3QgdmFsaWRhdGVJbml0aWFsRnJhbWUgPSAoeyBpbml0aWFsRnJhbWUsIGR1cmF0aW9uSW5GcmFtZXMsIH0pID0+IHtcbiAgICBpZiAodHlwZW9mIGR1cmF0aW9uSW5GcmFtZXMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgZHVyYXRpb25JbkZyYW1lc1xcYCBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgJHtKU09OLnN0cmluZ2lmeShkdXJhdGlvbkluRnJhbWVzKX1gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsRnJhbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbml0aWFsRnJhbWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgaW5pdGlhbEZyYW1lXFxgIG11c3QgYmUgYSBudW1iZXIsIGJ1dCBpcyAke0pTT04uc3RyaW5naWZ5KGluaXRpYWxGcmFtZSl9YCk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4oaW5pdGlhbEZyYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYGluaXRpYWxGcmFtZVxcYCBtdXN0IGJlIGEgbnVtYmVyLCBidXQgaXMgTmFOYCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGluaXRpYWxGcmFtZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGBpbml0aWFsRnJhbWVcXGAgbXVzdCBiZSBhIG51bWJlciwgYnV0IGlzIEluZmluaXR5YCk7XG4gICAgfVxuICAgIGlmIChpbml0aWFsRnJhbWUgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgaW5pdGlhbEZyYW1lXFxgIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGlzICR7SlNPTi5zdHJpbmdpZnkoaW5pdGlhbEZyYW1lKX1gKTtcbiAgICB9XG4gICAgaWYgKGluaXRpYWxGcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXFxgaW5pdGlhbEZyYW1lXFxgIG11c3QgYmUgbGVzcyBvciBlcXVhbCB0aGFuIFxcYGR1cmF0aW9uSW5GcmFtZXMgLSAxXFxgLCBidXQgaXMgJHtKU09OLnN0cmluZ2lmeShpbml0aWFsRnJhbWUpfWApO1xuICAgIH1cbn07XG5cbmNvbnN0IHZhbGlkYXRlUGxheWJhY2tSYXRlID0gKHBsYXliYWNrUmF0ZSkgPT4ge1xuICAgIGlmIChwbGF5YmFja1JhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChwbGF5YmFja1JhdGUgPiA0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGhpZ2hlc3QgcG9zc2libGUgcGxheWJhY2sgcmF0ZSBpcyA0LiBZb3UgcGFzc2VkOiAke3BsYXliYWNrUmF0ZX1gKTtcbiAgICB9XG4gICAgaWYgKHBsYXliYWNrUmF0ZSA8IC00KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIGxvd2VzdCBwb3NzaWJsZSBwbGF5YmFjayByYXRlIGlzIC00LiBZb3UgcGFzc2VkOiAke3BsYXliYWNrUmF0ZX1gKTtcbiAgICB9XG4gICAgaWYgKHBsYXliYWNrUmF0ZSA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgcGxheWJhY2sgcmF0ZSBvZiAwIGlzIG5vdCBzdXBwb3J0ZWQuYCk7XG4gICAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWRlc3RydWN0dXJpbmcgKi9cbmNvbnN0IHZhbGlkYXRlRnBzID0gSW50ZXJuYWxzLnZhbGlkYXRlRnBzO1xuY29uc3QgdmFsaWRhdGVEaW1lbnNpb24gPSBJbnRlcm5hbHMudmFsaWRhdGVEaW1lbnNpb247XG5jb25zdCB2YWxpZGF0ZUR1cmF0aW9uSW5GcmFtZXMgPSBJbnRlcm5hbHMudmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzO1xuY29uc3QgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IEludGVybmFscy52YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzO1xuXG5jb25zdCBjb21wb25lbnRPck51bGxJZkxhenkgPSAocHJvcHMpID0+IHtcbiAgICBpZiAoJ2NvbXBvbmVudCcgaW4gcHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzLmNvbXBvbmVudDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgUGxheWVyRm4gPSAoeyBkdXJhdGlvbkluRnJhbWVzLCBjb21wb3NpdGlvbkhlaWdodCwgY29tcG9zaXRpb25XaWR0aCwgZnBzLCBpbnB1dFByb3BzLCBzdHlsZSwgY29udHJvbHMgPSBmYWxzZSwgbG9vcCA9IGZhbHNlLCBhdXRvUGxheSA9IGZhbHNlLCBzaG93Vm9sdW1lQ29udHJvbHMgPSB0cnVlLCBhbGxvd0Z1bGxzY3JlZW4gPSB0cnVlLCBjbGlja1RvUGxheSwgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW4gPSBmYWxzZSwgc3BhY2VLZXlUb1BsYXlPclBhdXNlID0gdHJ1ZSwgbW92ZVRvQmVnaW5uaW5nV2hlbkVuZGVkID0gdHJ1ZSwgbnVtYmVyT2ZTaGFyZWRBdWRpb1RhZ3MgPSA1LCBlcnJvckZhbGxiYWNrID0gKCkgPT4gJ+KaoO+4jycsIHBsYXliYWNrUmF0ZSA9IDEsIHJlbmRlckxvYWRpbmcsIGNsYXNzTmFtZSwgc2hvd1Bvc3RlcldoZW5VbnBsYXllZCwgc2hvd1Bvc3RlcldoZW5FbmRlZCwgc2hvd1Bvc3RlcldoZW5QYXVzZWQsIGluaXRpYWxGcmFtZSwgcmVuZGVyUG9zdGVyLCBpbkZyYW1lLCBvdXRGcmFtZSwgaW5pdGlhbGx5U2hvd0NvbnRyb2xzLCByZW5kZXJGdWxsc2NyZWVuQnV0dG9uLCByZW5kZXJQbGF5UGF1c2VCdXR0b24sIGFsd2F5c1Nob3dDb250cm9scyA9IGZhbHNlLCBpbml0aWFsbHlNdXRlZCA9IGZhbHNlLCBzaG93UGxheWJhY2tSYXRlQ29udHJvbCA9IGZhbHNlLCAuLi5jb21wb25lbnRQcm9wcyB9LCByZWYpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSB0cnVlO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBpZiAoY29tcG9uZW50UHJvcHMuZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgPFBsYXllciAvPiBjb21wb25lbnQgZG9lcyBub3QgYWNjZXB0IGBkZWZhdWx0UHJvcHNgLCBidXQgc29tZSB3ZXJlIHBhc3NlZC4gVXNlIGBpbnB1dFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnRGb3JWYWxpZGF0aW9uID0gY29tcG9uZW50T3JOdWxsSWZMYXp5KGNvbXBvbmVudFByb3BzKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKChjb21wb25lbnRGb3JWYWxpZGF0aW9uID09PSBudWxsIHx8IGNvbXBvbmVudEZvclZhbGlkYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbXBvbmVudEZvclZhbGlkYXRpb24udHlwZSkgPT09IENvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCdjb21wb25lbnQnIHNob3VsZCBub3QgYmUgYW4gaW5zdGFuY2Ugb2YgPENvbXBvc2l0aW9uLz4uIFBhc3MgdGhlIFJlYWN0IGNvbXBvbmVudCBkaXJlY3RseSwgYW5kIHNldCB0aGUgZHVyYXRpb24sIGZwcyBhbmQgZGltZW5zaW9ucyBhcyBzZXBhcmF0ZSBwcm9wcy4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlcyBmb3IgYW4gZXhhbXBsZS5gKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudEZvclZhbGlkYXRpb24gPT09IENvbXBvc2l0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCdjb21wb25lbnQnIG11c3Qgbm90IGJlIHRoZSAnQ29tcG9zaXRpb24nIGNvbXBvbmVudC4gUGFzcyB5b3VyIG93biBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHksIGFuZCBzZXQgdGhlIGR1cmF0aW9uLCBmcHMgYW5kIGRpbWVuc2lvbnMgYXMgc2VwYXJhdGUgcHJvcHMuIFNlZSBodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvZXhhbXBsZXMgZm9yIGFuIGV4YW1wbGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBvbmVudCA9IEludGVybmFscy51c2VMYXp5Q29tcG9uZW50KGNvbXBvbmVudFByb3BzKTtcbiAgICB2YWxpZGF0ZUluaXRpYWxGcmFtZSh7IGluaXRpYWxGcmFtZSwgZHVyYXRpb25JbkZyYW1lcyB9KTtcbiAgICBjb25zdCBbZnJhbWUsIHNldEZyYW1lXSA9IHVzZVN0YXRlKCgpID0+ICh7XG4gICAgICAgIFtQTEFZRVJfQ09NUF9JRF06IGluaXRpYWxGcmFtZSAhPT0gbnVsbCAmJiBpbml0aWFsRnJhbWUgIT09IHZvaWQgMCA/IGluaXRpYWxGcmFtZSA6IDAsXG4gICAgfSkpO1xuICAgIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcm9vdElkXSA9IHVzZVN0YXRlKCdwbGF5ZXItY29tcCcpO1xuICAgIGNvbnN0IFtlbWl0dGVyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBQbGF5ZXJFbWl0dGVyKCkpO1xuICAgIGNvbnN0IHJvb3RSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgYXVkaW9BbmRWaWRlb1RhZ3MgPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IGltcGVyYXRpdmVQbGF5aW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBbY3VycmVudFBsYXliYWNrUmF0ZSwgc2V0Q3VycmVudFBsYXliYWNrUmF0ZV0gPSB1c2VTdGF0ZShwbGF5YmFja1JhdGUpO1xuICAgIGlmICh0eXBlb2YgY29tcG9zaXRpb25IZWlnaHQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCdjb21wb3NpdGlvbkhlaWdodCcgbXVzdCBiZSBhIG51bWJlciBidXQgZ290ICcke3R5cGVvZiBjb21wb3NpdGlvbkhlaWdodH0nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb21wb3NpdGlvbldpZHRoICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnY29tcG9zaXRpb25XaWR0aCcgbXVzdCBiZSBhIG51bWJlciBidXQgZ290ICcke3R5cGVvZiBjb21wb3NpdGlvbldpZHRofScgaW5zdGVhZGApO1xuICAgIH1cbiAgICB2YWxpZGF0ZURpbWVuc2lvbihjb21wb3NpdGlvbkhlaWdodCwgJ2NvbXBvc2l0aW9uSGVpZ2h0JywgJ29mIHRoZSA8UGxheWVyIC8+IGNvbXBvbmVudCcpO1xuICAgIHZhbGlkYXRlRGltZW5zaW9uKGNvbXBvc2l0aW9uV2lkdGgsICdjb21wb3NpdGlvbldpZHRoJywgJ29mIHRoZSA8UGxheWVyIC8+IGNvbXBvbmVudCcpO1xuICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgICAgIGNvbXBvbmVudDogJ29mIHRoZSA8UGxheWVyLz4gY29tcG9uZW50JyxcbiAgICAgICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHZhbGlkYXRlRnBzKGZwcywgJ2FzIGEgcHJvcCBvZiB0aGUgPFBsYXllci8+IGNvbXBvbmVudCcsIGZhbHNlKTtcbiAgICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzKGlucHV0UHJvcHMsICdpbnB1dFByb3BzJywgbnVsbCk7XG4gICAgdmFsaWRhdGVJbk91dEZyYW1lcyh7XG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIGluRnJhbWUsXG4gICAgICAgIG91dEZyYW1lLFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29udHJvbHMgIT09ICdib29sZWFuJyAmJiB0eXBlb2YgY29udHJvbHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCdjb250cm9scycgbXVzdCBiZSBhIGJvb2xlYW4gb3IgdW5kZWZpbmVkIGJ1dCBnb3QgJyR7dHlwZW9mIGNvbnRyb2xzfScgaW5zdGVhZGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGF1dG9QbGF5ICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIGF1dG9QbGF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnYXV0b1BsYXknIG11c3QgYmUgYSBib29sZWFuIG9yIHVuZGVmaW5lZCBidXQgZ290ICcke3R5cGVvZiBhdXRvUGxheX0nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBsb29wICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIGxvb3AgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCdsb29wJyBtdXN0IGJlIGEgYm9vbGVhbiBvciB1bmRlZmluZWQgYnV0IGdvdCAnJHt0eXBlb2YgbG9vcH0nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb3VibGVDbGlja1RvRnVsbHNjcmVlbiAhPT0gJ2Jvb2xlYW4nICYmXG4gICAgICAgIHR5cGVvZiBkb3VibGVDbGlja1RvRnVsbHNjcmVlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ2RvdWJsZUNsaWNrVG9GdWxsc2NyZWVuJyBtdXN0IGJlIGEgYm9vbGVhbiBvciB1bmRlZmluZWQgYnV0IGdvdCAnJHt0eXBlb2YgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW59JyBpbnN0ZWFkYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2hvd1ZvbHVtZUNvbnRyb2xzICE9PSAnYm9vbGVhbicgJiZcbiAgICAgICAgdHlwZW9mIHNob3dWb2x1bWVDb250cm9scyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ3Nob3dWb2x1bWVDb250cm9scycgbXVzdCBiZSBhIGJvb2xlYW4gb3IgdW5kZWZpbmVkIGJ1dCBnb3QgJyR7dHlwZW9mIHNob3dWb2x1bWVDb250cm9sc30nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhbGxvd0Z1bGxzY3JlZW4gIT09ICdib29sZWFuJyAmJlxuICAgICAgICB0eXBlb2YgYWxsb3dGdWxsc2NyZWVuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnYWxsb3dGdWxsc2NyZWVuJyBtdXN0IGJlIGEgYm9vbGVhbiBvciB1bmRlZmluZWQgYnV0IGdvdCAnJHt0eXBlb2YgYWxsb3dGdWxsc2NyZWVufScgaW5zdGVhZGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNsaWNrVG9QbGF5ICE9PSAnYm9vbGVhbicgJiYgdHlwZW9mIGNsaWNrVG9QbGF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnY2xpY2tUb1BsYXknIG11c3QgYmUgYSBib29sZWFuIG9yIHVuZGVmaW5lZCBidXQgZ290ICcke3R5cGVvZiBjbGlja1RvUGxheX0nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcGFjZUtleVRvUGxheU9yUGF1c2UgIT09ICdib29sZWFuJyAmJlxuICAgICAgICB0eXBlb2Ygc3BhY2VLZXlUb1BsYXlPclBhdXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAnc3BhY2VLZXlUb1BsYXlPclBhdXNlJyBtdXN0IGJlIGEgYm9vbGVhbiBvciB1bmRlZmluZWQgYnV0IGdvdCAnJHt0eXBlb2Ygc3BhY2VLZXlUb1BsYXlPclBhdXNlfScgaW5zdGVhZGApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG51bWJlck9mU2hhcmVkQXVkaW9UYWdzICE9PSAnbnVtYmVyJyB8fFxuICAgICAgICBudW1iZXJPZlNoYXJlZEF1ZGlvVGFncyAlIDEgIT09IDAgfHxcbiAgICAgICAgIU51bWJlci5pc0Zpbml0ZShudW1iZXJPZlNoYXJlZEF1ZGlvVGFncykgfHxcbiAgICAgICAgTnVtYmVyLmlzTmFOKG51bWJlck9mU2hhcmVkQXVkaW9UYWdzKSB8fFxuICAgICAgICBudW1iZXJPZlNoYXJlZEF1ZGlvVGFncyA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJ251bWJlck9mU2hhcmVkQXVkaW9UYWdzJyBtdXN0IGJlIGFuIGludGVnZXIgYnV0IGdvdCAnJHtudW1iZXJPZlNoYXJlZEF1ZGlvVGFnc30nIGluc3RlYWRgKTtcbiAgICB9XG4gICAgdmFsaWRhdGVQbGF5YmFja1JhdGUoY3VycmVudFBsYXliYWNrUmF0ZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZW1pdHRlci5kaXNwYXRjaFJhdGVDaGFuZ2UoY3VycmVudFBsYXliYWNrUmF0ZSk7XG4gICAgfSwgW2VtaXR0ZXIsIGN1cnJlbnRQbGF5YmFja1JhdGVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRDdXJyZW50UGxheWJhY2tSYXRlKHBsYXliYWNrUmF0ZSk7XG4gICAgfSwgW3BsYXliYWNrUmF0ZV0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiByb290UmVmLmN1cnJlbnQsIFtdKTtcbiAgICBjb25zdCB0aW1lbGluZUNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICBwbGF5aW5nLFxuICAgICAgICAgICAgcm9vdElkLFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlOiBjdXJyZW50UGxheWJhY2tSYXRlLFxuICAgICAgICAgICAgaW1wZXJhdGl2ZVBsYXlpbmcsXG4gICAgICAgICAgICBzZXRQbGF5YmFja1JhdGU6IChyYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0Q3VycmVudFBsYXliYWNrUmF0ZShyYXRlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdWRpb0FuZFZpZGVvVGFncyxcbiAgICAgICAgfTtcbiAgICB9LCBbZnJhbWUsIGN1cnJlbnRQbGF5YmFja1JhdGUsIHBsYXlpbmcsIHJvb3RJZF0pO1xuICAgIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRGcmFtZSxcbiAgICAgICAgICAgIHNldFBsYXlpbmcsXG4gICAgICAgIH07XG4gICAgfSwgW3NldEZyYW1lXSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgLy8gSW5qZWN0IENTUyBvbmx5IG9uIGNsaWVudCwgYW5kIGFsc28gb25seSBhZnRlciB0aGUgUGxheWVyIGhhcyBoeWRyYXRlZFxuICAgICAgICAgICAgSW50ZXJuYWxzLkNTU1V0aWxzLmluamVjdENTUyhJbnRlcm5hbHMuQ1NTVXRpbHMubWFrZURlZmF1bHRDU1MoYC4ke1BMQVlFUl9DU1NfQ0xBU1NOQU1FfWAsICcjZmZmJykpO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbElucHV0UHJvcHMgPSB1c2VNZW1vKCgpID0+IGlucHV0UHJvcHMgIT09IG51bGwgJiYgaW5wdXRQcm9wcyAhPT0gdm9pZCAwID8gaW5wdXRQcm9wcyA6IHt9LCBbaW5wdXRQcm9wc10pO1xuICAgIHJldHVybiAoanN4KEludGVybmFscy5Jc1BsYXllckNvbnRleHRQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KFNoYXJlZFBsYXllckNvbnRleHRzLCB7IHRpbWVsaW5lQ29udGV4dDogdGltZWxpbmVDb250ZXh0VmFsdWUsIGNvbXBvbmVudDogY29tcG9uZW50LCBjb21wb3NpdGlvbkhlaWdodDogY29tcG9zaXRpb25IZWlnaHQsIGNvbXBvc2l0aW9uV2lkdGg6IGNvbXBvc2l0aW9uV2lkdGgsIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXMsIGZwczogZnBzLCBudW1iZXJPZlNoYXJlZEF1ZGlvVGFnczogbnVtYmVyT2ZTaGFyZWRBdWRpb1RhZ3MsIGluaXRpYWxseU11dGVkOiBpbml0aWFsbHlNdXRlZCwgY2hpbGRyZW46IGpzeChJbnRlcm5hbHMuVGltZWxpbmUuU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSwgY2hpbGRyZW46IGpzeChQbGF5ZXJFdmVudEVtaXR0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlbWl0dGVyLCBjaGlsZHJlbjoganN4KFBsYXllclVJJDEsIHsgcmVmOiByb290UmVmLCByZW5kZXJMb2FkaW5nOiByZW5kZXJMb2FkaW5nLCBhdXRvUGxheTogQm9vbGVhbihhdXRvUGxheSksIGxvb3A6IEJvb2xlYW4obG9vcCksIGNvbnRyb2xzOiBCb29sZWFuKGNvbnRyb2xzKSwgZXJyb3JGYWxsYmFjazogZXJyb3JGYWxsYmFjaywgc3R5bGU6IHN0eWxlLCBpbnB1dFByb3BzOiBhY3R1YWxJbnB1dFByb3BzLCBhbGxvd0Z1bGxzY3JlZW46IEJvb2xlYW4oYWxsb3dGdWxsc2NyZWVuKSwgbW92ZVRvQmVnaW5uaW5nV2hlbkVuZGVkOiBCb29sZWFuKG1vdmVUb0JlZ2lubmluZ1doZW5FbmRlZCksIGNsaWNrVG9QbGF5OiB0eXBlb2YgY2xpY2tUb1BsYXkgPT09ICdib29sZWFuJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY2xpY2tUb1BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IEJvb2xlYW4oY29udHJvbHMpLCBzaG93Vm9sdW1lQ29udHJvbHM6IEJvb2xlYW4oc2hvd1ZvbHVtZUNvbnRyb2xzKSwgZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW46IEJvb2xlYW4oZG91YmxlQ2xpY2tUb0Z1bGxzY3JlZW4pLCBzcGFjZUtleVRvUGxheU9yUGF1c2U6IEJvb2xlYW4oc3BhY2VLZXlUb1BsYXlPclBhdXNlKSwgcGxheWJhY2tSYXRlOiBjdXJyZW50UGxheWJhY2tSYXRlLCBjbGFzc05hbWU6IGNsYXNzTmFtZSAhPT0gbnVsbCAmJiBjbGFzc05hbWUgIT09IHZvaWQgMCA/IGNsYXNzTmFtZSA6IHVuZGVmaW5lZCwgc2hvd1Bvc3RlcldoZW5VbnBsYXllZDogQm9vbGVhbihzaG93UG9zdGVyV2hlblVucGxheWVkKSwgc2hvd1Bvc3RlcldoZW5FbmRlZDogQm9vbGVhbihzaG93UG9zdGVyV2hlbkVuZGVkKSwgc2hvd1Bvc3RlcldoZW5QYXVzZWQ6IEJvb2xlYW4oc2hvd1Bvc3RlcldoZW5QYXVzZWQpLCByZW5kZXJQb3N0ZXI6IHJlbmRlclBvc3RlciwgaW5GcmFtZTogaW5GcmFtZSAhPT0gbnVsbCAmJiBpbkZyYW1lICE9PSB2b2lkIDAgPyBpbkZyYW1lIDogbnVsbCwgb3V0RnJhbWU6IG91dEZyYW1lICE9PSBudWxsICYmIG91dEZyYW1lICE9PSB2b2lkIDAgPyBvdXRGcmFtZSA6IG51bGwsIGluaXRpYWxseVNob3dDb250cm9sczogaW5pdGlhbGx5U2hvd0NvbnRyb2xzICE9PSBudWxsICYmIGluaXRpYWxseVNob3dDb250cm9scyAhPT0gdm9pZCAwID8gaW5pdGlhbGx5U2hvd0NvbnRyb2xzIDogdHJ1ZSwgcmVuZGVyRnVsbHNjcmVlbjogcmVuZGVyRnVsbHNjcmVlbkJ1dHRvbiAhPT0gbnVsbCAmJiByZW5kZXJGdWxsc2NyZWVuQnV0dG9uICE9PSB2b2lkIDAgPyByZW5kZXJGdWxsc2NyZWVuQnV0dG9uIDogbnVsbCwgcmVuZGVyUGxheVBhdXNlQnV0dG9uOiByZW5kZXJQbGF5UGF1c2VCdXR0b24gIT09IG51bGwgJiYgcmVuZGVyUGxheVBhdXNlQnV0dG9uICE9PSB2b2lkIDAgPyByZW5kZXJQbGF5UGF1c2VCdXR0b24gOiBudWxsLCBhbHdheXNTaG93Q29udHJvbHM6IGFsd2F5c1Nob3dDb250cm9scywgc2hvd1BsYXliYWNrUmF0ZUNvbnRyb2w6IHNob3dQbGF5YmFja1JhdGVDb250cm9sIH0pIH0pIH0pIH0pIH0pKTtcbn07XG5jb25zdCBmb3J3YXJkJDEgPSBmb3J3YXJkUmVmO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQSBjb21wb25lbnQgd2hpY2ggY2FuIGJlIHJlbmRlcmVkIGluIGEgcmVndWxhciBSZWFjdCBBcHAgKGZvciBleGFtcGxlOiBWaXRlLCBOZXh0LmpzKSB0byBkaXNwbGF5IGEgUmVtb3Rpb24gdmlkZW8uXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9wbGF5ZXIvcGxheWVyKVxuICovXG5jb25zdCBQbGF5ZXIgPSBmb3J3YXJkJDEoUGxheWVyRm4pO1xuXG5jb25zdCB1c2VUaHVtYm5haWwgPSAoKSA9PiB7XG4gICAgY29uc3QgZW1pdHRlciA9IHVzZUNvbnRleHQoVGh1bWJuYWlsRW1pdHRlckNvbnRleHQpO1xuICAgIGlmICghZW1pdHRlcikge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBQbGF5ZXIgZXZlbnQgZW1pdHRlciBjb250ZXh0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHJldHVyblZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbWl0dGVyLFxuICAgICAgICB9O1xuICAgIH0sIFtlbWl0dGVyXSk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufTtcblxuY29uc3QgcmVhY3RWZXJzaW9uID0gUmVhY3QudmVyc2lvbi5zcGxpdCgnLicpWzBdO1xuaWYgKHJlYWN0VmVyc2lvbiA9PT0gJzAnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBWZXJzaW9uICR7cmVhY3RWZXJzaW9ufSBvZiBcInJlYWN0XCIgaXMgbm90IHN1cHBvcnRlZCBieSBSZW1vdGlvbmApO1xufVxuY29uc3QgZG9lc1JlYWN0VmVyc2lvblN1cHBvcnRTdXNwZW5zZSA9IHBhcnNlSW50KHJlYWN0VmVyc2lvbiwgMTApID49IDE4O1xuY29uc3QgVGh1bWJuYWlsVUkgPSAoeyBzdHlsZSwgaW5wdXRQcm9wcywgZXJyb3JGYWxsYmFjaywgcmVuZGVyTG9hZGluZywgY2xhc3NOYW1lIH0sIHJlZikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgY29uZmlnID0gSW50ZXJuYWxzLnVzZVVuc2FmZVZpZGVvQ29uZmlnKCk7XG4gICAgY29uc3QgdmlkZW8gPSBJbnRlcm5hbHMudXNlVmlkZW8oKTtcbiAgICBjb25zdCBjb250YWluZXIgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgY2FudmFzU2l6ZSA9IHVzZUVsZW1lbnRTaXplKGNvbnRhaW5lciwge1xuICAgICAgICB0cmlnZ2VyT25XaW5kb3dSZXNpemU6IGZhbHNlLFxuICAgICAgICBzaG91bGRBcHBseUNzc1RyYW5zZm9ybXM6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IGxheW91dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbmZpZyB8fCAhY2FudmFzU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUNhbnZhc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgIGNhbnZhc1NpemUsXG4gICAgICAgICAgICBjb21wb3NpdGlvbkhlaWdodDogY29uZmlnLmhlaWdodCxcbiAgICAgICAgICAgIGNvbXBvc2l0aW9uV2lkdGg6IGNvbmZpZy53aWR0aCxcbiAgICAgICAgICAgIHByZXZpZXdTaXplOiAnYXV0bycsXG4gICAgICAgIH0pO1xuICAgIH0sIFtjYW52YXNTaXplLCBjb25maWddKTtcbiAgICBjb25zdCBzY2FsZSA9IChfYSA9IGxheW91dCA9PT0gbnVsbCB8fCBsYXlvdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dC5zY2FsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICBjb25zdCB0aHVtYm5haWwgPSB1c2VUaHVtYm5haWwoKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBtZXRob2RzID0ge1xuICAgICAgICAgICAgZ2V0Q29udGFpbmVyTm9kZTogKCkgPT4gY29udGFpbmVyLmN1cnJlbnQsXG4gICAgICAgICAgICBnZXRTY2FsZTogKCkgPT4gc2NhbGUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHRodW1ibmFpbC5lbWl0dGVyLCBtZXRob2RzKTtcbiAgICB9LCBbc2NhbGUsIHRodW1ibmFpbC5lbWl0dGVyXSk7XG4gICAgY29uc3QgVmlkZW9Db21wb25lbnQgPSB2aWRlbyA/IHZpZGVvLmNvbXBvbmVudCA6IG51bGw7XG4gICAgY29uc3Qgb3V0ZXJTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlT3V0ZXJTdHlsZSh7IGNvbmZpZywgc3R5bGUsIGNhbnZhc1NpemUgfSk7XG4gICAgfSwgW2NhbnZhc1NpemUsIGNvbmZpZywgc3R5bGVdKTtcbiAgICBjb25zdCBvdXRlciA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gY2FsY3VsYXRlT3V0ZXIoeyBjb25maWcsIGxheW91dCwgc2NhbGUgfSk7XG4gICAgfSwgW2NvbmZpZywgbGF5b3V0LCBzY2FsZV0pO1xuICAgIGNvbnN0IGNvbnRhaW5lclN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGVDb250YWluZXJTdHlsZSh7XG4gICAgICAgICAgICBjYW52YXNTaXplLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgbGF5b3V0LFxuICAgICAgICAgICAgc2NhbGUsXG4gICAgICAgIH0pO1xuICAgIH0sIFtjYW52YXNTaXplLCBjb25maWcsIGxheW91dCwgc2NhbGVdKTtcbiAgICBjb25zdCBvbkVycm9yID0gdXNlQ2FsbGJhY2soKGVycm9yKSA9PiB7XG4gICAgICAgIC8vIFBheSBhdHRlbnRpb24gdG8gYHRoaXMgY29udGV4dGBcbiAgICAgICAgdGh1bWJuYWlsLmVtaXR0ZXIuZGlzcGF0Y2hFcnJvcihlcnJvcik7XG4gICAgfSwgW3RodW1ibmFpbC5lbWl0dGVyXSk7XG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50LCBbXSk7XG4gICAgY29uc3QgbG9hZGluZ01hcmt1cCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcmVuZGVyTG9hZGluZ1xuICAgICAgICAgICAgPyByZW5kZXJMb2FkaW5nKHtcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG91dGVyU3R5bGUuaGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBvdXRlclN0eWxlLndpZHRoLFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIDogbnVsbDtcbiAgICB9LCBbb3V0ZXJTdHlsZS5oZWlnaHQsIG91dGVyU3R5bGUud2lkdGgsIHJlbmRlckxvYWRpbmddKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY29udGVudCA9IChqc3goXCJkaXZcIiwgeyBzdHlsZTogb3V0ZXIsIGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNsYXNzTmFtZTogUExBWUVSX0NTU19DTEFTU05BTUUsIGNoaWxkcmVuOiBWaWRlb0NvbXBvbmVudCA/IChqc3goRXJyb3JCb3VuZGFyeSwgeyBvbkVycm9yOiBvbkVycm9yLCBlcnJvckZhbGxiYWNrOiBlcnJvckZhbGxiYWNrLCBjaGlsZHJlbjoganN4KFZpZGVvQ29tcG9uZW50LCB7IC4uLigoX2IgPSB2aWRlbyA9PT0gbnVsbCB8fCB2aWRlbyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlkZW8ucHJvcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KSwgLi4uKGlucHV0UHJvcHMgIT09IG51bGwgJiYgaW5wdXRQcm9wcyAhPT0gdm9pZCAwID8gaW5wdXRQcm9wcyA6IHt9KSB9KSB9KSkgOiBudWxsIH0pIH0pKTtcbiAgICBpZiAoSVNfTk9ERSAmJiAhZG9lc1JlYWN0VmVyc2lvblN1cHBvcnRTdXNwZW5zZSkge1xuICAgICAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IHJlZjogY29udGFpbmVyLCBzdHlsZTogb3V0ZXJTdHlsZSwgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGNoaWxkcmVuOiBjb250ZW50IH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lciwgc3R5bGU6IG91dGVyU3R5bGUsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCBjaGlsZHJlbjoganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBsb2FkaW5nTWFya3VwLCBjaGlsZHJlbjogY29udGVudCB9KSB9KSk7XG59O1xudmFyIFRodW1ibmFpbFVJJDEgPSBmb3J3YXJkUmVmKFRodW1ibmFpbFVJKTtcblxuY29uc3QgVGh1bWJuYWlsRm4gPSAoeyBmcmFtZVRvRGlzcGxheSwgc3R5bGUsIGlucHV0UHJvcHMsIGNvbXBvc2l0aW9uSGVpZ2h0LCBjb21wb3NpdGlvbldpZHRoLCBkdXJhdGlvbkluRnJhbWVzLCBmcHMsIGNsYXNzTmFtZSwgZXJyb3JGYWxsYmFjayA9ICgpID0+ICfimqDvuI8nLCByZW5kZXJMb2FkaW5nLCAuLi5jb21wb25lbnRQcm9wcyB9LCByZWYpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIgPSB0cnVlO1xuICAgICAgICB9LCBbXSk7XG4gICAgfVxuICAgIGNvbnN0IFt0aHVtYm5haWxJZF0gPSB1c2VTdGF0ZSgoKSA9PiBTdHJpbmcocmFuZG9tKG51bGwpKSk7XG4gICAgY29uc3Qgcm9vdFJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB0aW1lbGluZVN0YXRlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICAgICAgcGxheWluZzogZmFsc2UsXG4gICAgICAgICAgICBmcmFtZToge1xuICAgICAgICAgICAgICAgIFtQTEFZRVJfQ09NUF9JRF06IGZyYW1lVG9EaXNwbGF5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJvb3RJZDogdGh1bWJuYWlsSWQsXG4gICAgICAgICAgICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogMSxcbiAgICAgICAgICAgIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndGh1bWJuYWlsJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXVkaW9BbmRWaWRlb1RhZ3M6IHsgY3VycmVudDogW10gfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sIFtmcmFtZVRvRGlzcGxheSwgdGh1bWJuYWlsSWRdKTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4gcm9vdFJlZi5jdXJyZW50LCBbXSk7XG4gICAgY29uc3QgQ29tcG9uZW50ID0gSW50ZXJuYWxzLnVzZUxhenlDb21wb25lbnQoY29tcG9uZW50UHJvcHMpO1xuICAgIGNvbnN0IFtlbWl0dGVyXSA9IHVzZVN0YXRlKCgpID0+IG5ldyBUaHVtYm5haWxFbWl0dGVyKCkpO1xuICAgIGNvbnN0IHBhc3NlZElucHV0UHJvcHMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGlucHV0UHJvcHMgIT09IG51bGwgJiYgaW5wdXRQcm9wcyAhPT0gdm9pZCAwID8gaW5wdXRQcm9wcyA6IHt9O1xuICAgIH0sIFtpbnB1dFByb3BzXSk7XG4gICAgcmV0dXJuIChqc3goSW50ZXJuYWxzLklzUGxheWVyQ29udGV4dFByb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goU2hhcmVkUGxheWVyQ29udGV4dHMsIHsgdGltZWxpbmVDb250ZXh0OiB0aW1lbGluZVN0YXRlLCBjb21wb25lbnQ6IENvbXBvbmVudCwgY29tcG9zaXRpb25IZWlnaHQ6IGNvbXBvc2l0aW9uSGVpZ2h0LCBjb21wb3NpdGlvbldpZHRoOiBjb21wb3NpdGlvbldpZHRoLCBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzLCBmcHM6IGZwcywgbnVtYmVyT2ZTaGFyZWRBdWRpb1RhZ3M6IDAsIGluaXRpYWxseU11dGVkOiB0cnVlLCBjaGlsZHJlbjoganN4KFRodW1ibmFpbEVtaXR0ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBlbWl0dGVyLCBjaGlsZHJlbjoganN4KFRodW1ibmFpbFVJJDEsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGVycm9yRmFsbGJhY2s6IGVycm9yRmFsbGJhY2ssIGlucHV0UHJvcHM6IHBhc3NlZElucHV0UHJvcHMsIHJlbmRlckxvYWRpbmc6IHJlbmRlckxvYWRpbmcsIHN0eWxlOiBzdHlsZSB9KSB9KSB9KSB9KSk7XG59O1xuY29uc3QgZm9yd2FyZCA9IGZvcndhcmRSZWY7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBIGNvbXBvbmVudCB3aGljaCBjYW4gYmUgcmVuZGVyZWQgaW4gYSByZWd1bGFyIFJlYWN0IEFwcCAoZm9yIGV4YW1wbGU6IENyZWF0ZSBSZWFjdCBBcHAsIE5leHQuanMpIHRvIGRpc3BsYXkgYSBzaW5nbGUgZnJhbWUgb2YgYSB2aWRlby5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci90aHVtYm5haWwpXG4gKi9cbmNvbnN0IFRodW1ibmFpbCA9IGZvcndhcmQoVGh1bWJuYWlsRm4pO1xuXG5jb25zdCBQbGF5ZXJJbnRlcm5hbHMgPSB7XG4gICAgUGxheWVyRXZlbnRFbWl0dGVyQ29udGV4dCxcbiAgICBQbGF5ZXJFbWl0dGVyLFxuICAgIHVzZVBsYXllcixcbiAgICB1c2VQbGF5YmFjayxcbiAgICB1c2VFbGVtZW50U2l6ZSxcbiAgICBjYWxjdWxhdGVDYW52YXNUcmFuc2Zvcm1hdGlvbixcbiAgICB1c2VIb3ZlclN0YXRlLFxuICAgIHVwZGF0ZUFsbEVsZW1lbnRzU2l6ZXMsXG4gICAgY2FsY3VsYXRlU2NhbGUsXG59O1xuXG5leHBvcnQgeyBQbGF5ZXIsIFBsYXllckludGVybmFscywgVGh1bWJuYWlsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/@remotion+player@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/@remotion/player/dist/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../../node_modules/.pnpm/remotion@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/remotion/dist/esm/index.mjs":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/remotion@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/remotion/dist/esm/index.mjs ***!
  \***********************************************************************************************************************/
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsoluteFill: function() { return /* binding */ AbsoluteFill; },\n/* harmony export */   Audio: function() { return /* binding */ Audio; },\n/* harmony export */   Composition: function() { return /* binding */ Composition; },\n/* harmony export */   Config: function() { return /* binding */ Config; },\n/* harmony export */   Easing: function() { return /* binding */ Easing; },\n/* harmony export */   Experimental: function() { return /* binding */ Experimental; },\n/* harmony export */   Folder: function() { return /* binding */ Folder; },\n/* harmony export */   FolderContext: function() { return /* binding */ FolderContext; },\n/* harmony export */   Freeze: function() { return /* binding */ Freeze; },\n/* harmony export */   IFrame: function() { return /* binding */ IFrame; },\n/* harmony export */   Img: function() { return /* binding */ Img; },\n/* harmony export */   Internals: function() { return /* binding */ Internals; },\n/* harmony export */   Loop: function() { return /* binding */ Loop; },\n/* harmony export */   OffthreadVideo: function() { return /* binding */ OffthreadVideo; },\n/* harmony export */   Sequence: function() { return /* binding */ Sequence; },\n/* harmony export */   Series: function() { return /* binding */ Series; },\n/* harmony export */   Still: function() { return /* binding */ Still; },\n/* harmony export */   VERSION: function() { return /* binding */ VERSION; },\n/* harmony export */   Video: function() { return /* binding */ Video; },\n/* harmony export */   cancelRender: function() { return /* binding */ cancelRender; },\n/* harmony export */   continueRender: function() { return /* binding */ continueRender; },\n/* harmony export */   delayRender: function() { return /* binding */ delayRender; },\n/* harmony export */   getInputProps: function() { return /* binding */ getInputProps; },\n/* harmony export */   getRemotionEnvironment: function() { return /* binding */ getRemotionEnvironment; },\n/* harmony export */   getStaticFiles: function() { return /* binding */ getStaticFiles; },\n/* harmony export */   interpolate: function() { return /* binding */ interpolate; },\n/* harmony export */   interpolateColors: function() { return /* binding */ interpolateColors; },\n/* harmony export */   measureSpring: function() { return /* binding */ measureSpring; },\n/* harmony export */   prefetch: function() { return /* binding */ prefetch; },\n/* harmony export */   random: function() { return /* binding */ random; },\n/* harmony export */   registerRoot: function() { return /* binding */ registerRoot; },\n/* harmony export */   spring: function() { return /* binding */ spring; },\n/* harmony export */   staticFile: function() { return /* binding */ staticFile; },\n/* harmony export */   useCurrentFrame: function() { return /* binding */ useCurrentFrame; },\n/* harmony export */   useVideoConfig: function() { return /* binding */ useVideoConfig; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react-dom/index.js\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/polyfills/process.js\");\n\n\n\n\nconst NativeLayersContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setClipRegion: () => {\n        throw new Error('NativeLayers not set');\n    },\n    clipRegion: null,\n});\nconst NativeLayersProvider = ({ children, }) => {\n    const [clipRegion, setClipRegion] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            setClipRegion,\n            clipRegion,\n        };\n    }, [clipRegion, setClipRegion]);\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            window.remotion_getClipRegion = () => {\n                return clipRegion;\n            };\n        }, [clipRegion, setClipRegion]);\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, { value: context, children: children }));\n};\n\nconst Clipper = ({ height, width, x, y }) => {\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        setClipRegion((c) => {\n            if (c === 'hide') {\n                throw new Error('Cannot render <Clipper>, because another <Null> is already rendered');\n            }\n            if (c === null) {\n                return { height, width, x, y };\n            }\n            throw new Error('Cannot render <Clipper>, because another component clipping the region was already rendered (most likely <Clipper>)');\n        });\n        return () => {\n            setClipRegion(null);\n        };\n    }, [height, setClipRegion, width, x, y]);\n    return null;\n};\n\nconst IsPlayerContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nconst IsPlayerContextProvider = ({ children, }) => {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(IsPlayerContext.Provider, { value: true, children: children });\n};\nconst useIsPlayer = () => {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(IsPlayerContext);\n};\n\nfunction truthy(value) {\n    return Boolean(value);\n}\n\n// Automatically generated on publish\nconst VERSION = '4.0.47';\n\nconst checkMultipleRemotionVersions = () => {\n    if (typeof globalThis === 'undefined') {\n        return;\n    }\n    const alreadyImported = globalThis.remotion_imported ||\n        (typeof window !== 'undefined' && window.remotion_imported);\n    if (alreadyImported) {\n        if (alreadyImported === VERSION) {\n            // Next.JS will reload the package and cause a server-side warning.\n            // It's okay if this happens during SSR in developement\n            return;\n        }\n        throw new TypeError(`🚨 Multiple versions of Remotion detected: ${[\n            VERSION,\n            typeof alreadyImported === 'string'\n                ? alreadyImported\n                : 'an older version',\n        ]\n            .filter(truthy)\n            .join(' and ')}. This will cause things to break in an unexpected way.\\nCheck that all your Remotion packages are on the same version. If your dependencies depend on Remotion, make them peer dependencies. You can also run \\`npx remotion versions\\` from your terminal to see which versions are mismatching.`);\n    }\n    globalThis.remotion_imported = VERSION;\n    if (typeof window !== 'undefined') {\n        window.remotion_imported = VERSION;\n    }\n};\n\nconst Null = () => {\n    const { setClipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        setClipRegion((c) => {\n            if (c === null) {\n                return 'hide';\n            }\n            // Rendering multiple <Null> is fine, because they are all hidden\n            if (c === 'hide') {\n                return 'hide';\n            }\n            throw new Error('Cannot render <Null>, because another component clipping the region was already rendered (most likely <Clipper>)');\n        });\n        return () => {\n            setClipRegion(null);\n        };\n    }, [setClipRegion]);\n    return null;\n};\n\nconst AbsoluteFillRefForwarding = (props, ref) => {\n    const { style, ...other } = props;\n    const actualStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            right: 0,\n            bottom: 0,\n            width: '100%',\n            height: '100%',\n            display: 'flex',\n            flexDirection: 'column',\n            ...style,\n        };\n    }, [style]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"div\", { ref: ref, style: actualStyle, ...other });\n};\n/**\n * @description An absolutely positioned <div> element with 100% width, height, and a column flex style\n * @see [Documentation](https://www.remotion.dev/docs/absolute-fill)\n */\nconst AbsoluteFill = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AbsoluteFillRefForwarding);\n\nconst getAbsoluteSrc = (relativeSrc) => {\n    return new URL(relativeSrc, window.location.origin).href;\n};\n\nconst calculateLoopDuration = ({ endAt, mediaDuration, playbackRate, startFrom, }) => {\n    let duration = mediaDuration;\n    // Account for endAt\n    if (typeof endAt !== 'undefined') {\n        duration = endAt;\n    }\n    // Account for startFrom\n    if (typeof startFrom !== 'undefined') {\n        duration -= startFrom;\n    }\n    const actualDuration = duration / playbackRate;\n    return Math.floor(actualDuration);\n};\n\nconst isErrorLike = (err) => {\n    if (err === null) {\n        return false;\n    }\n    if (typeof err !== 'object') {\n        return false;\n    }\n    if (!('stack' in err)) {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n    // @ts-ignore we just asserted\n    if (typeof err.stack !== 'string') {\n        return false;\n    }\n    if (!('message' in err)) {\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n    // @ts-ignore we just asserted\n    if (typeof err.message !== 'string') {\n        return false;\n    }\n    return true;\n};\n/**\n * @description When you invoke this function, Remotion will stop rendering all the frames without any retries\n * @see [Documentation](https://www.remotion.dev/docs/cancel-render)\n */\nfunction cancelRender(err) {\n    let error;\n    if (isErrorLike(err)) {\n        error = err;\n    }\n    else if (typeof err === 'string') {\n        error = Error(err);\n    }\n    else {\n        error = Error('Rendering was cancelled');\n    }\n    window.remotion_cancelledError = error.stack;\n    throw error;\n}\n\n/**\n * @description Provides information about the Remotion Environment\n * @see [Documentation](https://www.remotion.dev/docs/get-remotion-environment)\n */\nconst getRemotionEnvironment = () => {\n    if (false) {}\n    // The Vitest framework sets NODE_ENV as test.\n    // Right now we don't need to treat it in a special\n    // way which is good - defaulting to `rendering`.\n    if (false) {}\n    if (typeof window !== 'undefined' && window.remotion_isPlayer) {\n        return {\n            isStudio: false,\n            isRendering: false,\n            isPlayer: true,\n        };\n    }\n    return {\n        isStudio: true,\n        isRendering: false,\n        isPlayer: false,\n    };\n};\n\nconst HIDDEN_NAMES = ['__WEBPACK_DEFAULT_EXPORT__'];\nconst getTimelineClipName = (children) => {\n    var _a;\n    const tree = (_a = react__WEBPACK_IMPORTED_MODULE_0__.Children.map(children, (ch) => {\n        if (!(0,react__WEBPACK_IMPORTED_MODULE_0__.isValidElement)(ch)) {\n            return null;\n        }\n        // Must be name, not ID\n        const name = typeof ch.type !== 'string' && ch.type.name;\n        if (name && !HIDDEN_NAMES.includes(name)) {\n            return name;\n        }\n        if (ch.props.children) {\n            const chName = getTimelineClipName(ch.props.children);\n            return chName;\n        }\n        return null;\n    })) === null || _a === void 0 ? void 0 : _a.filter(Boolean);\n    return (tree === null || tree === void 0 ? void 0 : tree.length) ? tree[0] : '';\n};\n\nconst NonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    getNonce: () => 0,\n    fastRefreshes: 0,\n});\nconst useNonce = () => {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NonceContext);\n    const [nonce, setNonce] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => context.getNonce());\n    const lastContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(context);\n    // Only if context changes, but not initially\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (lastContext.current === context) {\n            return;\n        }\n        lastContext.current = context;\n        setNonce(context.getNonce);\n    }, [context]);\n    return nonce;\n};\n\nconst SequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\n\nconst SequenceManager = react__WEBPACK_IMPORTED_MODULE_0__.createContext({\n    registerSequence: () => {\n        throw new Error('SequenceManagerContext not initialized');\n    },\n    unregisterSequence: () => {\n        throw new Error('SequenceManagerContext not initialized');\n    },\n    sequences: [],\n});\nconst SequenceManagerProvider = ({ children }) => {\n    const [sequences, setSequences] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n        setSequences((seqs) => {\n            return [...seqs, seq];\n        });\n    }, []);\n    const unregisterSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((seq) => {\n        setSequences((seqs) => seqs.filter((s) => s.id !== seq));\n    }, []);\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            registerSequence,\n            sequences,\n            unregisterSequence,\n        };\n    }, [registerSequence, sequences, unregisterSequence]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, { value: context, children: children }));\n};\n\nconst CompositionManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    compositions: [],\n    registerComposition: () => undefined,\n    unregisterComposition: () => undefined,\n    registerFolder: () => undefined,\n    unregisterFolder: () => undefined,\n    setCurrentCompositionMetadata: () => undefined,\n    folders: [],\n    currentCompositionMetadata: null,\n    canvasContent: null,\n    setCanvasContent: () => undefined,\n});\n\nconst problematicCharacters = {\n    '%3A': ':',\n    '%2F': '/',\n    '%3F': '?',\n    '%23': '#',\n    '%5B': '[',\n    '%5D': ']',\n    '%40': '@',\n    '%21': '!',\n    '%24': '$',\n    '%26': '&',\n    '%27': \"'\",\n    '%28': '(',\n    '%29': ')',\n    '%2A': '*',\n    '%2B': '+',\n    '%2C': ',',\n    '%3B': ';',\n};\nconst didWarn$1 = {};\nconst warnOnce$1 = (message) => {\n    if (didWarn$1[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn$1[message] = true;\n};\nconst includesHexOfUnsafeChar = (path) => {\n    for (const key of Object.keys(problematicCharacters)) {\n        if (path.includes(key)) {\n            return { containsHex: true, hexCode: key };\n        }\n    }\n    return { containsHex: false };\n};\nconst trimLeadingSlash = (path) => {\n    if (path.startsWith('/')) {\n        return trimLeadingSlash(path.substring(1));\n    }\n    return path;\n};\nconst inner = (path) => {\n    if (typeof window !== 'undefined' && window.remotion_staticBase) {\n        if (path.startsWith(window.remotion_staticBase)) {\n            throw new Error(`The value \"${path}\" is already prefixed with the static base ${window.remotion_staticBase}. You don't need to call staticFile() on it.`);\n        }\n        return `${window.remotion_staticBase}/${trimLeadingSlash(path)}`;\n    }\n    return `/${trimLeadingSlash(path)}`;\n};\nconst encodeBySplitting = (path) => {\n    const splitBySlash = path.split('/');\n    const encodedArray = splitBySlash.map((element) => {\n        return encodeURIComponent(element);\n    });\n    const merged = encodedArray.join('/');\n    return merged;\n};\n/**\n * @description Reference a file from the public/ folder. If the file does not appear in the autocomplete, type the path manually.\n * @see [Documentation](https://www.remotion.dev/docs/staticfile)\n */\nconst staticFile = (path) => {\n    if (path.startsWith('http://') || path.startsWith('https://')) {\n        throw new TypeError(`staticFile() does not support remote URLs - got \"${path}\". Instead, pass the URL without wrapping it in staticFile(). See: https://remotion.dev/docs/staticfile-remote-urls`);\n    }\n    if (path.startsWith('..') || path.startsWith('./')) {\n        throw new TypeError(`staticFile() does not support relative paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith('/Users') ||\n        path.startsWith('/home') ||\n        path.startsWith('/tmp') ||\n        path.startsWith('/etc') ||\n        path.startsWith('/opt') ||\n        path.startsWith('/var') ||\n        path.startsWith('C:') ||\n        path.startsWith('D:') ||\n        path.startsWith('E:')) {\n        throw new TypeError(`staticFile() does not support absolute paths - got \"${path}\". Instead, pass the name of a file that is inside the public/ folder. See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    if (path.startsWith('public/')) {\n        throw new TypeError(`Do not include the public/ prefix when using staticFile() - got \"${path}\". See: https://remotion.dev/docs/staticfile-relative-paths`);\n    }\n    const includesHex = includesHexOfUnsafeChar(path);\n    if (includesHex.containsHex) {\n        warnOnce$1(`WARNING: You seem to pass an already encoded path (path contains ${includesHex.hexCode}). Since Remotion 4.0, the encoding is done by staticFile() itself. You may want to remove a encodeURIComponent() wrapping.`);\n    }\n    const preprocessed = encodeBySplitting(path);\n    const preparsed = inner(preprocessed);\n    if (!preparsed.startsWith('/')) {\n        return `/${preparsed}`;\n    }\n    return preparsed;\n};\n\n// Must keep this file in sync with the one in packages/lambda/src/shared/serialize-props.ts!\nconst DATE_TOKEN = 'remotion-date:';\nconst FILE_TOKEN = 'remotion-file:';\nconst serializeJSONWithDate = ({ data, indent, staticBase, }) => {\n    let customDateUsed = false;\n    let customFileUsed = false;\n    let mapUsed = false;\n    let setUsed = false;\n    const serializedString = JSON.stringify(data, function (key, value) {\n        const item = this[key];\n        if (item instanceof Date) {\n            customDateUsed = true;\n            return `${DATE_TOKEN}${item.toISOString()}`;\n        }\n        if (item instanceof Map) {\n            mapUsed = true;\n            return value;\n        }\n        if (item instanceof Set) {\n            setUsed = true;\n            return value;\n        }\n        if (typeof item === 'string' &&\n            staticBase !== null &&\n            item.startsWith(staticBase)) {\n            customFileUsed = true;\n            return `${FILE_TOKEN}${item.replace(staticBase + '/', '')}`;\n        }\n        return value;\n    }, indent);\n    return { serializedString, customDateUsed, customFileUsed, mapUsed, setUsed };\n};\nconst deserializeJSONWithCustomFields = (data) => {\n    return JSON.parse(data, (_, value) => {\n        if (typeof value === 'string' && value.startsWith(DATE_TOKEN)) {\n            return new Date(value.replace(DATE_TOKEN, ''));\n        }\n        if (typeof value === 'string' && value.startsWith(FILE_TOKEN)) {\n            return staticFile(value.replace(FILE_TOKEN, ''));\n        }\n        return value;\n    });\n};\n\nlet didWarnSSRImport = false;\nconst warnOnceSSRImport = () => {\n    if (didWarnSSRImport) {\n        return;\n    }\n    didWarnSSRImport = true;\n    console.warn('Called `getInputProps()` on the server. This function is not available server-side and has returned an empty object.');\n    console.warn(\"To hide this warning, don't call this function on the server:\");\n    console.warn(\"  typeof window === 'undefined' ? {} : getInputProps()\");\n};\nconst getInputProps = () => {\n    if (typeof window === 'undefined') {\n        warnOnceSSRImport();\n        return {};\n    }\n    if (getRemotionEnvironment().isPlayer) {\n        throw new Error('You cannot call `getInputProps()` from a <Player>. Instead, the props are available as React props from component that you passed as `component` prop.');\n    }\n    const param = window.remotion_inputProps;\n    if (!param) {\n        return {};\n    }\n    const parsed = deserializeJSONWithCustomFields(param);\n    return parsed;\n};\n\nconst EditorPropsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    props: {},\n    updateProps: () => {\n        throw new Error('Not implemented');\n    },\n});\nconst EditorPropsProvider = ({ children }) => {\n    const [props, setProps] = react__WEBPACK_IMPORTED_MODULE_0__.useState({});\n    const updateProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ defaultProps, id, newProps, }) => {\n        setProps((prev) => {\n            var _a;\n            return {\n                ...prev,\n                [id]: typeof newProps === 'function'\n                    ? newProps((_a = prev[id]) !== null && _a !== void 0 ? _a : defaultProps)\n                    : newProps,\n            };\n        });\n    }, []);\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return { props, updateProps };\n    }, [props, updateProps]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsContext.Provider, { value: ctx, children: children }));\n};\n\nfunction validateDimension(amount, nameOfProp, location) {\n    if (typeof amount !== 'number') {\n        throw new Error(`The \"${nameOfProp}\" prop ${location} must be a number, but you passed a value of type ${typeof amount}`);\n    }\n    if (isNaN(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must not be NaN, but is NaN.`);\n    }\n    if (!Number.isFinite(amount)) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be finite, but is ${amount}.`);\n    }\n    if (amount % 1 !== 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be an integer, but is ${amount}.`);\n    }\n    if (amount <= 0) {\n        throw new TypeError(`The \"${nameOfProp}\" prop ${location} must be positive, but got ${amount}.`);\n    }\n}\n\nfunction validateDurationInFrames(durationInFrames, options) {\n    const { allowFloats, component } = options;\n    if (typeof durationInFrames === 'undefined') {\n        throw new Error(`The \"durationInFrames\" prop ${component} is missing.`);\n    }\n    if (typeof durationInFrames !== 'number') {\n        throw new Error(`The \"durationInFrames\" prop ${component} must be a number, but you passed a value of type ${typeof durationInFrames}`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be positive, but got ${durationInFrames}.`);\n    }\n    if (!allowFloats && durationInFrames % 1 !== 0) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be an integer, but got ${durationInFrames}.`);\n    }\n    if (!Number.isFinite(durationInFrames)) {\n        throw new TypeError(`The \"durationInFrames\" prop ${component} must be finite, but got ${durationInFrames}.`);\n    }\n}\n\nfunction validateFps(fps, location, isGif) {\n    if (typeof fps !== 'number') {\n        throw new Error(`\"fps\" must be a number, but you passed a value of type ${typeof fps} ${location}`);\n    }\n    if (!Number.isFinite(fps)) {\n        throw new Error(`\"fps\" must be a finite, but you passed ${fps} ${location}`);\n    }\n    if (isNaN(fps)) {\n        throw new Error(`\"fps\" must not be NaN, but got ${fps} ${location}`);\n    }\n    if (fps <= 0) {\n        throw new TypeError(`\"fps\" must be positive, but got ${fps} ${location}`);\n    }\n    if (isGif && fps > 50) {\n        throw new TypeError(`The FPS for a GIF cannot be higher than 50. Use the --every-nth-frame option to lower the FPS: https://remotion.dev/docs/render-as-gif`);\n    }\n}\n\nconst validateCalculated = ({ composition, calculated, }) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const calculateMetadataErrorLocation = `calculated by calculateMetadata() for the composition \"${composition.id}\"`;\n    const defaultErrorLocation = `of the \"<Composition />\" component with the id \"${composition.id}\"`;\n    const width = (_b = (_a = calculated === null || calculated === void 0 ? void 0 : calculated.width) !== null && _a !== void 0 ? _a : composition.width) !== null && _b !== void 0 ? _b : undefined;\n    validateDimension(width, 'width', (calculated === null || calculated === void 0 ? void 0 : calculated.width) ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const height = (_d = (_c = calculated === null || calculated === void 0 ? void 0 : calculated.height) !== null && _c !== void 0 ? _c : composition.height) !== null && _d !== void 0 ? _d : undefined;\n    validateDimension(height, 'height', (calculated === null || calculated === void 0 ? void 0 : calculated.height) ? calculateMetadataErrorLocation : defaultErrorLocation);\n    const fps = (_f = (_e = calculated === null || calculated === void 0 ? void 0 : calculated.fps) !== null && _e !== void 0 ? _e : composition.fps) !== null && _f !== void 0 ? _f : null;\n    validateFps(fps, (calculated === null || calculated === void 0 ? void 0 : calculated.fps) ? calculateMetadataErrorLocation : defaultErrorLocation, false);\n    const durationInFrames = (_h = (_g = calculated === null || calculated === void 0 ? void 0 : calculated.durationInFrames) !== null && _g !== void 0 ? _g : composition.durationInFrames) !== null && _h !== void 0 ? _h : null;\n    validateDurationInFrames(durationInFrames, {\n        allowFloats: false,\n        component: `of the \"<Composition />\" component with the id \"${composition.id}\"`,\n    });\n    return { width, height, fps, durationInFrames };\n};\nconst resolveVideoConfig = ({ composition, editorProps: editorPropsOrUndefined, signal, inputProps, }) => {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const calculatedProm = composition.calculateMetadata\n        ? composition.calculateMetadata({\n            defaultProps: (_a = composition.defaultProps) !== null && _a !== void 0 ? _a : {},\n            props: {\n                ...((_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {}),\n                ...(editorPropsOrUndefined !== null && editorPropsOrUndefined !== void 0 ? editorPropsOrUndefined : {}),\n                ...inputProps,\n            },\n            abortSignal: signal,\n        })\n        : null;\n    const fallbackProps = {\n        ...((_c = composition.defaultProps) !== null && _c !== void 0 ? _c : {}),\n        ...(inputProps !== null && inputProps !== void 0 ? inputProps : {}),\n    };\n    if (calculatedProm !== null &&\n        typeof calculatedProm === 'object' &&\n        'then' in calculatedProm) {\n        return calculatedProm.then((c) => {\n            var _a, _b;\n            const { height, width, durationInFrames, fps } = validateCalculated({\n                calculated: c,\n                composition,\n            });\n            return {\n                width,\n                height,\n                fps,\n                durationInFrames,\n                id: composition.id,\n                defaultProps: (_a = composition.defaultProps) !== null && _a !== void 0 ? _a : {},\n                props: (_b = c.props) !== null && _b !== void 0 ? _b : fallbackProps,\n            };\n        });\n    }\n    const data = validateCalculated({\n        calculated: calculatedProm,\n        composition,\n    });\n    if (calculatedProm === null) {\n        return {\n            ...data,\n            id: composition.id,\n            defaultProps: (_d = composition.defaultProps) !== null && _d !== void 0 ? _d : {},\n            props: fallbackProps,\n        };\n    }\n    return {\n        ...data,\n        id: composition.id,\n        defaultProps: (_e = composition.defaultProps) !== null && _e !== void 0 ? _e : {},\n        props: (_g = (_f = calculatedProm.props) !== null && _f !== void 0 ? _f : composition.defaultProps) !== null && _g !== void 0 ? _g : {},\n    };\n};\n\nconst ResolveCompositionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst resolveCompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)();\nconst needsResolution = (composition) => {\n    return Boolean(composition.calculateMetadata);\n};\nconst ResolveCompositionConfig = ({ children }) => {\n    const [currentRenderModalComposition, setCurrentRenderModalComposition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selectedComposition = compositions.find((c) => canvasContent &&\n        canvasContent.type === 'composition' &&\n        canvasContent.compositionId === c.id);\n    const renderModalComposition = compositions.find((c) => c.id === currentRenderModalComposition);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const [resolvedConfigs, setResolvedConfigs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return selectedComposition\n            ? (_a = allEditorProps[selectedComposition.id]) !== null && _a !== void 0 ? _a : {}\n            : {};\n    }, [allEditorProps, selectedComposition]);\n    const renderModalProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return renderModalComposition\n            ? (_a = allEditorProps[renderModalComposition.id]) !== null && _a !== void 0 ? _a : {}\n            : {};\n    }, [allEditorProps, renderModalComposition]);\n    const doResolution = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((composition, editorProps) => {\n        var _a;\n        const controller = new AbortController();\n        if (currentCompositionMetadata) {\n            return controller;\n        }\n        const inputProps = typeof window === 'undefined' || getRemotionEnvironment().isPlayer\n            ? {}\n            : (_a = getInputProps()) !== null && _a !== void 0 ? _a : {};\n        const { signal } = controller;\n        const promOrNot = resolveVideoConfig({\n            composition,\n            editorProps,\n            inputProps,\n            signal,\n        });\n        if (typeof promOrNot === 'object' && 'then' in promOrNot) {\n            setResolvedConfigs((r) => ({\n                ...r,\n                [composition.id]: {\n                    type: 'loading',\n                },\n            }));\n            promOrNot\n                .then((c) => {\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r) => ({\n                    ...r,\n                    [composition.id]: {\n                        type: 'success',\n                        result: c,\n                    },\n                }));\n            })\n                .catch((err) => {\n                if (controller.signal.aborted) {\n                    return;\n                }\n                setResolvedConfigs((r) => ({\n                    ...r,\n                    [composition.id]: {\n                        type: 'error',\n                        error: err,\n                    },\n                }));\n            });\n        }\n        else {\n            setResolvedConfigs((r) => ({\n                ...r,\n                [composition.id]: {\n                    type: 'success',\n                    result: promOrNot,\n                },\n            }));\n        }\n        return controller;\n    }, [currentCompositionMetadata]);\n    const currentComposition = (canvasContent === null || canvasContent === void 0 ? void 0 : canvasContent.type) === 'composition' ? canvasContent.compositionId : null;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(resolveCompositionsRef, () => {\n        return {\n            setCurrentRenderModalComposition: (id) => {\n                setCurrentRenderModalComposition(id);\n            },\n            reloadCurrentlySelectedComposition: () => {\n                var _a;\n                if (!currentComposition) {\n                    return;\n                }\n                const composition = compositions.find((c) => c.id === currentComposition);\n                if (!composition) {\n                    throw new Error(`Could not find composition with id ${currentComposition}`);\n                }\n                const editorProps = (_a = allEditorProps[currentComposition]) !== null && _a !== void 0 ? _a : {};\n                doResolution(composition, editorProps);\n            },\n        };\n    }, [allEditorProps, compositions, currentComposition, doResolution]);\n    const isTheSame = (selectedComposition === null || selectedComposition === void 0 ? void 0 : selectedComposition.id) === (renderModalComposition === null || renderModalComposition === void 0 ? void 0 : renderModalComposition.id);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (selectedComposition && needsResolution(selectedComposition)) {\n            const controller = doResolution(selectedComposition, selectedEditorProps);\n            return () => {\n                controller.abort();\n            };\n        }\n    }, [doResolution, selectedComposition, selectedEditorProps]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (renderModalComposition && !isTheSame) {\n            const controller = doResolution(renderModalComposition, renderModalProps);\n            return () => {\n                controller.abort();\n            };\n        }\n    }, [doResolution, isTheSame, renderModalComposition, renderModalProps]);\n    const resolvedConfigsIncludingStaticOnes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const staticComps = compositions.filter((c) => {\n            return c.calculateMetadata === null;\n        });\n        return {\n            ...resolvedConfigs,\n            ...staticComps.reduce((acc, curr) => {\n                var _a;\n                return {\n                    ...acc,\n                    [curr.id]: {\n                        type: 'success',\n                        result: { ...curr, defaultProps: (_a = curr.defaultProps) !== null && _a !== void 0 ? _a : {} },\n                    },\n                };\n            }, {}),\n        };\n    }, [compositions, resolvedConfigs]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, { value: resolvedConfigsIncludingStaticOnes, children: children }));\n};\nconst useResolvedVideoConfig = (preferredCompositionId) => {\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ResolveCompositionContext);\n    const { props: allEditorProps } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorPropsContext);\n    const { compositions, canvasContent, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const currentComposition = (canvasContent === null || canvasContent === void 0 ? void 0 : canvasContent.type) === 'composition' ? canvasContent.compositionId : null;\n    const compositionId = preferredCompositionId !== null && preferredCompositionId !== void 0 ? preferredCompositionId : currentComposition;\n    const composition = compositions.find((c) => c.id === compositionId);\n    const selectedEditorProps = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return composition ? (_a = allEditorProps[composition.id]) !== null && _a !== void 0 ? _a : {} : {};\n    }, [allEditorProps, composition]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a, _b, _c, _d;\n        if (!composition) {\n            return null;\n        }\n        if (currentCompositionMetadata) {\n            return {\n                type: 'success',\n                result: {\n                    ...currentCompositionMetadata,\n                    id: composition.id,\n                    props: currentCompositionMetadata.props,\n                    defaultProps: (_a = composition.defaultProps) !== null && _a !== void 0 ? _a : {},\n                },\n            };\n        }\n        if (!needsResolution(composition)) {\n            return {\n                type: 'success',\n                result: {\n                    width: composition.width,\n                    height: composition.height,\n                    fps: composition.fps,\n                    id: composition.id,\n                    durationInFrames: composition.durationInFrames,\n                    defaultProps: (_b = composition.defaultProps) !== null && _b !== void 0 ? _b : {},\n                    props: {\n                        ...((_c = composition.defaultProps) !== null && _c !== void 0 ? _c : {}),\n                        ...(selectedEditorProps !== null && selectedEditorProps !== void 0 ? selectedEditorProps : {}),\n                        ...(typeof window === 'undefined' ||\n                            getRemotionEnvironment().isPlayer\n                            ? {}\n                            : (_d = getInputProps()) !== null && _d !== void 0 ? _d : {}),\n                    },\n                },\n            };\n        }\n        if (!context[composition.id]) {\n            return null;\n        }\n        return context[composition.id];\n    }, [composition, context, currentCompositionMetadata, selectedEditorProps]);\n};\n\nconst useVideo = () => {\n    var _a;\n    const { canvasContent, compositions, currentCompositionMetadata } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const selected = compositions.find((c) => {\n        return ((canvasContent === null || canvasContent === void 0 ? void 0 : canvasContent.type) === 'composition' &&\n            c.id === canvasContent.compositionId);\n    });\n    const resolved = useResolvedVideoConfig((_a = selected === null || selected === void 0 ? void 0 : selected.id) !== null && _a !== void 0 ? _a : null);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        if (!resolved) {\n            return null;\n        }\n        if (resolved.type === 'error') {\n            return null;\n        }\n        if (resolved.type === 'loading') {\n            return null;\n        }\n        if (!selected) {\n            return null;\n        }\n        return {\n            ...resolved.result,\n            defaultProps: (_a = selected.defaultProps) !== null && _a !== void 0 ? _a : {},\n            id: selected.id,\n            // We override the selected metadata with the metadata that was passed to renderMedia(),\n            // and don't allow it to be changed during render anymore\n            ...(currentCompositionMetadata !== null && currentCompositionMetadata !== void 0 ? currentCompositionMetadata : {}),\n            component: selected.component,\n        };\n    }, [currentCompositionMetadata, resolved, selected]);\n};\n\nconst TimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    frame: {},\n    playing: false,\n    playbackRate: 1,\n    rootId: '',\n    imperativePlaying: {\n        current: false,\n    },\n    setPlaybackRate: () => {\n        throw new Error('default');\n    },\n    audioAndVideoTags: { current: [] },\n});\nconst SetTimelineContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setFrame: () => {\n        throw new Error('default');\n    },\n    setPlaying: () => {\n        throw new Error('default');\n    },\n});\nconst makeKey = (composition) => {\n    return `remotion.time.${composition}`;\n};\nconst persistCurrentFrame = (frame, composition) => {\n    localStorage.setItem(makeKey(composition), String(frame));\n};\nconst getFrameForComposition = (composition) => {\n    var _a, _b;\n    const frame = localStorage.getItem(makeKey(composition));\n    return frame\n        ? Number(frame)\n        : (_b = (typeof window === 'undefined' ? 0 : (_a = window.remotion_initialFrame) !== null && _a !== void 0 ? _a : 0)) !== null && _b !== void 0 ? _b : 0;\n};\nconst useTimelinePosition = () => {\n    var _a, _b;\n    const videoConfig = useVideo();\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    if (!videoConfig) {\n        return typeof window === 'undefined'\n            ? 0\n            : (_a = window.remotion_initialFrame) !== null && _a !== void 0 ? _a : 0;\n    }\n    const unclamped = (_b = state.frame[videoConfig.id]) !== null && _b !== void 0 ? _b : (typeof window !== 'undefined' && window.remotion_isPlayer\n        ? 0\n        : getFrameForComposition(videoConfig.id));\n    return Math.min(videoConfig.durationInFrames - 1, unclamped);\n};\nconst useTimelineSetFrame = () => {\n    const { setFrame } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return setFrame;\n};\nconst usePlayingState = () => {\n    const { playing, imperativePlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const { setPlaying } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetTimelineContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [playing, setPlaying, imperativePlaying], [imperativePlaying, playing, setPlaying]);\n};\n\nvar TimelinePosition = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TimelineContext: TimelineContext,\n    SetTimelineContext: SetTimelineContext,\n    persistCurrentFrame: persistCurrentFrame,\n    getFrameForComposition: getFrameForComposition,\n    useTimelinePosition: useTimelinePosition,\n    useTimelineSetFrame: useTimelineSetFrame,\n    usePlayingState: usePlayingState\n});\n\nconst CanUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(false);\nconst CanUseRemotionHooksProvider = ({ children }) => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, { value: true, children: children }));\n};\n\nconst useUnsafeVideoConfig = () => {\n    var _a;\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const ctxDuration = (_a = context === null || context === void 0 ? void 0 : context.durationInFrames) !== null && _a !== void 0 ? _a : null;\n    const video = useVideo();\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (!video) {\n            return null;\n        }\n        const { id, durationInFrames, fps, height, width, defaultProps, props } = video;\n        return {\n            id,\n            width,\n            height,\n            fps,\n            durationInFrames: ctxDuration !== null && ctxDuration !== void 0 ? ctxDuration : durationInFrames,\n            defaultProps,\n            props,\n        };\n    }, [ctxDuration, video]);\n};\n\n/**\n * /**\n * @description Get some info about the context of the video that you are making.\n * @see [Documentation](https://www.remotion.dev/docs/use-video-config)\n * @returns Returns an object containing `fps`, `width`, `height` and `durationInFrames`, all of type `number`.\n */\nconst useVideoConfig = () => {\n    const videoConfig = useUnsafeVideoConfig();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    const isPlayer = useIsPlayer();\n    if (!videoConfig) {\n        if ((typeof window !== 'undefined' && window.remotion_isPlayer) ||\n            isPlayer) {\n            throw new Error([\n                'No video config found. Likely reasons:',\n                '- You are probably calling useVideoConfig() from outside the component passed to <Player />. See https://www.remotion.dev/docs/player/examples for how to set up the Player correctly.',\n                '- You have multiple versions of Remotion installed which causes the React context to get lost.',\n            ].join('-'));\n        }\n        throw new Error('No video config found. You are probably calling useVideoConfig() from a component which has not been registered as a <Composition />. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions for more information.');\n    }\n    if (!context) {\n        throw new Error('Called useVideoConfig() outside a Remotion composition.');\n    }\n    return videoConfig;\n};\n\nconst SequenceRefForwardingFunction = ({ from = 0, durationInFrames = Infinity, children, name, showInTimeline = true, loopDisplay, ...other }, ref) => {\n    const { layout = 'absolute-fill' } = other;\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { rootId } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const cumulatedFrom = parentSequence\n        ? parentSequence.cumulatedFrom + parentSequence.relativeFrom\n        : 0;\n    const nonce = useNonce();\n    if (layout !== 'absolute-fill' && layout !== 'none') {\n        throw new TypeError(`The layout prop of <Sequence /> expects either \"absolute-fill\" or \"none\", but you passed: ${layout}`);\n    }\n    // @ts-expect-error\n    if (layout === 'none' && typeof other.style !== 'undefined') {\n        throw new TypeError('If layout=\"none\", you may not pass a style.');\n    }\n    if (typeof durationInFrames !== 'number') {\n        throw new TypeError(`You passed to durationInFrames an argument of type ${typeof durationInFrames}, but it must be a number.`);\n    }\n    if (durationInFrames <= 0) {\n        throw new TypeError(`durationInFrames must be positive, but got ${durationInFrames}`);\n    }\n    if (typeof from !== 'number') {\n        throw new TypeError(`You passed to the \"from\" props of your <Sequence> an argument of type ${typeof from}, but it must be a number.`);\n    }\n    if (!Number.isFinite(from)) {\n        throw new TypeError(`The \"from\" prop of a sequence must be finite, but got ${from}.`);\n    }\n    const absoluteFrame = useTimelinePosition();\n    const videoConfig = useVideoConfig();\n    const parentSequenceDuration = parentSequence\n        ? Math.min(parentSequence.durationInFrames - from, durationInFrames)\n        : durationInFrames;\n    const actualDurationInFrames = Math.max(0, Math.min(videoConfig.durationInFrames - from, parentSequenceDuration));\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return {\n            cumulatedFrom,\n            relativeFrom: from,\n            durationInFrames: actualDurationInFrames,\n            parentFrom: (_a = parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.relativeFrom) !== null && _a !== void 0 ? _a : 0,\n            id,\n        };\n    }, [\n        cumulatedFrom,\n        from,\n        actualDurationInFrames,\n        parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.relativeFrom,\n        id,\n    ]);\n    const timelineClipName = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return name !== null && name !== void 0 ? name : getTimelineClipName(children);\n    }, [children, name]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!getRemotionEnvironment().isStudio) {\n            return;\n        }\n        registerSequence({\n            from,\n            duration: actualDurationInFrames,\n            id,\n            displayName: timelineClipName,\n            parent: (_a = parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.id) !== null && _a !== void 0 ? _a : null,\n            type: 'sequence',\n            rootId,\n            showInTimeline,\n            nonce,\n            loopDisplay,\n        });\n        return () => {\n            unregisterSequence(id);\n        };\n    }, [\n        durationInFrames,\n        id,\n        name,\n        registerSequence,\n        timelineClipName,\n        unregisterSequence,\n        parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.id,\n        actualDurationInFrames,\n        rootId,\n        from,\n        showInTimeline,\n        nonce,\n        loopDisplay,\n    ]);\n    // Ceil to support floats\n    // https://github.com/remotion-dev/remotion/issues/2958\n    const endThreshold = Math.ceil(cumulatedFrom + from + durationInFrames - 1);\n    const content = absoluteFrame < cumulatedFrom + from\n        ? null\n        : absoluteFrame > endThreshold\n            ? null\n            : children;\n    const styleIfThere = other.layout === 'none' ? undefined : other.style;\n    const defaultStyle = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            flexDirection: undefined,\n            ...(styleIfThere !== null && styleIfThere !== void 0 ? styleIfThere : {}),\n        };\n    }, [styleIfThere]);\n    if (ref !== null && layout === 'none') {\n        throw new TypeError('It is not supported to pass both a `ref` and `layout=\"none\"` to <Sequence />.');\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, { value: contextValue, children: content === null ? null : other.layout === 'none' ? (content) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, { ref: ref, style: defaultStyle, className: other.className, children: content })) }));\n};\n/**\n * @description A component that time-shifts its children and wraps them in an absolutely positioned <div>.\n * @see [Documentation](https://www.remotion.dev/docs/sequence)\n */\nconst Sequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SequenceRefForwardingFunction);\n\n/**\n * @description Get the current frame of the video. Frames are 0-indexed, meaning the first frame is 0, the last frame is the duration of the composition in frames minus one.\n * @see [Documentation](https://remotion.dev/docs/use-current-frame)\n */\nconst useCurrentFrame = () => {\n    const canUseRemotionHooks = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (!canUseRemotionHooks) {\n        if (typeof window !== 'undefined' && window.remotion_isPlayer) {\n            throw new Error(`useCurrentFrame can only be called inside a component that was passed to <Player>. See: https://www.remotion.dev/docs/player/examples`);\n        }\n        throw new Error(`useCurrentFrame() can only be called inside a component that was registered as a composition. See https://www.remotion.dev/docs/the-fundamentals#defining-compositions`);\n    }\n    const frame = useTimelinePosition();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const contextOffset = context\n        ? context.cumulatedFrom + context.relativeFrom\n        : 0;\n    return frame - contextOffset;\n};\n\n/**\n * @description This component allows you to quickly lay out an animation so it repeats itself.\n * @see [Documentation](https://www.remotion.dev/docs/loop)\n */\nconst Loop = ({ durationInFrames, times = Infinity, children, name, ...props }) => {\n    const currentFrame = useCurrentFrame();\n    const { durationInFrames: compDuration } = useVideoConfig();\n    validateDurationInFrames(durationInFrames, {\n        component: 'of the <Loop /> component',\n        allowFloats: true,\n    });\n    if (typeof times !== 'number') {\n        throw new TypeError(`You passed to \"times\" an argument of type ${typeof times}, but it must be a number.`);\n    }\n    if (times !== Infinity && times % 1 !== 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be an integer, but got ${times}.`);\n    }\n    if (times < 0) {\n        throw new TypeError(`The \"times\" prop of a loop must be at least 0, but got ${times}`);\n    }\n    const maxTimes = Math.ceil(compDuration / durationInFrames);\n    const actualTimes = Math.min(maxTimes, times);\n    const style = props.layout === 'none' ? undefined : props.style;\n    const maxFrame = durationInFrames * (actualTimes - 1);\n    const start = Math.floor(currentFrame / durationInFrames) * durationInFrames;\n    const from = Math.min(start, maxFrame);\n    const loopDisplay = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            numberOfTimes: actualTimes,\n            startOffset: -from,\n            durationInFrames,\n        };\n    }, [actualTimes, durationInFrames, from]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, { durationInFrames: durationInFrames, from: from, name: name, loopDisplay: loopDisplay, layout: props.layout, style: style, children: children }));\n};\n\nconst validateMediaProps = (props, component) => {\n    if (typeof props.volume !== 'number' &&\n        typeof props.volume !== 'function' &&\n        typeof props.volume !== 'undefined') {\n        throw new TypeError(`You have passed a volume of type ${typeof props.volume} to your <${component} /> component. Volume must be a number or a function with the signature '(frame: number) => number' undefined.`);\n    }\n    if (typeof props.volume === 'number' && props.volume < 0) {\n        throw new TypeError(`You have passed a volume below 0 to your <${component} /> component. Volume must be between 0 and 1`);\n    }\n    if (typeof props.playbackRate !== 'number' &&\n        typeof props.playbackRate !== 'undefined') {\n        throw new TypeError(`You have passed a playbackRate of type ${typeof props.playbackRate} to your <${component} /> component. Playback rate must a real number or undefined.`);\n    }\n    if (typeof props.playbackRate === 'number' &&\n        (isNaN(props.playbackRate) ||\n            !Number.isFinite(props.playbackRate) ||\n            props.playbackRate <= 0)) {\n        throw new TypeError(`You have passed a playbackRate of ${props.playbackRate} to your <${component} /> component. Playback rate must be a real number above 0.`);\n    }\n};\n\nconst validateStartFromProps = (startFrom, endAt) => {\n    if (typeof startFrom !== 'undefined') {\n        if (typeof startFrom !== 'number') {\n            throw new TypeError(`type of startFrom prop must be a number, instead got type ${typeof startFrom}.`);\n        }\n        if (isNaN(startFrom) || startFrom === Infinity) {\n            throw new TypeError('startFrom prop can not be NaN or Infinity.');\n        }\n        if (startFrom < 0) {\n            throw new TypeError(`startFrom must be greater than equal to 0 instead got ${startFrom}.`);\n        }\n    }\n    if (typeof endAt !== 'undefined') {\n        if (typeof endAt !== 'number') {\n            throw new TypeError(`type of endAt prop must be a number, instead got type ${typeof endAt}.`);\n        }\n        if (isNaN(endAt)) {\n            throw new TypeError('endAt prop can not be NaN.');\n        }\n        if (endAt <= 0) {\n            throw new TypeError(`endAt must be a positive number, instead got ${endAt}.`);\n        }\n    }\n    if (endAt < startFrom) {\n        throw new TypeError('endAt prop must be greater than startFrom prop.');\n    }\n};\n\nconst durationReducer = (state, action) => {\n    switch (action.type) {\n        case 'got-duration':\n            return {\n                ...state,\n                [getAbsoluteSrc(action.src)]: action.durationInSeconds,\n            };\n        default:\n            return state;\n    }\n};\nconst DurationsContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    durations: {},\n    setDurations: () => {\n        throw new Error('context missing');\n    },\n});\nconst DurationsContextProvider = ({ children }) => {\n    const [durations, setDurations] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)(durationReducer, {});\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            durations,\n            setDurations,\n        };\n    }, [durations]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContext.Provider, { value: value, children: children }));\n};\n\nconst PreloadContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nlet preloads = {};\nlet updaters = [];\nconst setPreloads = (updater) => {\n    preloads = updater(preloads);\n    updaters.forEach((u) => u());\n};\nconst PrefetchProvider = ({ children }) => {\n    const [_preloads, _setPreloads] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => preloads);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const updaterFunction = () => {\n            _setPreloads(preloads);\n        };\n        updaters.push(updaterFunction);\n        return () => {\n            updaters = updaters.filter((u) => u !== updaterFunction);\n        };\n    }, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, { value: _preloads, children: children }));\n};\n\nconst usePreload = (src) => {\n    var _a;\n    const preloads = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(PreloadContext);\n    return (_a = preloads[src]) !== null && _a !== void 0 ? _a : src;\n};\nconst blobToBase64 = function (blob) {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n        reader.onload = function () {\n            const dataUrl = reader.result;\n            resolve(dataUrl);\n        };\n        reader.onerror = (err) => {\n            return reject(err);\n        };\n        reader.readAsDataURL(blob);\n    });\n};\n/**\n * @description When you call the preFetch() function, an asset will be fetched and kept in memory so it is ready when you want to play it in a <Player>.\n * @see [Documentation](https://www.remotion.dev/docs/prefetch)\n */\nconst prefetch = (src, options) => {\n    var _a;\n    const method = (_a = options === null || options === void 0 ? void 0 : options.method) !== null && _a !== void 0 ? _a : 'blob-url';\n    if (getRemotionEnvironment().isRendering) {\n        return {\n            free: () => undefined,\n            waitUntilDone: () => Promise.resolve(src),\n        };\n    }\n    let canceled = false;\n    let objectUrl = null;\n    let resolve = () => undefined;\n    let reject = () => undefined;\n    const waitUntilDone = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    const controller = new AbortController();\n    let canBeAborted = true;\n    fetch(src, {\n        signal: controller.signal,\n    })\n        .then((res) => {\n        canBeAborted = false;\n        if (canceled) {\n            return null;\n        }\n        if (!res.ok) {\n            throw new Error(`HTTP error, status = ${res.status}`);\n        }\n        return res.blob();\n    })\n        .then((buf) => {\n        if (!buf) {\n            return;\n        }\n        if (!buf.type.startsWith('video/') &&\n            !buf.type.startsWith('audio/') &&\n            !(options === null || options === void 0 ? void 0 : options.contentType)) {\n            console.warn(`Called prefetch() on ${src} which returned a \"Content-Type\" of ${buf.type}. Prefetched content should have a proper content type (video/... or audio/...) or a contentType passed the options of prefetch(). Otherwise, prefetching will not work properly in all browsers.`);\n        }\n        const actualBlob = (options === null || options === void 0 ? void 0 : options.contentType)\n            ? new Blob([buf], { type: options.contentType })\n            : buf;\n        if (method === 'base64') {\n            return blobToBase64(actualBlob);\n        }\n        return URL.createObjectURL(actualBlob);\n    })\n        .then((url) => {\n        if (canceled) {\n            return;\n        }\n        objectUrl = url;\n        setPreloads((p) => ({\n            ...p,\n            [src]: objectUrl,\n        }));\n        resolve(objectUrl);\n    })\n        .catch((err) => {\n        reject(err);\n    });\n    return {\n        free: () => {\n            if (objectUrl) {\n                if (method === 'blob-url') {\n                    URL.revokeObjectURL(objectUrl);\n                }\n                setPreloads((p) => {\n                    const copy = { ...p };\n                    delete copy[src];\n                    return copy;\n                });\n            }\n            else {\n                canceled = true;\n                if (canBeAborted) {\n                    try {\n                        controller.abort();\n                    }\n                    catch (e) { }\n                }\n            }\n        },\n        waitUntilDone: () => {\n            return waitUntilDone;\n        },\n    };\n};\n\n/* eslint-disable no-bitwise */\nfunction mulberry32(a) {\n    let t = a + 0x6d2b79f5;\n    t = Math.imul(t ^ (t >>> 15), t | 1);\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61);\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;\n}\nfunction hashCode(str) {\n    let i = 0;\n    let chr = 0;\n    let hash = 0;\n    for (i = 0; i < str.length; i++) {\n        chr = str.charCodeAt(i);\n        hash = (hash << 5) - hash + chr;\n        hash |= 0; // Convert to 32bit integer\n    }\n    return hash;\n}\n/**\n * @description A deterministic pseudo-random number generator. Pass in the same seed and get the same pseudorandom number.\n * @see [Documentation](https://remotion.dev/docs/random)\n */\nconst random = (seed, dummy) => {\n    if (dummy !== undefined) {\n        throw new TypeError('random() takes only one argument');\n    }\n    if (seed === null) {\n        return Math.random();\n    }\n    if (typeof seed === 'string') {\n        return mulberry32(hashCode(seed));\n    }\n    if (typeof seed === 'number') {\n        return mulberry32(seed * 10000000000);\n    }\n    throw new Error('random() argument must be a number or a string');\n};\n\nconst useMediaStartsAt = () => {\n    var _a;\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const startsAt = Math.min(0, (_a = parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.relativeFrom) !== null && _a !== void 0 ? _a : 0);\n    return startsAt;\n};\n/**\n * When passing a function as the prop for `volume`,\n * we calculate the way more intuitive value for currentFrame\n */\nconst useFrameForVolumeProp = () => {\n    const frame = useCurrentFrame();\n    const startsAt = useMediaStartsAt();\n    return frame + startsAt;\n};\n\nconst getAssetDisplayName = (filename) => {\n    if (/data:|blob:/.test(filename.substring(0, 5))) {\n        return 'Data URL';\n    }\n    const splitted = filename\n        .split('/')\n        .map((s) => s.split('\\\\'))\n        .flat(1);\n    return splitted[splitted.length - 1];\n};\n\nconst playAndHandleNotAllowedError = (mediaRef, mediaType) => {\n    const { current } = mediaRef;\n    if (!current) {\n        return;\n    }\n    const prom = current.play();\n    if (prom.catch) {\n        prom.catch((err) => {\n            if (!current) {\n                return;\n            }\n            // Pause was called after play in Chrome\n            if (err.message.includes('request was interrupted by a call to pause')) {\n                return;\n            }\n            // Pause was called after play in Safari\n            if (err.message.includes('The operation was aborted.')) {\n                return;\n            }\n            // Pause was called after play in Firefox\n            if (err.message.includes('The fetching process for the media resource was aborted by the user agent')) {\n                return;\n            }\n            // Got replaced by a different audio source in Chromium\n            if (err.message.includes('request was interrupted by a new load request')) {\n                return;\n            }\n            // Audio tag got unmounted\n            if (err.message.includes('because the media was removed from the document')) {\n                return;\n            }\n            console.log(`Could not play ${mediaType} due to following error: `, err);\n            if (!current.muted) {\n                console.log(`The video will be muted and we'll retry playing it.`, err);\n                current.muted = true;\n                current.play();\n            }\n        });\n    }\n};\n\nconst evaluateVolume = ({ frame, volume, mediaVolume = 1, allowAmplificationDuringRender, }) => {\n    const maxVolume = allowAmplificationDuringRender ? Infinity : 1;\n    if (typeof volume === 'number') {\n        return Math.min(maxVolume, volume * mediaVolume);\n    }\n    if (typeof volume === 'undefined') {\n        return Number(mediaVolume);\n    }\n    const evaluated = volume(frame) * mediaVolume;\n    if (typeof evaluated !== 'number') {\n        throw new TypeError(`You passed in a a function to the volume prop but it did not return a number but a value of type ${typeof evaluated} for frame ${frame}`);\n    }\n    if (Number.isNaN(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned NaN for frame ${frame}.`);\n    }\n    if (!Number.isFinite(evaluated)) {\n        throw new TypeError(`You passed in a function to the volume prop but it returned a non-finite number for frame ${frame}.`);\n    }\n    return Math.max(0, Math.min(maxVolume, evaluated));\n};\n\nconst didWarn = {};\nconst warnOnce = (message) => {\n    if (didWarn[message]) {\n        return;\n    }\n    console.warn(message);\n    didWarn[message] = true;\n};\nconst useMediaInTimeline = ({ volume, mediaVolume, mediaRef, src, mediaType, playbackRate, }) => {\n    const videoConfig = useVideoConfig();\n    const { rootId, audioAndVideoTags } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const actualFrom = parentSequence\n        ? parentSequence.relativeFrom + parentSequence.cumulatedFrom\n        : 0;\n    const [playing] = usePlayingState();\n    const startsAt = useMediaStartsAt();\n    const { registerSequence, unregisterSequence } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceManager);\n    const [id] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(Math.random()));\n    const [initialVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => volume);\n    const nonce = useNonce();\n    const duration = parentSequence\n        ? Math.min(parentSequence.durationInFrames, videoConfig.durationInFrames)\n        : videoConfig.durationInFrames;\n    const doesVolumeChange = typeof volume === 'function';\n    const volumes = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if (typeof volume === 'number') {\n            return volume;\n        }\n        return new Array(Math.floor(Math.max(0, duration + startsAt)))\n            .fill(true)\n            .map((_, i) => {\n            return evaluateVolume({\n                frame: i + startsAt,\n                volume,\n                mediaVolume,\n                allowAmplificationDuringRender: false,\n            });\n        })\n            .join(',');\n    }, [duration, startsAt, volume, mediaVolume]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (typeof volume === 'number' && volume !== initialVolume) {\n            warnOnce(`Remotion: The ${mediaType} with src ${src} has changed it's volume. Prefer the callback syntax for setting volume to get better timeline display: https://www.remotion.dev/docs/using-audio/#controlling-volume`);\n        }\n    }, [initialVolume, mediaType, src, volume]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!mediaRef.current) {\n            return;\n        }\n        if (!src) {\n            throw new Error('No src passed');\n        }\n        if (!getRemotionEnvironment().isStudio && \"development\" !== 'test') {\n            return;\n        }\n        registerSequence({\n            type: mediaType,\n            src,\n            id,\n            duration,\n            from: 0,\n            parent: (_a = parentSequence === null || parentSequence === void 0 ? void 0 : parentSequence.id) !== null && _a !== void 0 ? _a : null,\n            displayName: getAssetDisplayName(src),\n            rootId,\n            volume: volumes,\n            showInTimeline: true,\n            nonce,\n            startMediaFrom: 0 - startsAt,\n            doesVolumeChange,\n            loopDisplay: undefined,\n            playbackRate,\n        });\n        return () => {\n            unregisterSequence(id);\n        };\n    }, [\n        actualFrom,\n        duration,\n        id,\n        parentSequence,\n        src,\n        registerSequence,\n        rootId,\n        unregisterSequence,\n        videoConfig,\n        volumes,\n        doesVolumeChange,\n        nonce,\n        mediaRef,\n        mediaType,\n        startsAt,\n        playbackRate,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const tag = {\n            id,\n            play: () => {\n                if (!playing) {\n                    // Don't play if for example in a <Freeze> state.\n                    return;\n                }\n                return playAndHandleNotAllowedError(mediaRef, mediaType);\n            },\n        };\n        audioAndVideoTags.current.push(tag);\n        return () => {\n            audioAndVideoTags.current = audioAndVideoTags.current.filter((a) => a.id !== id);\n        };\n    }, [audioAndVideoTags, id, mediaRef, mediaType, playing]);\n};\n\n// Taken from https://github.com/facebook/react-native/blob/0b9ea60b4fee8cacc36e7160e31b91fc114dbc0d/Libraries/Animated/src/nodes/AnimatedInterpolation.js\nfunction interpolateFunction(input, inputRange, outputRange, options) {\n    const { extrapolateLeft, extrapolateRight, easing } = options;\n    let result = input;\n    const [inputMin, inputMax] = inputRange;\n    const [outputMin, outputMax] = outputRange;\n    if (result < inputMin) {\n        if (extrapolateLeft === 'identity') {\n            return result;\n        }\n        if (extrapolateLeft === 'clamp') {\n            result = inputMin;\n        }\n    }\n    if (result > inputMax) {\n        if (extrapolateRight === 'identity') {\n            return result;\n        }\n        if (extrapolateRight === 'clamp') {\n            result = inputMax;\n        }\n    }\n    if (outputMin === outputMax) {\n        return outputMin;\n    }\n    // Input Range\n    result = (result - inputMin) / (inputMax - inputMin);\n    // Easing\n    result = easing(result);\n    // Output Range\n    result = result * (outputMax - outputMin) + outputMin;\n    return result;\n}\nfunction findRange(input, inputRange) {\n    let i;\n    for (i = 1; i < inputRange.length - 1; ++i) {\n        if (inputRange[i] >= input) {\n            break;\n        }\n    }\n    return i - 1;\n}\nfunction checkValidInputRange(arr) {\n    for (let i = 1; i < arr.length; ++i) {\n        if (!(arr[i] > arr[i - 1])) {\n            throw new Error(`inputRange must be strictly monotonically non-decreasing but got [${arr.join(',')}]`);\n        }\n    }\n}\nfunction checkInfiniteRange(name, arr) {\n    if (arr.length < 2) {\n        throw new Error(name + ' must have at least 2 elements');\n    }\n    for (const index in arr) {\n        if (typeof arr[index] !== 'number') {\n            throw new Error(`${name} must contain only numbers`);\n        }\n        if (arr[index] === -Infinity || arr[index] === Infinity) {\n            throw new Error(`${name} must contain only finite numbers, but got [${arr.join(',')}]`);\n        }\n    }\n}\n/**\n * Map a value from an input range to an output range.\n * @link https://www.remotion.dev/docs/interpolate\n * @param {!number} input value to interpolate\n * @param {!number[]} inputRange range of values that you expect the input to assume.\n * @param {!number[]} outputRange range of output values that you want the input to map to.\n * @param {?object} options\n * @param {?Function} options.easing easing function which allows you to customize the input, for example to apply a certain easing function. By default, the input is left unmodified, resulting in a pure linear interpolation {@link https://www.remotion.dev/docs/easing}\n * @param {string=} [options.extrapolateLeft=\"extend\"] What should happen if the input value is outside left the input range, default: \"extend\" {@link https://www.remotion.dev/docs/interpolate#extrapolateleft}\n * @param {string=} [options.extrapolateRight=\"extend\"] Same as extrapolateLeft, except for values outside right the input range {@link https://www.remotion.dev/docs/interpolate#extrapolateright}\n */\nfunction interpolate(input, inputRange, outputRange, options) {\n    var _a;\n    if (typeof input === 'undefined') {\n        throw new Error('input can not be undefined');\n    }\n    if (typeof inputRange === 'undefined') {\n        throw new Error('inputRange can not be undefined');\n    }\n    if (typeof outputRange === 'undefined') {\n        throw new Error('outputRange can not be undefined');\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new Error('inputRange (' +\n            inputRange.length +\n            ') and outputRange (' +\n            outputRange.length +\n            ') must have the same length');\n    }\n    checkInfiniteRange('inputRange', inputRange);\n    checkInfiniteRange('outputRange', outputRange);\n    checkValidInputRange(inputRange);\n    const easing = (_a = options === null || options === void 0 ? void 0 : options.easing) !== null && _a !== void 0 ? _a : ((num) => num);\n    let extrapolateLeft = 'extend';\n    if ((options === null || options === void 0 ? void 0 : options.extrapolateLeft) !== undefined) {\n        extrapolateLeft = options.extrapolateLeft;\n    }\n    let extrapolateRight = 'extend';\n    if ((options === null || options === void 0 ? void 0 : options.extrapolateRight) !== undefined) {\n        extrapolateRight = options.extrapolateRight;\n    }\n    if (typeof input !== 'number') {\n        throw new TypeError('Cannot interpolate an input which is not a number');\n    }\n    const range = findRange(input, inputRange);\n    return interpolateFunction(input, [inputRange[range], inputRange[range + 1]], [outputRange[range], outputRange[range + 1]], {\n        easing,\n        extrapolateLeft,\n        extrapolateRight,\n    });\n}\n\n// Calculate the `.currentTime` of a video or audio element\nconst getExpectedMediaFrameUncorrected = ({ frame, playbackRate, startFrom, }) => {\n    return interpolate(frame, [-1, startFrom, startFrom + 1], [-1, startFrom, startFrom + playbackRate]);\n};\nconst getMediaTime = ({ fps, frame, src, playbackRate, startFrom, mediaType, }) => {\n    const expectedFrame = getExpectedMediaFrameUncorrected({\n        frame,\n        playbackRate,\n        startFrom,\n    });\n    const isChrome = typeof window !== 'undefined' &&\n        window.navigator.userAgent.match(/Chrome\\/([0-9]+)/);\n    if (isChrome &&\n        Number(isChrome[1]) < 112 &&\n        mediaType === 'video' &&\n        src.endsWith('.mp4')) {\n        // In Chrome, for MP4s, if 30fps, the first frame is still displayed at 0.033333\n        // even though after that it increases by 0.033333333 each.\n        // So frame = 0 in Remotion is like frame = 1 for the browser\n        return (expectedFrame + 1) / fps;\n    }\n    // For WebM videos, we need to add a little bit of shift to get the right frame.\n    const msPerFrame = 1000 / fps;\n    const msShift = msPerFrame / 2;\n    return (expectedFrame * msPerFrame + msShift) / 1000;\n};\n\nconst toSeconds = (time, fps) => {\n    return Math.round((time / fps) * 100) / 100;\n};\n// https://github.com/remotion-dev/remotion/issues/1655\nconst isIOSSafariCase = (actualSrc) => {\n    return typeof window === 'undefined'\n        ? false\n        : /iP(ad|od|hone)/i.test(window.navigator.userAgent) &&\n            Boolean(navigator.userAgent.match(/Version\\/[\\d.]+.*Safari/)) &&\n            actualSrc.startsWith('blob:');\n};\nconst appendVideoFragment = ({ actualSrc, actualFrom, duration, fps, }) => {\n    var _a;\n    if (isIOSSafariCase(actualSrc)) {\n        return actualSrc;\n    }\n    if (actualSrc.startsWith('data:')) {\n        return actualSrc;\n    }\n    const existingHash = Boolean(new URL(actualSrc, (_a = (typeof window === 'undefined' ? null : window.location.href)) !== null && _a !== void 0 ? _a : 'http://localhost:3000').hash);\n    if (existingHash) {\n        return actualSrc;\n    }\n    if (!Number.isFinite(actualFrom)) {\n        return actualSrc;\n    }\n    actualSrc += `#t=${toSeconds(-actualFrom, fps)}`;\n    if (!Number.isFinite(duration)) {\n        return actualSrc;\n    }\n    actualSrc += `,${toSeconds(duration, fps)}`;\n    return actualSrc;\n};\nconst isSubsetOfDuration = (prevStartFrom, newStartFrom, prevDuration, newDuration) => {\n    return (prevStartFrom <= newStartFrom &&\n        prevStartFrom + prevDuration >= newStartFrom + newDuration);\n};\nconst useAppendVideoFragment = ({ actualSrc: initialActualSrc, actualFrom: initialActualFrom, duration: initialDuration, fps, }) => {\n    const actualFromRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualFrom);\n    const actualDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialDuration);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(initialActualSrc);\n    if (!isSubsetOfDuration || initialActualSrc !== actualSrc.current) {\n        actualFromRef.current = initialActualFrom;\n        actualDuration.current = initialDuration;\n        actualSrc.current = initialActualSrc;\n    }\n    const appended = appendVideoFragment({\n        actualSrc: actualSrc.current,\n        actualFrom: actualFromRef.current,\n        duration: actualDuration.current,\n        fps,\n    });\n    return appended;\n};\nconst isIosSafari = () => {\n    return typeof window === 'undefined'\n        ? false\n        : /iP(ad|od|hone)/i.test(window.navigator.userAgent) &&\n            Boolean(navigator.userAgent.match(/Version\\/[\\d.]+.*Safari/));\n};\n\nconst alreadyWarned = {};\nconst warnAboutNonSeekableMedia = (ref, type) => {\n    // Media is not loaded yet, but this does not yet mean something is wrong with the media\n    if (ref === null) {\n        return;\n    }\n    if (ref.seekable.length === 0) {\n        return;\n    }\n    if (ref.seekable.length > 1) {\n        return;\n    }\n    if (alreadyWarned[ref.src]) {\n        return;\n    }\n    const range = { start: ref.seekable.start(0), end: ref.seekable.end(0) };\n    if (range.start === 0 && range.end === 0) {\n        const msg = `The media ${ref.src} cannot be seeked. This could be one of two reasons: 1) The media resource was replaced while the video is playing but it was not loaded yet. 2) The media does not support seeking. Please see https://remotion.dev/docs/non-seekable-media for assistance.`;\n        if (type === 'console-error') {\n            console.error(msg);\n        }\n        else if (type === 'console-warning') {\n            console.warn(`The media ${ref.src} does not support seeking. The video will render fine, but may not play correctly in the Remotion Studio and in the <Player>. See https://remotion.dev/docs/non-seekable-media for an explanation.`);\n        }\n        else {\n            throw new Error(msg);\n        }\n        alreadyWarned[ref.src] = true;\n    }\n};\n\nconst DEFAULT_ACCEPTABLE_TIMESHIFT = 0.45;\nconst seek = (mediaRef, time) => {\n    if (!mediaRef.current) {\n        return;\n    }\n    // iOS seeking does not support multiple decimals\n    if (isIosSafari()) {\n        mediaRef.current.currentTime = Number(time.toFixed(1));\n        return;\n    }\n    mediaRef.current.currentTime = time;\n};\nconst useMediaPlayback = ({ mediaRef, src, mediaType, playbackRate: localPlaybackRate, onlyWarnForMediaSeekingError, acceptableTimeshift, }) => {\n    const { playbackRate: globalPlaybackRate } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const frame = useCurrentFrame();\n    const absoluteFrame = useTimelinePosition();\n    const [playing] = usePlayingState();\n    const { fps } = useVideoConfig();\n    const mediaStartsAt = useMediaStartsAt();\n    const playbackRate = localPlaybackRate * globalPlaybackRate;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!playing) {\n            (_a = mediaRef.current) === null || _a === void 0 ? void 0 : _a.pause();\n        }\n    }, [mediaRef, mediaType, playing]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const tagName = mediaType === 'audio' ? '<Audio>' : '<Video>';\n        if (!mediaRef.current) {\n            throw new Error(`No ${mediaType} ref found`);\n        }\n        if (!src) {\n            throw new Error(`No 'src' attribute was passed to the ${tagName} element.`);\n        }\n        const playbackRateToSet = Math.max(0, playbackRate);\n        if (mediaRef.current.playbackRate !== playbackRateToSet) {\n            mediaRef.current.playbackRate = playbackRateToSet;\n        }\n        const desiredUnclampedTime = getMediaTime({\n            fps,\n            frame,\n            src,\n            playbackRate: localPlaybackRate,\n            startFrom: -mediaStartsAt,\n            mediaType,\n        });\n        const { duration } = mediaRef.current;\n        const shouldBeTime = !Number.isNaN(duration) && Number.isFinite(duration)\n            ? Math.min(duration, desiredUnclampedTime)\n            : desiredUnclampedTime;\n        const isTime = mediaRef.current.currentTime;\n        const timeShift = Math.abs(shouldBeTime - isTime);\n        if (timeShift > acceptableTimeshift) {\n            // If scrubbing around, adjust timing\n            // or if time shift is bigger than 0.45sec\n            seek(mediaRef, shouldBeTime);\n            if (!onlyWarnForMediaSeekingError) {\n                warnAboutNonSeekableMedia(mediaRef.current, onlyWarnForMediaSeekingError ? 'console-warning' : 'console-error');\n            }\n            return;\n        }\n        // Only perform a seek if the time is not already the same.\n        // Chrome rounds to 6 digits, so 0.033333333 -> 0.033333,\n        // therefore a threshold is allowed.\n        // Refer to the https://github.com/remotion-dev/video-buffering-example\n        // which is fixed by only seeking conditionally.\n        const makesSenseToSeek = Math.abs(mediaRef.current.currentTime - shouldBeTime) > 0.00001;\n        if (!playing || absoluteFrame === 0) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n            }\n        }\n        if (mediaRef.current.paused && !mediaRef.current.ended && playing) {\n            if (makesSenseToSeek) {\n                seek(mediaRef, shouldBeTime);\n            }\n            playAndHandleNotAllowedError(mediaRef, mediaType);\n        }\n    }, [\n        absoluteFrame,\n        fps,\n        playbackRate,\n        frame,\n        mediaRef,\n        mediaType,\n        playing,\n        src,\n        mediaStartsAt,\n        localPlaybackRate,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift,\n    ]);\n};\n\n// Returns the real volume of the audio or video while playing,\n// no matter what the supposed volume should be\nconst useMediaTagVolume = (mediaRef) => {\n    const [actualVolume, setActualVolume] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        const onChange = () => {\n            setActualVolume(ref.volume);\n        };\n        ref.addEventListener('volumechange', onChange);\n        return () => ref.removeEventListener('volumechange', onChange);\n    }, [mediaRef]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const ref = mediaRef.current;\n        if (!ref) {\n            return;\n        }\n        if (ref.volume !== actualVolume) {\n            setActualVolume(ref.volume);\n        }\n    }, [actualVolume, mediaRef]);\n    return actualVolume;\n};\n\nconst FLOATING_POINT_ERROR_THRESHOLD = 0.00001;\nconst isApproximatelyTheSame = (num1, num2) => {\n    return Math.abs(num1 - num2) < FLOATING_POINT_ERROR_THRESHOLD;\n};\n\nconst useSyncVolumeWithMediaTag = ({ volumePropFrame, actualVolume, volume, mediaVolume, mediaRef, }) => {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const userPreferredVolume = evaluateVolume({\n            frame: volumePropFrame,\n            volume,\n            mediaVolume,\n            allowAmplificationDuringRender: false,\n        });\n        if (!isApproximatelyTheSame(userPreferredVolume, actualVolume) &&\n            mediaRef.current) {\n            mediaRef.current.volume = userPreferredVolume;\n        }\n    }, [actualVolume, volumePropFrame, mediaRef, volume, mediaVolume]);\n};\n\nconst MediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    mediaMuted: false,\n    mediaVolume: 1,\n});\nconst SetMediaVolumeContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    setMediaMuted: () => {\n        throw new Error('default');\n    },\n    setMediaVolume: () => {\n        throw new Error('default');\n    },\n});\nconst useMediaVolumeState = () => {\n    const { mediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaVolume } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return [mediaVolume, setMediaVolume];\n    }, [mediaVolume, setMediaVolume]);\n};\nconst useMediaMutedState = () => {\n    const { mediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(MediaVolumeContext);\n    const { setMediaMuted } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SetMediaVolumeContext);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return [mediaMuted, setMediaMuted];\n    }, [mediaMuted, setMediaMuted]);\n};\n\nconst EMPTY_AUDIO = 'data:audio/mp3;base64,/+MYxAAJcAV8AAgAABn//////+/gQ5BAMA+D4Pg+BAQBAEAwD4Pg+D4EBAEAQDAPg++hYBH///hUFQVBUFREDQNHmf///////+MYxBUGkAGIMAAAAP/29Xt6lUxBTUUzLjEwMFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV/+MYxDUAAANIAAAAAFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV';\nconst compareProps = (obj1, obj2) => {\n    const keysA = Object.keys(obj1).sort();\n    const keysB = Object.keys(obj2).sort();\n    if (keysA.length !== keysB.length) {\n        return false;\n    }\n    for (let i = 0; i < keysA.length; i++) {\n        // Not the same keys\n        if (keysA[i] !== keysB[i]) {\n            return false;\n        }\n        // Not the same values\n        if (obj1[keysA[i]] !== obj2[keysB[i]]) {\n            return false;\n        }\n    }\n    return true;\n};\nconst didPropChange = (key, newProp, prevProp) => {\n    // /music.mp3 and http://localhost:3000/music.mp3 are the same\n    if (key === 'src' &&\n        !prevProp.startsWith('data:') &&\n        !newProp.startsWith('data:')) {\n        return (new URL(prevProp, window.location.origin).toString() !==\n            new URL(newProp, window.location.origin).toString());\n    }\n    if (prevProp === newProp) {\n        return false;\n    }\n    return true;\n};\nconst SharedAudioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nconst SharedAudioContextProvider = ({ children, numberOfAudioTags, component }) => {\n    const audios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    const [initialNumberOfAudioTags] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(numberOfAudioTags);\n    if (numberOfAudioTags !== initialNumberOfAudioTags) {\n        throw new Error('The number of shared audio tags has changed dynamically. Once you have set this property, you cannot change it afterwards.');\n    }\n    const refs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return new Array(numberOfAudioTags).fill(true).map(() => {\n            return { id: Math.random(), ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)() };\n        });\n    }, [numberOfAudioTags]);\n    const takenAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(new Array(numberOfAudioTags).fill(false));\n    const rerenderAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        refs.forEach(({ ref, id }) => {\n            var _a;\n            const data = (_a = audios.current) === null || _a === void 0 ? void 0 : _a.find((a) => a.id === id);\n            const { current } = ref;\n            if (!current) {\n                // Whole player has been unmounted, the refs don't exist anymore.\n                // It is not an error anymore though\n                return;\n            }\n            if (data === undefined) {\n                current.src = EMPTY_AUDIO;\n                return;\n            }\n            if (!data) {\n                throw new TypeError('Expected audio data to be there');\n            }\n            Object.keys(data.props).forEach((key) => {\n                // @ts-expect-error\n                if (didPropChange(key, data.props[key], current[key])) {\n                    // @ts-expect-error\n                    current[key] = data.props[key];\n                }\n            });\n        });\n    }, [refs]);\n    const registerAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((aud, audioId) => {\n        var _a, _b;\n        const found = (_a = audios.current) === null || _a === void 0 ? void 0 : _a.find((a) => a.audioId === audioId);\n        if (found) {\n            return found;\n        }\n        const firstFreeAudio = takenAudios.current.findIndex((a) => a === false);\n        if (firstFreeAudio === -1) {\n            throw new Error(`Tried to simultaneously mount ${numberOfAudioTags + 1} <Audio /> tags at the same time. With the current settings, the maximum amount of <Audio /> tags is limited to ${numberOfAudioTags} at the same time. Remotion pre-mounts silent audio tags to help avoid browser autoplay restrictions. See https://remotion.dev/docs/player/autoplay#use-the-numberofsharedaudiotags-property for more information on how to increase this limit.`);\n        }\n        const { id, ref } = refs[firstFreeAudio];\n        const cloned = [...takenAudios.current];\n        cloned[firstFreeAudio] = id;\n        takenAudios.current = cloned;\n        const newElem = {\n            props: aud,\n            id,\n            el: ref,\n            audioId,\n        };\n        (_b = audios.current) === null || _b === void 0 ? void 0 : _b.push(newElem);\n        rerenderAudios();\n        return newElem;\n    }, [numberOfAudioTags, refs, rerenderAudios]);\n    const unregisterAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        var _a;\n        const cloned = [...takenAudios.current];\n        const index = refs.findIndex((r) => r.id === id);\n        if (index === -1) {\n            throw new TypeError('Error occured in ');\n        }\n        cloned[index] = false;\n        takenAudios.current = cloned;\n        audios.current = (_a = audios.current) === null || _a === void 0 ? void 0 : _a.filter((a) => a.id !== id);\n        rerenderAudios();\n    }, [refs, rerenderAudios]);\n    const updateAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(({ aud, audioId, id, }) => {\n        var _a;\n        let changed = false;\n        audios.current = (_a = audios.current) === null || _a === void 0 ? void 0 : _a.map((prevA) => {\n            if (prevA.id === id) {\n                const isTheSame = compareProps(aud, prevA.props);\n                if (isTheSame) {\n                    return prevA;\n                }\n                changed = true;\n                return {\n                    ...prevA,\n                    props: aud,\n                    audioId,\n                };\n            }\n            return prevA;\n        });\n        if (changed) {\n            rerenderAudios();\n        }\n    }, [rerenderAudios]);\n    const playAllAudios = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        refs.forEach((ref) => {\n            var _a;\n            (_a = ref.ref.current) === null || _a === void 0 ? void 0 : _a.play();\n        });\n    }, [refs]);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            registerAudio,\n            unregisterAudio,\n            updateAudio,\n            playAllAudios,\n            numberOfAudioTags,\n        };\n    }, [\n        numberOfAudioTags,\n        playAllAudios,\n        registerAudio,\n        unregisterAudio,\n        updateAudio,\n    ]);\n    // Fixing a bug: In React, if a component is unmounted using useInsertionEffect, then\n    // the cleanup function does sometimes not work properly. That is why when we\n    // are changing the composition, we reset the audio state.\n    // TODO: Possibly this does not save the problem completely, since the\n    // if an audio tag that is inside a sequence will also not be removed\n    // from the shared audios.\n    const resetAudio = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        takenAudios.current = new Array(numberOfAudioTags).fill(false);\n        audios.current = [];\n        rerenderAudios();\n    }, [numberOfAudioTags, rerenderAudios]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n            resetAudio();\n        };\n    }, [component, resetAudio]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(SharedAudioContext.Provider, { value: value, children: [refs.map(({ id, ref }) => {\n                return (\n                // Without preload=\"metadata\", iOS will seek the time internally\n                // but not actually with sound. Adding `preload=\"metadata\"` helps here.\n                // https://discord.com/channels/809501355504959528/817306414069710848/1130519583367888906\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", { ref: ref, preload: \"metadata\", src: EMPTY_AUDIO }, id));\n            }), children] }));\n};\nconst useSharedAudio = (aud, audioId) => {\n    var _a;\n    const ctx = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    /**\n     * We work around this in React 18 so an audio tag will only register itself once\n     */\n    const [elem] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n        if (ctx && ctx.numberOfAudioTags > 0) {\n            return ctx.registerAudio(aud, audioId);\n        }\n        return {\n            el: react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n            id: Math.random(),\n            props: aud,\n            audioId,\n        };\n    });\n    /**\n     * Effects in React 18 fire twice, and we are looking for a way to only fire it once.\n     * - useInsertionEffect only fires once. If it's available we are in React 18.\n     * - useLayoutEffect only fires once in React 17.\n     *\n     * Need to import it from React to fix React 17 ESM support.\n     */\n    const effectToUse = (_a = react__WEBPACK_IMPORTED_MODULE_0__.useInsertionEffect) !== null && _a !== void 0 ? _a : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n    if (typeof document !== 'undefined') {\n        effectToUse(() => {\n            if (ctx && ctx.numberOfAudioTags > 0) {\n                ctx.updateAudio({ id: elem.id, aud, audioId });\n            }\n        }, [aud, ctx, elem.id, audioId]);\n        effectToUse(() => {\n            return () => {\n                if (ctx && ctx.numberOfAudioTags > 0) {\n                    ctx.unregisterAudio(elem.id);\n                }\n            };\n        }, [ctx, elem.id]);\n    }\n    return elem;\n};\n\nconst AudioForDevelopmentForwardRefFunction = (props, ref) => {\n    const [initialShouldPreMountAudioElements] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(props.shouldPreMountAudioTags);\n    if (props.shouldPreMountAudioTags !== initialShouldPreMountAudioElements) {\n        throw new Error('Cannot change the behavior for pre-mounting audio tags dynamically.');\n    }\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    const volumePropFrame = useFrameForVolumeProp();\n    const { volume, muted, playbackRate, shouldPreMountAudioTags, src, onDuration, acceptableTimeShiftInSeconds, _remotionInternalNeedsDurationCalculation, allowAmplificationDuringRender, ...nativeProps } = props;\n    if (!src) {\n        throw new TypeError(\"No 'src' was passed to <Audio>.\");\n    }\n    const preloadedSrc = usePreload(src);\n    const propsToPass = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            muted: muted || mediaMuted,\n            src: preloadedSrc,\n            ...nativeProps,\n        };\n    }, [mediaMuted, muted, nativeProps, preloadedSrc]);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    // Generate a string that's as unique as possible for this asset\n    // but at the same time deterministic. We use it to combat strict mode issues.\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `audio-${random(src !== null && src !== void 0 ? src : '')}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames}-muted:${props.muted}-loop:${props.loop}`, [\n        src,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames,\n        props.muted,\n        props.loop,\n    ]);\n    const audioRef = useSharedAudio(propsToPass, id).el;\n    const actualVolume = useMediaTagVolume(audioRef);\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n    });\n    useMediaInTimeline({\n        volume,\n        mediaVolume,\n        mediaRef: audioRef,\n        src,\n        mediaType: 'audio',\n        playbackRate: playbackRate !== null && playbackRate !== void 0 ? playbackRate : 1,\n    });\n    useMediaPlayback({\n        mediaRef: audioRef,\n        src,\n        mediaType: 'audio',\n        playbackRate: playbackRate !== null && playbackRate !== void 0 ? playbackRate : 1,\n        onlyWarnForMediaSeekingError: false,\n        acceptableTimeshift: acceptableTimeShiftInSeconds !== null && acceptableTimeShiftInSeconds !== void 0 ? acceptableTimeShiftInSeconds : DEFAULT_ACCEPTABLE_TIMESHIFT,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        return audioRef.current;\n    }, [audioRef]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        const { current } = audioRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            (_a = currentOnDurationCallback.current) === null || _a === void 0 ? void 0 : _a.call(currentOnDurationCallback, current.src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = () => {\n            var _a;\n            (_a = currentOnDurationCallback.current) === null || _a === void 0 ? void 0 : _a.call(currentOnDurationCallback, current.src, current.duration);\n        };\n        current.addEventListener('loadedmetadata', onLoadedMetadata);\n        return () => {\n            current.removeEventListener('loadedmetadata', onLoadedMetadata);\n        };\n    }, [audioRef, src]);\n    if (initialShouldPreMountAudioElements) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", { ref: audioRef, preload: \"metadata\", ...propsToPass });\n};\nconst AudioForDevelopment = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForDevelopmentForwardRefFunction);\n\nif (typeof window !== 'undefined') {\n    window.remotion_renderReady = false;\n}\nlet handles = [];\nif (typeof window !== 'undefined') {\n    window.remotion_delayRenderTimeouts = {};\n}\nconst DELAY_RENDER_CALLSTACK_TOKEN = 'The delayRender was called:';\nconst defaultTimeout = 30000;\n/**\n * @description Call this function to tell Remotion to wait before capturing this frame until data has loaded. Use continueRender() to unblock the render.\n * @param label _optional_ A label to identify the call in case it does time out.\n * @returns {number} An identifier to be passed to continueRender().\n * @see [Documentation](https://www.remotion.dev/docs/delay-render)\n */\nconst delayRender = (label) => {\n    var _a, _b, _c;\n    if (typeof label !== 'string' && typeof label !== 'undefined') {\n        throw new Error('The label parameter of delayRender() must be a string or undefined, got: ' +\n            JSON.stringify(label));\n    }\n    const handle = Math.random();\n    handles.push(handle);\n    const called = (_b = (_a = Error().stack) === null || _a === void 0 ? void 0 : _a.replace(/^Error/g, '')) !== null && _b !== void 0 ? _b : '';\n    if (getRemotionEnvironment().isRendering) {\n        const timeoutToUse = typeof window === 'undefined'\n            ? defaultTimeout\n            : ((_c = window.remotion_puppeteerTimeout) !== null && _c !== void 0 ? _c : defaultTimeout) - 2000;\n        if (typeof window !== 'undefined') {\n            window.remotion_delayRenderTimeouts[handle] = {\n                label: label !== null && label !== void 0 ? label : null,\n                timeout: setTimeout(() => {\n                    const message = [\n                        `A delayRender()`,\n                        label ? `\"${label}\"` : null,\n                        `was called but not cleared after ${timeoutToUse}ms. See https://remotion.dev/docs/timeout for help.`,\n                        DELAY_RENDER_CALLSTACK_TOKEN,\n                        called,\n                    ]\n                        .filter(truthy)\n                        .join(' ');\n                    throw new Error(message);\n                }, timeoutToUse),\n            };\n        }\n    }\n    if (typeof window !== 'undefined') {\n        window.remotion_renderReady = false;\n    }\n    return handle;\n};\n/**\n * @description Unblock a render that has been blocked by delayRender()\n * @param handle The return value of delayRender().\n * @see [Documentation](https://www.remotion.dev/docs/continue-render)\n */\nconst continueRender = (handle) => {\n    if (typeof handle === 'undefined') {\n        throw new TypeError('The continueRender() method must be called with a parameter that is the return value of delayRender(). No value was passed.');\n    }\n    if (typeof handle !== 'number') {\n        throw new TypeError('The parameter passed into continueRender() must be the return value of delayRender() which is a number. Got: ' +\n            JSON.stringify(handle));\n    }\n    handles = handles.filter((h) => {\n        if (h === handle) {\n            if (getRemotionEnvironment().isRendering) {\n                clearTimeout(window.remotion_delayRenderTimeouts[handle].timeout);\n                delete window.remotion_delayRenderTimeouts[handle];\n            }\n            return false;\n        }\n        return true;\n    });\n    if (handles.length === 0 && typeof window !== 'undefined') {\n        window.remotion_renderReady = true;\n    }\n};\n\nconst RenderAssetManager = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    // Must be undefined, otherwise error in Player\n    registerRenderAsset: () => undefined,\n    unregisterRenderAsset: () => undefined,\n    renderAssets: [],\n});\nconst RenderAssetManagerProvider = ({ children }) => {\n    const [renderAssets, setRenderAssets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const registerRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((renderAsset) => {\n        setRenderAssets((assets) => {\n            return [...assets, renderAsset];\n        });\n    }, []);\n    const unregisterRenderAsset = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        setRenderAssets((assts) => {\n            return assts.filter((a) => a.id !== id);\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (typeof window !== 'undefined') {\n            window.remotion_collectAssets = () => {\n                setRenderAssets([]); // clear assets at next render\n                return renderAssets;\n            };\n        }\n    }, [renderAssets]);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            registerRenderAsset,\n            unregisterRenderAsset,\n            renderAssets,\n        };\n    }, [renderAssets, registerRenderAsset, unregisterRenderAsset]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, { value: contextValue, children: children }));\n};\n\nconst AudioForRenderingRefForwardingFunction = (props, ref) => {\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const absoluteFrame = useTimelinePosition();\n    const volumePropFrame = useFrameForVolumeProp();\n    const frame = useCurrentFrame();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    // Generate a string that's as unique as possible for this asset\n    // but at the same time the same on all threads\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return `audio-${random((_a = props.src) !== null && _a !== void 0 ? _a : '')}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames}`;\n    }, [props.src, sequenceContext]);\n    const { volume: volumeProp, playbackRate, allowAmplificationDuringRender, onDuration, toneFrequency, _remotionInternalNeedsDurationCalculation, acceptableTimeShiftInSeconds, ...nativeProps } = props;\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        return audioRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!props.src) {\n            throw new Error('No src passed');\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (props.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: 'audio',\n            src: getAbsoluteSrc(props.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: (_a = props.playbackRate) !== null && _a !== void 0 ? _a : 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n            toneFrequency: toneFrequency !== null && toneFrequency !== void 0 ? toneFrequency : null,\n        });\n        return () => unregisterRenderAsset(id);\n    }, [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        absoluteFrame,\n        id,\n        unregisterRenderAsset,\n        volume,\n        volumePropFrame,\n        frame,\n        playbackRate,\n        props.playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n    ]);\n    const { src } = props;\n    // The <audio> tag is only rendered if the duration needs to be calculated for the `loop`\n    // attribute to work, or if the user assigns a ref to it.\n    const needsToRenderAudioTag = ref || _remotionInternalNeedsDurationCalculation;\n    // If audio source switches, make new handle\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (false) {}\n        if (!needsToRenderAudioTag) {\n            return;\n        }\n        const newHandle = delayRender('Loading <Audio> duration with src=' + src);\n        const { current } = audioRef;\n        const didLoad = () => {\n            if (current === null || current === void 0 ? void 0 : current.duration) {\n                onDuration(current.src, current.duration);\n            }\n            continueRender(newHandle);\n        };\n        if (current === null || current === void 0 ? void 0 : current.duration) {\n            onDuration(current.src, current.duration);\n            continueRender(newHandle);\n        }\n        else {\n            current === null || current === void 0 ? void 0 : current.addEventListener('loadedmetadata', didLoad, { once: true });\n        }\n        // If tag gets unmounted, clear pending handles because video metadata is not going to load\n        return () => {\n            current === null || current === void 0 ? void 0 : current.removeEventListener('loadedmetadata', didLoad);\n            continueRender(newHandle);\n        };\n    }, [src, onDuration, needsToRenderAudioTag]);\n    if (!needsToRenderAudioTag) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"audio\", { ref: audioRef, ...nativeProps });\n};\nconst AudioForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioForRenderingRefForwardingFunction);\n\nconst AudioRefForwardingFunction = (props, ref) => {\n    var _a;\n    const audioContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SharedAudioContext);\n    const { startFrom, endAt, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof props.src !== 'string') {\n        throw new TypeError(`The \\`<Audio>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const onError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        console.log(e.currentTarget.error);\n        // If there is no `loop` property, we don't need to get the duration\n        // and this does not need to be a fatal error\n        const errMessage = `Could not play audio with src ${otherProps.src}: ${e.currentTarget.error}. See https://remotion.dev/docs/media-playback-error for help.`;\n        if (loop) {\n            cancelRender(new Error(errMessage));\n        }\n        else {\n            console.warn(errMessage);\n        }\n    }, [loop, otherProps.src]);\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n        setDurations({ type: 'got-duration', durationInSeconds, src });\n    }, [setDurations]);\n    if (loop && props.src && durations[getAbsoluteSrc(props.src)] !== undefined) {\n        const duration = Math.floor(durations[getAbsoluteSrc(props.src)] * fps);\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, { layout: \"none\", durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration: duration,\n                playbackRate: (_a = props.playbackRate) !== null && _a !== void 0 ? _a : 1,\n                startFrom,\n            }), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, { ...propsOtherThanLoop, ref: ref }) }));\n    }\n    if (typeof startFrom !== 'undefined' || typeof endAt !== 'undefined') {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom !== null && startFrom !== void 0 ? startFrom : 0;\n        const endAtFrameNo = endAt !== null && endAt !== void 0 ? endAt : Infinity;\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, { layout: \"none\", from: 0 - startFromFrameNo, showInTimeline: false, durationInFrames: endAtFrameNo, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Audio, { _remotionInternalNeedsDurationCalculation: Boolean(loop), ...otherProps, ref: ref }) }));\n    }\n    validateMediaProps(props, 'Audio');\n    if (environment.isRendering) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForRendering, { onDuration: onDuration, ...props, ref: ref, onError: onError, _remotionInternalNeedsDurationCalculation: Boolean(loop) }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AudioForDevelopment, { shouldPreMountAudioTags: audioContext !== null && audioContext.numberOfAudioTags > 0, ...props, ref: ref, onError: onError, onDuration: onDuration, _remotionInternalNeedsDurationCalculation: Boolean(loop) }));\n};\n/**\n * @description With this component, you can add audio to your video. All audio formats which are supported by Chromium are supported by the component.\n * @see [Documentation](https://www.remotion.dev/docs/audio)\n */\nconst Audio = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(AudioRefForwardingFunction);\n\nconst getRegex$1 = () => /^([a-zA-Z0-9-])+$/g;\nconst isFolderNameValid = (name) => name.match(getRegex$1());\nconst validateFolderName = (name) => {\n    if (name === undefined || name === null) {\n        throw new TypeError('You must pass a name to a <Folder />.');\n    }\n    if (typeof name !== 'string') {\n        throw new TypeError(`The \"name\" you pass into <Folder /> must be a string. Got: ${typeof name}`);\n    }\n    if (!isFolderNameValid(name)) {\n        throw new Error(`Folder name can only contain a-z, A-Z, 0-9 and -. You passed ${name}`);\n    }\n};\n\nconst FolderContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    folderName: null,\n    parentName: null,\n});\n/**\n * @description By wrapping a <Composition /> inside a <Folder />, you can visually categorize it in your sidebar, should you have many compositions.\n * @see [Documentation](https://www.remotion.dev/docs/folder)\n */\nconst Folder = ({ name, children, }) => {\n    const parent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    const { registerFolder, unregisterFolder } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    validateFolderName(name);\n    const parentNameArr = [parent.parentName, parent.folderName].filter(truthy);\n    const parentName = parentNameArr.length === 0 ? null : parentNameArr.join('/');\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            folderName: name,\n            parentName,\n        };\n    }, [name, parentName]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        registerFolder(name, parentName);\n        return () => {\n            unregisterFolder(name, parentName);\n        };\n    }, [name, parent.folderName, parentName, registerFolder, unregisterFolder]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(FolderContext.Provider, { value: value, children: children }));\n};\n\nconst rotate = {\n    transform: `rotate(90deg)`,\n};\nconst ICON_SIZE = 40;\nconst label = {\n    color: 'white',\n    fontSize: 14,\n    fontFamily: 'sans-serif',\n};\nconst container = {\n    justifyContent: 'center',\n    alignItems: 'center',\n};\nconst Loading = () => {\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(AbsoluteFill, { style: container, id: \"remotion-comp-loading\", children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"style\", { type: \"text/css\", children: `\n\t\t\t\t@keyframes anim {\n\t\t\t\t\tfrom {\n\t\t\t\t\t\topacity: 0\n\t\t\t\t\t}\n\t\t\t\t\tto {\n\t\t\t\t\t\topacity: 1\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#remotion-comp-loading {\n\t\t\t\t\tanimation: anim 2s;\n\t\t\t\t\tanimation-fill-mode: forwards;\n\t\t\t\t}\n\t\t\t` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"svg\", { width: ICON_SIZE, height: ICON_SIZE, viewBox: \"-100 -100 400 400\", style: rotate, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"path\", { fill: \"#555\", stroke: \"#555\", strokeWidth: \"100\", strokeLinejoin: \"round\", d: \"M 2 172 a 196 100 0 0 0 195 5 A 196 240 0 0 0 100 2.259 A 196 240 0 0 0 2 172 z\" }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsxs)(\"p\", { style: label, children: [\"Resolving \", '<Suspense>', \"...\"] })] }));\n};\n\nlet _portalNode = null;\nconst portalNode = () => {\n    if (!_portalNode) {\n        if (typeof document === 'undefined') {\n            throw new Error('Tried to call an API that only works in the browser from outside the browser');\n        }\n        _portalNode = document.createElement('div');\n        _portalNode.style.position = 'absolute';\n        _portalNode.style.top = '0px';\n        _portalNode.style.left = '0px';\n        _portalNode.style.right = '0px';\n        _portalNode.style.bottom = '0px';\n        _portalNode.style.width = '100%';\n        _portalNode.style.height = '100%';\n        _portalNode.style.display = 'flex';\n        _portalNode.style.flexDirection = 'column';\n    }\n    return _portalNode;\n};\n\n// Expected, it can be any component props\nconst useLazyComponent = (compProps) => {\n    const lazy = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        if ('lazyComponent' in compProps) {\n            return react__WEBPACK_IMPORTED_MODULE_0__.lazy(compProps.lazyComponent);\n        }\n        if ('component' in compProps) {\n            // In SSR, suspense is not yet supported, we cannot use React.lazy\n            if (typeof document === 'undefined') {\n                return compProps.component;\n            }\n            return react__WEBPACK_IMPORTED_MODULE_0__.lazy(() => Promise.resolve({ default: compProps.component }));\n        }\n        throw new Error(\"You must pass either 'component' or 'lazyComponent'\");\n        // Very important to leave the dependencies as they are, or instead\n        // the player will remount on every frame.\n        // @ts-expect-error\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [compProps.component, compProps.lazyComponent]);\n    return lazy;\n};\n\nconst getRegex = () => /^([a-zA-Z0-9-])+$/g;\nconst isCompositionIdValid = (id) => id.match(getRegex());\nconst validateCompositionId = (id) => {\n    if (!isCompositionIdValid(id)) {\n        throw new Error(`Composition id can only contain a-z, A-Z, 0-9 and -. You passed ${id}`);\n    }\n};\nconst invalidCompositionErrorMessage = `Composition ID must match ${String(getRegex())}`;\n\nconst validateDefaultAndInputProps = (defaultProps, name, compositionId) => {\n    if (!defaultProps) {\n        return;\n    }\n    if (typeof defaultProps !== 'object') {\n        throw new Error(`\"${name}\" must be an object, but you passed a value of type ${typeof defaultProps}`);\n    }\n    if (Array.isArray(defaultProps)) {\n        throw new Error(`\"${name}\" must be an object, an array was passed ${compositionId ? `for composition \"${compositionId}\"` : ''}`);\n    }\n};\n\nconst ClipComposition = ({ children }) => {\n    const { clipRegion } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(NativeLayersContext);\n    const style = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            display: 'flex',\n            flexDirection: 'row',\n            opacity: clipRegion === 'hide' ? 0 : 1,\n            clipPath: clipRegion && clipRegion !== 'hide'\n                ? `polygon(${clipRegion.x}px ${clipRegion.y}px, ${clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.height + clipRegion.y}px, ${clipRegion.width + clipRegion.x}px ${clipRegion.y}px)`\n                : undefined,\n        };\n    }, [clipRegion]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(AbsoluteFill, { style: style, children: children });\n};\nconst Fallback = () => {\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const fallback = delayRender('Waiting for Root component to unsuspend');\n        return () => continueRender(fallback);\n    }, []);\n    return null;\n};\n/**\n * @description This component is used to register a video to make it renderable and make it show in the sidebar, in dev mode.\n * @see [Documentation](https://www.remotion.dev/docs/composition)\n */\nconst Composition = ({ width, height, fps, durationInFrames, id, defaultProps, schema, ...compProps }) => {\n    var _a, _b;\n    const { registerComposition, unregisterComposition } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CompositionManager);\n    const video = useVideo();\n    const lazy = useLazyComponent(compProps);\n    const nonce = useNonce();\n    const isPlayer = useIsPlayer();\n    const environment = getRemotionEnvironment();\n    const canUseComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(CanUseRemotionHooks);\n    if (canUseComposition) {\n        if (isPlayer) {\n            throw new Error('<Composition> was mounted inside the `component` that was passed to the <Player>. See https://remotion.dev/docs/wrong-composition-mount for help.');\n        }\n        throw new Error('<Composition> mounted inside another composition. See https://remotion.dev/docs/wrong-composition-mount for help.');\n    }\n    const { folderName, parentName } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(FolderContext);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        // Ensure it's a URL safe id\n        if (!id) {\n            throw new Error('No id for composition passed.');\n        }\n        validateCompositionId(id);\n        validateDefaultAndInputProps(defaultProps, 'defaultProps', id);\n        registerComposition({\n            durationInFrames: durationInFrames !== null && durationInFrames !== void 0 ? durationInFrames : undefined,\n            fps: fps !== null && fps !== void 0 ? fps : undefined,\n            height: height !== null && height !== void 0 ? height : undefined,\n            width: width !== null && width !== void 0 ? width : undefined,\n            id,\n            folderName,\n            component: lazy,\n            defaultProps: defaultProps,\n            nonce,\n            parentFolderName: parentName,\n            schema: schema !== null && schema !== void 0 ? schema : null,\n            calculateMetadata: (_a = compProps.calculateMetadata) !== null && _a !== void 0 ? _a : null,\n        });\n        return () => {\n            unregisterComposition(id);\n        };\n    }, [\n        durationInFrames,\n        fps,\n        height,\n        lazy,\n        id,\n        folderName,\n        defaultProps,\n        registerComposition,\n        unregisterComposition,\n        width,\n        nonce,\n        parentName,\n        schema,\n        compProps.calculateMetadata,\n    ]);\n    const resolved = useResolvedVideoConfig(id);\n    if (environment.isStudio && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== 'success') {\n            return null;\n        }\n        return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ClipComposition, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loading, {}), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, { ...((_a = resolved.result.props) !== null && _a !== void 0 ? _a : {}) }) }) }) }), portalNode());\n    }\n    if (environment.isRendering && video && video.component === lazy) {\n        const Comp = lazy;\n        if (resolved === null || resolved.type !== 'success') {\n            return null;\n        }\n        return (0,react_dom__WEBPACK_IMPORTED_MODULE_2__.createPortal)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooksProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react__WEBPACK_IMPORTED_MODULE_0__.Suspense, { fallback: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Fallback, {}), children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Comp, { ...((_b = resolved.result.props) !== null && _b !== void 0 ? _b : {}) }) }) }), portalNode());\n    }\n    return null;\n};\n\n// Taken from https://github.com/facebook/react-native/blob/0b9ea60b4fee8cacc36e7160e31b91fc114dbc0d/Libraries/Animated/src/bezier.js\nconst NEWTON_ITERATIONS = 4;\nconst NEWTON_MIN_SLOPE = 0.001;\nconst SUBDIVISION_PRECISION = 0.0000001;\nconst SUBDIVISION_MAX_ITERATIONS = 10;\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nconst float32ArraySupported = typeof Float32Array === 'function';\nfunction a(aA1, aA2) {\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\nfunction b(aA1, aA2) {\n    return 3.0 * aA2 - 6.0 * aA1;\n}\nfunction c(aA1) {\n    return 3.0 * aA1;\n}\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier(aT, aA1, aA2) {\n    return ((a(aA1, aA2) * aT + b(aA1, aA2)) * aT + c(aA1)) * aT;\n}\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope(aT, aA1, aA2) {\n    return 3.0 * a(aA1, aA2) * aT * aT + 2.0 * b(aA1, aA2) * aT + c(aA1);\n}\nfunction binarySubdivide({ aX, _aA, _aB, mX1, mX2, }) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    let aA = _aA;\n    let aB = _aB;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > SUBDIVISION_PRECISION &&\n        ++i < SUBDIVISION_MAX_ITERATIONS);\n    return currentT;\n}\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n    let aGuessT = _aGuessT;\n    for (let i = 0; i < NEWTON_ITERATIONS; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nfunction bezier(mX1, mY1, mX2, mY2) {\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n        throw new Error('bezier x values must be in [0, 1] range');\n    }\n    // Precompute samples table\n    const sampleValues = float32ArraySupported\n        ? new Float32Array(kSplineTableSize)\n        : new Array(kSplineTableSize);\n    if (mX1 !== mY1 || mX2 !== mY2) {\n        for (let i = 0; i < kSplineTableSize; ++i) {\n            sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n        }\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        // Interpolate to provide an initial guess for t\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        return binarySubdivide({\n            aX,\n            _aA: intervalStart,\n            _aB: intervalStart + kSampleStepSize,\n            mX1,\n            mX2,\n        });\n    }\n    return function (x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n            return x; // linear\n        }\n        // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n        if (x === 0) {\n            return 0;\n        }\n        if (x === 1) {\n            return 1;\n        }\n        return calcBezier(getTForX(x), mY1, mY2);\n    };\n}\n\n// Taken from https://github.com/facebook/react-native/blob/0b9ea60b4fee8cacc36e7160e31b91fc114dbc0d/Libraries/Animated/src/Easing.js\n/**\n * @description The Easing module implements common easing functions. You can use it with the interpolate() API.\n * @see [Documentation](https://www.remotion.dev/docs/easing)\n */\nclass Easing {\n    static step0(n) {\n        return n > 0 ? 1 : 0;\n    }\n    static step1(n) {\n        return n >= 1 ? 1 : 0;\n    }\n    static linear(t) {\n        return t;\n    }\n    static ease(t) {\n        return Easing.bezier(0.42, 0, 1, 1)(t);\n    }\n    static quad(t) {\n        return t * t;\n    }\n    static cubic(t) {\n        return t * t * t;\n    }\n    static poly(n) {\n        return (t) => t ** n;\n    }\n    static sin(t) {\n        return 1 - Math.cos((t * Math.PI) / 2);\n    }\n    static circle(t) {\n        return 1 - Math.sqrt(1 - t * t);\n    }\n    static exp(t) {\n        return 2 ** (10 * (t - 1));\n    }\n    static elastic(bounciness = 1) {\n        const p = bounciness * Math.PI;\n        return (t) => 1 - Math.cos((t * Math.PI) / 2) ** 3 * Math.cos(t * p);\n    }\n    static back(s = 1.70158) {\n        return (t) => t * t * ((s + 1) * t - s);\n    }\n    static bounce(t) {\n        if (t < 1 / 2.75) {\n            return 7.5625 * t * t;\n        }\n        if (t < 2 / 2.75) {\n            const t2_ = t - 1.5 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.75;\n        }\n        if (t < 2.5 / 2.75) {\n            const t2_ = t - 2.25 / 2.75;\n            return 7.5625 * t2_ * t2_ + 0.9375;\n        }\n        const t2 = t - 2.625 / 2.75;\n        return 7.5625 * t2 * t2 + 0.984375;\n    }\n    static bezier(x1, y1, x2, y2) {\n        return bezier(x1, y1, x2, y2);\n    }\n    static in(easing) {\n        return easing;\n    }\n    static out(easing) {\n        return (t) => 1 - easing(1 - t);\n    }\n    static inOut(easing) {\n        return (t) => {\n            if (t < 0.5) {\n                return easing(t * 2) / 2;\n            }\n            return 1 - easing((1 - t) * 2) / 2;\n        };\n    }\n}\n\n/**\n * @description This method freezes all of its children to the frame that you specify as a prop\n * @see [Documentation](https://www.remotion.dev/docs/freeze)\n */\nconst Freeze = ({ frame, children }) => {\n    const videoConfig = useVideoConfig();\n    if (typeof frame === 'undefined') {\n        throw new Error(`The <Freeze /> component requires a 'frame' prop, but none was passed.`);\n    }\n    if (typeof frame !== 'number') {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a number, but is of type ${typeof frame}`);\n    }\n    if (Number.isNaN(frame)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a real number, but it is NaN.`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new Error(`The 'frame' prop of <Freeze /> must be a finite number, but it is ${frame}.`);\n    }\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TimelineContext);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            ...context,\n            playing: false,\n            imperativePlaying: {\n                current: false,\n            },\n            frame: {\n                [videoConfig.id]: frame,\n            },\n        };\n    }, [context, frame, videoConfig.id]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, { value: value, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, { value: null, children: children }) }));\n};\n\nlet warnedServer = false;\nlet warnedPlayer = false;\nconst warnServerOnce = () => {\n    if (warnedServer) {\n        return;\n    }\n    warnedServer = true;\n    console.warn('Called getStaticFiles() on the server. The API is only available in the browser. An empty array was returned.');\n};\nconst warnPlayerOnce = () => {\n    if (warnedPlayer) {\n        return;\n    }\n    warnedPlayer = true;\n    console.warn('Called getStaticFiles() while using the Remotion Player. The API is only available while using the Remotion Studio. An empty array was returned.');\n};\n/**\n * @description The function array containing all files in the public/ folder. You can reference them by using staticFile().\n * @see [Documentation](https://www.remotion.dev/docs/getstaticfiles)\n */\nconst getStaticFiles = () => {\n    if (typeof document === 'undefined') {\n        warnServerOnce();\n        return [];\n    }\n    if (window.remotion_isPlayer) {\n        warnPlayerOnce();\n        return [];\n    }\n    return window.remotion_staticFiles;\n};\n\nconst IFrameRefForwarding = ({ onLoad, onError, ...props }, ref) => {\n    const [handle] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => delayRender(`Loading <IFrame> with source ${props.src}`));\n    const didLoad = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        continueRender(handle);\n        onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);\n    }, [handle, onLoad]);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        continueRender(handle);\n        if (onError) {\n            onError(e);\n        }\n        else {\n            console.error('Error loading iframe:', e, 'Handle the event using the onError() prop to make this message disappear.');\n        }\n    }, [handle, onError]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"iframe\", { ...props, ref: ref, onError: didGetError, onLoad: didLoad });\n};\n/**\n * @description The <IFrame /> can be used like a regular <iframe> HTML tag.\n * @see [Documentation](https://www.remotion.dev/docs/iframe)\n */\nconst IFrame = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(IFrameRefForwarding);\n\nfunction exponentialBackoff(errorCount) {\n    return 1000 * 2 ** (errorCount - 1);\n}\nconst ImgRefForwarding = ({ onError, maxRetries = 2, src, ...props }, ref) => {\n    const imageRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const errors = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({});\n    if (!src) {\n        throw new Error('No \"src\" prop was passed to <Img>.');\n    }\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        return imageRef.current;\n    }, []);\n    const actualSrc = usePreload(src);\n    const retryIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((timeout) => {\n        if (!imageRef.current) {\n            return;\n        }\n        const currentSrc = imageRef.current.src;\n        setTimeout(() => {\n            var _a;\n            if (!imageRef.current) {\n                // Component has been unmounted, do not retry\n                return;\n            }\n            const newSrc = (_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src;\n            if (newSrc !== currentSrc) {\n                // src has changed, do not retry\n                return;\n            }\n            imageRef.current.removeAttribute('src');\n            imageRef.current.setAttribute('src', newSrc);\n        }, timeout);\n    }, []);\n    const didGetError = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        if (!errors.current) {\n            return;\n        }\n        errors.current[(_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src] =\n            ((_c = errors.current[(_b = imageRef.current) === null || _b === void 0 ? void 0 : _b.src]) !== null && _c !== void 0 ? _c : 0) + 1;\n        if (onError &&\n            ((_e = errors.current[(_d = imageRef.current) === null || _d === void 0 ? void 0 : _d.src]) !== null && _e !== void 0 ? _e : 0) > maxRetries) {\n            onError(e);\n            return;\n        }\n        if (((_g = errors.current[(_f = imageRef.current) === null || _f === void 0 ? void 0 : _f.src]) !== null && _g !== void 0 ? _g : 0) <= maxRetries) {\n            const backoff = exponentialBackoff((_j = errors.current[(_h = imageRef.current) === null || _h === void 0 ? void 0 : _h.src]) !== null && _j !== void 0 ? _j : 0);\n            console.warn(`Could not load image with source ${(_k = imageRef.current) === null || _k === void 0 ? void 0 : _k.src}, retrying again in ${backoff}ms`);\n            retryIn(backoff);\n            return;\n        }\n        cancelRender('Error loading image with src: ' + ((_l = imageRef.current) === null || _l === void 0 ? void 0 : _l.src));\n    }, [maxRetries, onError, retryIn]);\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            if (false) {}\n            const newHandle = delayRender('Loading <Img> with src=' + actualSrc);\n            const { current } = imageRef;\n            const onComplete = () => {\n                var _a, _b, _c, _d;\n                if (((_b = errors.current[(_a = imageRef.current) === null || _a === void 0 ? void 0 : _a.src]) !== null && _b !== void 0 ? _b : 0) > 0) {\n                    delete errors.current[(_c = imageRef.current) === null || _c === void 0 ? void 0 : _c.src];\n                    console.info(`Retry successful - ${(_d = imageRef.current) === null || _d === void 0 ? void 0 : _d.src} is now loaded`);\n                }\n                continueRender(newHandle);\n            };\n            const didLoad = () => {\n                onComplete();\n            };\n            if (current === null || current === void 0 ? void 0 : current.complete) {\n                onComplete();\n            }\n            else {\n                current === null || current === void 0 ? void 0 : current.addEventListener('load', didLoad, { once: true });\n            }\n            // If tag gets unmounted, clear pending handles because image is not going to load\n            return () => {\n                current === null || current === void 0 ? void 0 : current.removeEventListener('load', didLoad);\n                continueRender(newHandle);\n            };\n        }, [actualSrc]);\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"img\", { ...props, ref: imageRef, src: actualSrc, onError: didGetError }));\n};\n/**\n * @description Works just like a regular HTML img tag. When you use the <Img> tag, Remotion will ensure that the image is loaded before rendering the frame.\n * @see [Documentation](https://www.remotion.dev/docs/img)\n */\nconst Img = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(ImgRefForwarding);\n\nconst compositionsRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\nconst CompositionManagerProvider = ({ children, numberOfAudioTags }) => {\n    var _a;\n    // Wontfix, expected to have\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const [compositions, setCompositions] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const currentcompositionsRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(compositions);\n    const [folders, setFolders] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const [canvasContent, setCanvasContent] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [currentCompositionMetadata, setCurrentCompositionMetadata] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const updateCompositions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    updateComps) => {\n        setCompositions((comps) => {\n            const updated = updateComps(comps);\n            currentcompositionsRef.current = updated;\n            return updated;\n        });\n    }, []);\n    const registerComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((comp) => {\n        updateCompositions((comps) => {\n            if (comps.find((c) => c.id === comp.id)) {\n                throw new Error(`Multiple composition with id ${comp.id} are registered.`);\n            }\n            const value = [...comps, comp]\n                .slice()\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                .sort((a, b) => a.nonce - b.nonce);\n            return value;\n        });\n    }, [updateCompositions]);\n    const unregisterComposition = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((id) => {\n        setCompositions((comps) => {\n            return comps.filter((c) => c.id !== id);\n        });\n    }, []);\n    const registerFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n        setFolders((prevFolders) => {\n            return [\n                ...prevFolders,\n                {\n                    name,\n                    parent,\n                },\n            ];\n        });\n    }, []);\n    const unregisterFolder = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((name, parent) => {\n        setFolders((prevFolders) => {\n            return prevFolders.filter((p) => !(p.name === name && p.parent === parent));\n        });\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(compositionsRef, () => {\n        return {\n            getCompositions: () => currentcompositionsRef.current,\n        };\n    }, []);\n    const composition = compositions.find((c) => (canvasContent === null || canvasContent === void 0 ? void 0 : canvasContent.type) === 'composition'\n        ? c.id === canvasContent.compositionId\n        : null);\n    const contextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            compositions,\n            registerComposition,\n            unregisterComposition,\n            folders,\n            registerFolder,\n            unregisterFolder,\n            currentCompositionMetadata,\n            setCurrentCompositionMetadata,\n            canvasContent,\n            setCanvasContent,\n        };\n    }, [\n        compositions,\n        registerComposition,\n        unregisterComposition,\n        folders,\n        registerFolder,\n        unregisterFolder,\n        currentCompositionMetadata,\n        canvasContent,\n        setCanvasContent,\n    ]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, { value: contextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManagerProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManagerProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionConfig, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SharedAudioContextProvider, { numberOfAudioTags: numberOfAudioTags, component: (_a = composition === null || composition === void 0 ? void 0 : composition.component) !== null && _a !== void 0 ? _a : null, children: children }) }) }) }) }));\n};\n\nconst injected = {};\nconst injectCSS = (css) => {\n    // Skip in node\n    if (typeof document === 'undefined') {\n        return;\n    }\n    if (injected[css]) {\n        return;\n    }\n    const head = document.head || document.getElementsByTagName('head')[0];\n    const style = document.createElement('style');\n    style.appendChild(document.createTextNode(css));\n    head.prepend(style);\n    injected[css] = true;\n};\nconst OFFTHREAD_VIDEO_CLASS_NAME = '__remotion_offthreadvideo';\nconst makeDefaultCSS = (scope, backgroundColor) => {\n    if (!scope) {\n        return `\n    * {\n      box-sizing: border-box;\n    }\n    body {\n      margin: 0;\n\t    background-color: ${backgroundColor};\n    }\n    .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n    `;\n    }\n    return `\n    ${scope} * {\n      box-sizing: border-box;\n    }\n    ${scope} *:-webkit-full-screen {\n      width: 100%;\n      height: 100%;\n    }\n    ${scope} .${OFFTHREAD_VIDEO_CLASS_NAME} {\n      object-fit: contain;\n    }\n  `;\n};\n\nvar CSSUtils = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    injectCSS: injectCSS,\n    OFFTHREAD_VIDEO_CLASS_NAME: OFFTHREAD_VIDEO_CLASS_NAME,\n    makeDefaultCSS: makeDefaultCSS\n});\n\nconst REMOTION_STUDIO_CONTAINER_ELEMENT = '__remotion-studio-container';\nconst getPreviewDomElement = () => {\n    return document.getElementById(REMOTION_STUDIO_CONTAINER_ELEMENT);\n};\n\n/**\n * Copied from:\n * https://github.com/software-mansion/react-native-reanimated/blob/master/src/reanimated2/Colors.ts\n */\n// var INTEGER = '[-+]?\\\\d+';\nconst NUMBER = '[-+]?\\\\d*\\\\.?\\\\d+';\nconst PERCENTAGE = NUMBER + '%';\nfunction call(...args) {\n    return '\\\\(\\\\s*(' + args.join(')\\\\s*,\\\\s*(') + ')\\\\s*\\\\)';\n}\nfunction getMatchers() {\n    const cachedMatchers = {\n        rgb: undefined,\n        rgba: undefined,\n        hsl: undefined,\n        hsla: undefined,\n        hex3: undefined,\n        hex4: undefined,\n        hex5: undefined,\n        hex6: undefined,\n        hex8: undefined,\n    };\n    if (cachedMatchers.rgb === undefined) {\n        cachedMatchers.rgb = new RegExp('rgb' + call(NUMBER, NUMBER, NUMBER));\n        cachedMatchers.rgba = new RegExp('rgba' + call(NUMBER, NUMBER, NUMBER, NUMBER));\n        cachedMatchers.hsl = new RegExp('hsl' + call(NUMBER, PERCENTAGE, PERCENTAGE));\n        cachedMatchers.hsla = new RegExp('hsla' + call(NUMBER, PERCENTAGE, PERCENTAGE, NUMBER));\n        cachedMatchers.hex3 = /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex4 =\n            /^#([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/;\n        cachedMatchers.hex6 = /^#([0-9a-fA-F]{6})$/;\n        cachedMatchers.hex8 = /^#([0-9a-fA-F]{8})$/;\n    }\n    return cachedMatchers;\n}\nfunction hue2rgb(p, q, t) {\n    if (t < 0) {\n        t += 1;\n    }\n    if (t > 1) {\n        t -= 1;\n    }\n    if (t < 1 / 6) {\n        return p + (q - p) * 6 * t;\n    }\n    if (t < 1 / 2) {\n        return q;\n    }\n    if (t < 2 / 3) {\n        return p + (q - p) * (2 / 3 - t) * 6;\n    }\n    return p;\n}\nfunction hslToRgb(h, s, l) {\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    const r = hue2rgb(p, q, h + 1 / 3);\n    const g = hue2rgb(p, q, h);\n    const b = hue2rgb(p, q, h - 1 / 3);\n    return ((Math.round(r * 255) << 24) |\n        (Math.round(g * 255) << 16) |\n        (Math.round(b * 255) << 8));\n}\nfunction parse255(str) {\n    const int = Number.parseInt(str, 10);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 255) {\n        return 255;\n    }\n    return int;\n}\nfunction parse360(str) {\n    const int = Number.parseFloat(str);\n    return (((int % 360) + 360) % 360) / 360;\n}\nfunction parse1(str) {\n    const num = Number.parseFloat(str);\n    if (num < 0) {\n        return 0;\n    }\n    if (num > 1) {\n        return 255;\n    }\n    return Math.round(num * 255);\n}\nfunction parsePercentage(str) {\n    // parseFloat conveniently ignores the final %\n    const int = Number.parseFloat(str);\n    if (int < 0) {\n        return 0;\n    }\n    if (int > 100) {\n        return 1;\n    }\n    return int / 100;\n}\nconst names = {\n    transparent: 0x00000000,\n    // http://www.w3.org/TR/css3-color/#svg-color\n    aliceblue: 0xf0f8ffff,\n    antiquewhite: 0xfaebd7ff,\n    aqua: 0x00ffffff,\n    aquamarine: 0x7fffd4ff,\n    azure: 0xf0ffffff,\n    beige: 0xf5f5dcff,\n    bisque: 0xffe4c4ff,\n    black: 0x000000ff,\n    blanchedalmond: 0xffebcdff,\n    blue: 0x0000ffff,\n    blueviolet: 0x8a2be2ff,\n    brown: 0xa52a2aff,\n    burlywood: 0xdeb887ff,\n    burntsienna: 0xea7e5dff,\n    cadetblue: 0x5f9ea0ff,\n    chartreuse: 0x7fff00ff,\n    chocolate: 0xd2691eff,\n    coral: 0xff7f50ff,\n    cornflowerblue: 0x6495edff,\n    cornsilk: 0xfff8dcff,\n    crimson: 0xdc143cff,\n    cyan: 0x00ffffff,\n    darkblue: 0x00008bff,\n    darkcyan: 0x008b8bff,\n    darkgoldenrod: 0xb8860bff,\n    darkgray: 0xa9a9a9ff,\n    darkgreen: 0x006400ff,\n    darkgrey: 0xa9a9a9ff,\n    darkkhaki: 0xbdb76bff,\n    darkmagenta: 0x8b008bff,\n    darkolivegreen: 0x556b2fff,\n    darkorange: 0xff8c00ff,\n    darkorchid: 0x9932ccff,\n    darkred: 0x8b0000ff,\n    darksalmon: 0xe9967aff,\n    darkseagreen: 0x8fbc8fff,\n    darkslateblue: 0x483d8bff,\n    darkslategray: 0x2f4f4fff,\n    darkslategrey: 0x2f4f4fff,\n    darkturquoise: 0x00ced1ff,\n    darkviolet: 0x9400d3ff,\n    deeppink: 0xff1493ff,\n    deepskyblue: 0x00bfffff,\n    dimgray: 0x696969ff,\n    dimgrey: 0x696969ff,\n    dodgerblue: 0x1e90ffff,\n    firebrick: 0xb22222ff,\n    floralwhite: 0xfffaf0ff,\n    forestgreen: 0x228b22ff,\n    fuchsia: 0xff00ffff,\n    gainsboro: 0xdcdcdcff,\n    ghostwhite: 0xf8f8ffff,\n    gold: 0xffd700ff,\n    goldenrod: 0xdaa520ff,\n    gray: 0x808080ff,\n    green: 0x008000ff,\n    greenyellow: 0xadff2fff,\n    grey: 0x808080ff,\n    honeydew: 0xf0fff0ff,\n    hotpink: 0xff69b4ff,\n    indianred: 0xcd5c5cff,\n    indigo: 0x4b0082ff,\n    ivory: 0xfffff0ff,\n    khaki: 0xf0e68cff,\n    lavender: 0xe6e6faff,\n    lavenderblush: 0xfff0f5ff,\n    lawngreen: 0x7cfc00ff,\n    lemonchiffon: 0xfffacdff,\n    lightblue: 0xadd8e6ff,\n    lightcoral: 0xf08080ff,\n    lightcyan: 0xe0ffffff,\n    lightgoldenrodyellow: 0xfafad2ff,\n    lightgray: 0xd3d3d3ff,\n    lightgreen: 0x90ee90ff,\n    lightgrey: 0xd3d3d3ff,\n    lightpink: 0xffb6c1ff,\n    lightsalmon: 0xffa07aff,\n    lightseagreen: 0x20b2aaff,\n    lightskyblue: 0x87cefaff,\n    lightslategray: 0x778899ff,\n    lightslategrey: 0x778899ff,\n    lightsteelblue: 0xb0c4deff,\n    lightyellow: 0xffffe0ff,\n    lime: 0x00ff00ff,\n    limegreen: 0x32cd32ff,\n    linen: 0xfaf0e6ff,\n    magenta: 0xff00ffff,\n    maroon: 0x800000ff,\n    mediumaquamarine: 0x66cdaaff,\n    mediumblue: 0x0000cdff,\n    mediumorchid: 0xba55d3ff,\n    mediumpurple: 0x9370dbff,\n    mediumseagreen: 0x3cb371ff,\n    mediumslateblue: 0x7b68eeff,\n    mediumspringgreen: 0x00fa9aff,\n    mediumturquoise: 0x48d1ccff,\n    mediumvioletred: 0xc71585ff,\n    midnightblue: 0x191970ff,\n    mintcream: 0xf5fffaff,\n    mistyrose: 0xffe4e1ff,\n    moccasin: 0xffe4b5ff,\n    navajowhite: 0xffdeadff,\n    navy: 0x000080ff,\n    oldlace: 0xfdf5e6ff,\n    olive: 0x808000ff,\n    olivedrab: 0x6b8e23ff,\n    orange: 0xffa500ff,\n    orangered: 0xff4500ff,\n    orchid: 0xda70d6ff,\n    palegoldenrod: 0xeee8aaff,\n    palegreen: 0x98fb98ff,\n    paleturquoise: 0xafeeeeff,\n    palevioletred: 0xdb7093ff,\n    papayawhip: 0xffefd5ff,\n    peachpuff: 0xffdab9ff,\n    peru: 0xcd853fff,\n    pink: 0xffc0cbff,\n    plum: 0xdda0ddff,\n    powderblue: 0xb0e0e6ff,\n    purple: 0x800080ff,\n    rebeccapurple: 0x663399ff,\n    red: 0xff0000ff,\n    rosybrown: 0xbc8f8fff,\n    royalblue: 0x4169e1ff,\n    saddlebrown: 0x8b4513ff,\n    salmon: 0xfa8072ff,\n    sandybrown: 0xf4a460ff,\n    seagreen: 0x2e8b57ff,\n    seashell: 0xfff5eeff,\n    sienna: 0xa0522dff,\n    silver: 0xc0c0c0ff,\n    skyblue: 0x87ceebff,\n    slateblue: 0x6a5acdff,\n    slategray: 0x708090ff,\n    slategrey: 0x708090ff,\n    snow: 0xfffafaff,\n    springgreen: 0x00ff7fff,\n    steelblue: 0x4682b4ff,\n    tan: 0xd2b48cff,\n    teal: 0x008080ff,\n    thistle: 0xd8bfd8ff,\n    tomato: 0xff6347ff,\n    turquoise: 0x40e0d0ff,\n    violet: 0xee82eeff,\n    wheat: 0xf5deb3ff,\n    white: 0xffffffff,\n    whitesmoke: 0xf5f5f5ff,\n    yellow: 0xffff00ff,\n    yellowgreen: 0x9acd32ff,\n};\nfunction normalizeColor(color) {\n    const matchers = getMatchers();\n    let match;\n    // Ordered based on occurrences on Facebook codebase\n    if (matchers.hex6) {\n        if ((match = matchers.hex6.exec(color))) {\n            return Number.parseInt(match[1] + 'ff', 16) >>> 0;\n        }\n    }\n    if (names[color] !== undefined) {\n        return names[color];\n    }\n    if (matchers.rgb) {\n        if ((match = matchers.rgb.exec(color))) {\n            return (\n            // b\n            ((parse255(match[1]) << 24) | // r\n                (parse255(match[2]) << 16) | // g\n                (parse255(match[3]) << 8) |\n                0x000000ff) >>> // a\n                0);\n        }\n    }\n    if (matchers.rgba) {\n        if ((match = matchers.rgba.exec(color))) {\n            return (\n            // b\n            ((parse255(match[1]) << 24) | // r\n                (parse255(match[2]) << 16) | // g\n                (parse255(match[3]) << 8) |\n                parse1(match[4])) >>> // a\n                0);\n        }\n    }\n    if (matchers.hex3) {\n        if ((match = matchers.hex3.exec(color))) {\n            return (Number.parseInt(match[1] +\n                match[1] + // r\n                match[2] +\n                match[2] + // g\n                match[3] +\n                match[3] + // b\n                'ff', // a\n            16) >>> 0);\n        }\n    }\n    // https://drafts.csswg.org/css-color-4/#hex-notation\n    if (matchers.hex8) {\n        if ((match = matchers.hex8.exec(color))) {\n            return Number.parseInt(match[1], 16) >>> 0;\n        }\n    }\n    if (matchers.hex4) {\n        if ((match = matchers.hex4.exec(color))) {\n            return (Number.parseInt(match[1] +\n                match[1] + // r\n                match[2] +\n                match[2] + // g\n                match[3] +\n                match[3] + // b\n                match[4] +\n                match[4], // a\n            16) >>> 0);\n        }\n    }\n    if (matchers.hsl) {\n        if ((match = matchers.hsl.exec(color))) {\n            return ((hslToRgb(parse360(match[1]), // h\n            parsePercentage(match[2]), // s\n            parsePercentage(match[3])) |\n                0x000000ff) >>> // a\n                0);\n        }\n    }\n    if (matchers.hsla) {\n        if ((match = matchers.hsla.exec(color))) {\n            return ((hslToRgb(parse360(match[1]), // h\n            parsePercentage(match[2]), // s\n            parsePercentage(match[3])) |\n                parse1(match[4])) >>> // a\n                0);\n        }\n    }\n    throw new Error(`invalid color string ${color} provided`);\n}\nconst opacity = (c) => {\n    return ((c >> 24) & 255) / 255;\n};\nconst red = (c) => {\n    return (c >> 16) & 255;\n};\nconst green = (c) => {\n    return (c >> 8) & 255;\n};\nconst blue = (c) => {\n    return c & 255;\n};\nconst rgbaColor = (r, g, b, alpha) => {\n    return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n};\nfunction processColor(color) {\n    const normalizedColor = normalizeColor(color);\n    return ((normalizedColor << 24) | (normalizedColor >>> 8)) >>> 0; // argb\n}\nconst interpolateColorsRGB = (value, inputRange, colors) => {\n    const [r, g, b, a] = [red, green, blue, opacity].map((f) => {\n        const unrounded = interpolate(value, inputRange, colors.map((c) => f(c)), {\n            extrapolateLeft: 'clamp',\n            extrapolateRight: 'clamp',\n        });\n        if (f === opacity) {\n            return Number(unrounded.toFixed(3));\n        }\n        return Math.round(unrounded);\n    });\n    return rgbaColor(r, g, b, a);\n};\n/**\n * @description This function allows you to map a range of values to colors using a concise syntax.\n * @see [Documentation](https://www.remotion.dev/docs/interpolate-colors)\n */\nconst interpolateColors = (input, inputRange, outputRange) => {\n    if (typeof input === 'undefined') {\n        throw new TypeError('input can not be undefined');\n    }\n    if (typeof inputRange === 'undefined') {\n        throw new TypeError('inputRange can not be undefined');\n    }\n    if (typeof outputRange === 'undefined') {\n        throw new TypeError('outputRange can not be undefined');\n    }\n    if (inputRange.length !== outputRange.length) {\n        throw new TypeError('inputRange (' +\n            inputRange.length +\n            ' values provided) and outputRange (' +\n            outputRange.length +\n            ' values provided) must have the same length');\n    }\n    const processedOutputRange = outputRange.map((c) => processColor(c));\n    return interpolateColorsRGB(input, inputRange, processedOutputRange);\n};\n\nlet Root = null;\nlet listeners = [];\n/**\n * @description This function registers the root component of the Remotion project\n * @see [Documentation](https://www.remotion.dev/docs/register-root)\n */\nconst registerRoot = (comp) => {\n    if (!comp) {\n        throw new Error(`You must pass a React component to registerRoot(), but ${JSON.stringify(comp)} was passed.`);\n    }\n    if (Root) {\n        throw new Error('registerRoot() was called more than once.');\n    }\n    Root = comp;\n    listeners.forEach((l) => {\n        l(comp);\n    });\n};\nconst getRoot = () => {\n    return Root;\n};\nconst waitForRoot = (fn) => {\n    if (Root) {\n        fn(Root);\n        return () => undefined;\n    }\n    listeners.push(fn);\n    return () => {\n        listeners = listeners.filter((l) => l !== fn);\n    };\n};\n\nconst RemotionRoot = ({ children, numberOfAudioTags }) => {\n    const [remotionRootId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => String(random(null)));\n    const [frame, setFrame] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({});\n    const [playing, setPlaying] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const imperativePlaying = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [fastRefreshes, setFastRefreshes] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);\n    const [playbackRate, setPlaybackRate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(1);\n    const audioAndVideoTags = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)([]);\n    if (typeof window !== 'undefined') {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            window.remotion_setFrame = (f, composition) => {\n                const id = delayRender(`Setting the current frame to ${f}`);\n                setFrame((s) => ({\n                    ...s,\n                    [composition]: f,\n                }));\n                requestAnimationFrame(() => continueRender(id));\n            };\n            window.remotion_isPlayer = false;\n        }, []);\n    }\n    const timelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            frame,\n            playing,\n            imperativePlaying,\n            rootId: remotionRootId,\n            playbackRate,\n            setPlaybackRate,\n            audioAndVideoTags,\n        };\n    }, [frame, playbackRate, playing, remotionRootId]);\n    const setTimelineContextValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return {\n            setFrame,\n            setPlaying,\n        };\n    }, []);\n    const nonceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let counter = 0;\n        return {\n            getNonce: () => counter++,\n            fastRefreshes,\n        };\n    }, [fastRefreshes]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (true) {\n            if (__webpack_module__.hot) {\n                __webpack_module__.hot.addStatusHandler((status) => {\n                    if (status === 'idle') {\n                        setFastRefreshes((i) => i + 1);\n                    }\n                });\n            }\n        }\n    }, []);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, { value: nonceContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, { value: timelineContextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, { value: setTimelineContextValue, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(EditorPropsProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PrefetchProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersProvider, { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManagerProvider, { numberOfAudioTags: numberOfAudioTags, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(DurationsContextProvider, { children: children }) }) }) }) }) }) }) }));\n};\n\nconst getEnvVariables = () => {\n    if (getRemotionEnvironment().isRendering) {\n        const param = window.remotion_envVariables;\n        if (!param) {\n            return {};\n        }\n        return { ...JSON.parse(param), NODE_ENV: \"development\" };\n    }\n    if (getRemotionEnvironment().isStudio) {\n        // For the Studio, we already set the environment variables in index-html.ts.\n        // We just add NODE_ENV here.\n        return {\n            NODE_ENV: 'development',\n        };\n    }\n    throw new Error('Can only call getEnvVariables() if environment is `rendering` or `preview`');\n};\nconst setupEnvVariables = () => {\n    const env = getEnvVariables();\n    if (!window.process) {\n        window.process = {};\n    }\n    if (!window.process.env) {\n        window.process.env = {};\n    }\n    Object.keys(env).forEach((key) => {\n        window.process.env[key] = env[key];\n    });\n};\n\nconst validateFrame = ({ allowFloats, durationInFrames, frame, }) => {\n    if (typeof frame === 'undefined') {\n        throw new TypeError(`Argument missing for parameter \"frame\"`);\n    }\n    if (typeof frame !== 'number') {\n        throw new TypeError(`Argument passed for \"frame\" is not a number: ${frame}`);\n    }\n    if (!Number.isFinite(frame)) {\n        throw new RangeError(`Frame ${frame} is not finite`);\n    }\n    if (frame % 1 !== 0 && !allowFloats) {\n        throw new RangeError(`Argument for frame must be an integer, but got ${frame}`);\n    }\n    if (frame < 0 && frame < -durationInFrames) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the lowest frame that can be rendered is ${-durationInFrames}`);\n    }\n    if (frame > durationInFrames - 1) {\n        throw new RangeError(`Cannot use frame ${frame}: Duration of composition is ${durationInFrames}, therefore the highest frame that can be rendered is ${durationInFrames - 1}`);\n    }\n};\n\nfunction useRemotionContexts() {\n    const compositionManagerCtx = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CompositionManager);\n    const timelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(TimelineContext);\n    const setTimelineContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SetTimelineContext);\n    const sequenceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceContext);\n    const nonceContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NonceContext);\n    const canUseRemotionHooksContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(CanUseRemotionHooks);\n    const nativeLayersContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(NativeLayersContext);\n    const preloadContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(PreloadContext);\n    const resolveCompositionContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(ResolveCompositionContext);\n    const renderAssetManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(RenderAssetManager);\n    const sequenceManagerContext = react__WEBPACK_IMPORTED_MODULE_0__.useContext(SequenceManager);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => ({\n        compositionManagerCtx,\n        timelineContext,\n        setTimelineContext,\n        sequenceContext,\n        nonceContext,\n        canUseRemotionHooksContext,\n        nativeLayersContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n    }), [\n        compositionManagerCtx,\n        nonceContext,\n        sequenceContext,\n        setTimelineContext,\n        timelineContext,\n        canUseRemotionHooksContext,\n        nativeLayersContext,\n        preloadContext,\n        resolveCompositionContext,\n        renderAssetManagerContext,\n        sequenceManagerContext,\n    ]);\n}\nconst RemotionContextProvider = (props) => {\n    const { children, contexts } = props;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CanUseRemotionHooks.Provider, { value: contexts.canUseRemotionHooksContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NonceContext.Provider, { value: contexts.nonceContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(NativeLayersContext.Provider, { value: contexts.nativeLayersContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(PreloadContext.Provider, { value: contexts.preloadContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(CompositionManager.Provider, { value: contexts.compositionManagerCtx, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceManager.Provider, { value: contexts.sequenceManagerContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(RenderAssetManager.Provider, { value: contexts.renderAssetManagerContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(ResolveCompositionContext.Provider, { value: contexts.resolveCompositionContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(TimelineContext.Provider, { value: contexts.timelineContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SetTimelineContext.Provider, { value: contexts.setTimelineContext, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(SequenceContext.Provider, { value: contexts.sequenceContext, children: children }) }) }) }) }) }) }) }) }) }) }));\n};\n\n// Mark them as Internals so use don't assume this is public\n// API and are less likely to use it\nconst Internals = {\n    useUnsafeVideoConfig,\n    Timeline: TimelinePosition,\n    CompositionManager,\n    SequenceManager,\n    RemotionRoot,\n    useVideo,\n    getRoot,\n    useMediaVolumeState,\n    useMediaMutedState,\n    useLazyComponent,\n    truthy,\n    SequenceContext,\n    useRemotionContexts,\n    RemotionContextProvider,\n    CSSUtils,\n    setupEnvVariables,\n    MediaVolumeContext,\n    SetMediaVolumeContext,\n    validateDurationInFrames,\n    validateFps,\n    validateDefaultAndInputProps,\n    validateDimension,\n    getRemotionEnvironment,\n    SharedAudioContext,\n    SharedAudioContextProvider,\n    invalidCompositionErrorMessage,\n    isCompositionIdValid,\n    getPreviewDomElement,\n    compositionsRef,\n    DELAY_RENDER_CALLSTACK_TOKEN,\n    portalNode,\n    waitForRoot,\n    CanUseRemotionHooksProvider,\n    CanUseRemotionHooks,\n    PrefetchProvider,\n    DurationsContextProvider,\n    IsPlayerContextProvider,\n    useIsPlayer,\n    validateFrame,\n    EditorPropsProvider,\n    EditorPropsContext,\n    usePreload,\n    processColor,\n    NonceContext,\n    resolveVideoConfig,\n    useResolvedVideoConfig,\n    resolveCompositionsRef,\n    ResolveCompositionConfig,\n    REMOTION_STUDIO_CONTAINER_ELEMENT,\n    RenderAssetManager,\n    bundleName: 'bundle.js',\n    bundleMapName: 'bundle.js.map',\n    persistCurrentFrame,\n    useTimelineSetFrame,\n    serializeJSONWithDate,\n    deserializeJSONWithCustomFields,\n    FILE_TOKEN,\n    DATE_TOKEN,\n    NativeLayersProvider,\n    ClipComposition,\n    isIosSafari,\n};\n\nconst flattenChildren = (children) => {\n    const childrenArray = react__WEBPACK_IMPORTED_MODULE_0__.Children.toArray(children);\n    return childrenArray.reduce((flatChildren, child) => {\n        if (child.type === react__WEBPACK_IMPORTED_MODULE_0__.Fragment) {\n            return flatChildren.concat(flattenChildren(child.props\n                .children));\n        }\n        flatChildren.push(child);\n        return flatChildren;\n    }, []);\n};\n\nconst SeriesSequenceRefForwardingFunction = ({ children }, _ref) => {\n    // Discard ref\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: children });\n};\nconst SeriesSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(SeriesSequenceRefForwardingFunction);\n/**\n * @description with this component, you can easily stitch together scenes that should play sequentially after another.\n * @see [Documentation](https://www.remotion.dev/docs/series)\n */\nconst Series = ({ children }) => {\n    const childrenValue = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        let startFrame = 0;\n        const flattenedChildren = flattenChildren(children);\n        return react__WEBPACK_IMPORTED_MODULE_0__.Children.map(flattenedChildren, (child, i) => {\n            var _a;\n            const castedChild = child;\n            if (typeof castedChild === 'string') {\n                // Don't throw if it's just some accidential whitespace\n                if (castedChild.trim() === '') {\n                    return null;\n                }\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as it's children, but you passed a string \"${castedChild}\"`);\n            }\n            if (castedChild.type !== SeriesSequence) {\n                throw new TypeError(`The <Series /> component only accepts a list of <Series.Sequence /> components as it's children, but got ${castedChild} instead`);\n            }\n            const debugInfo = `index = ${i}, duration = ${castedChild.props.durationInFrames}`;\n            if (!(castedChild === null || castedChild === void 0 ? void 0 : castedChild.props.children)) {\n                throw new TypeError(`A <Series.Sequence /> component (${debugInfo}) was detected to not have any children. Delete it to fix this error.`);\n            }\n            const durationInFramesProp = castedChild.props.durationInFrames;\n            const { durationInFrames, children: _children, from, ...passedProps } = castedChild.props; // `from` is not accepted and must be filtered out if used in JS\n            if (i !== flattenedChildren.length - 1 ||\n                durationInFramesProp !== Infinity) {\n                validateDurationInFrames(durationInFramesProp, {\n                    component: `of a <Series.Sequence /> component`,\n                    allowFloats: true,\n                });\n            }\n            const offset = (_a = castedChild.props.offset) !== null && _a !== void 0 ? _a : 0;\n            if (Number.isNaN(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must not be NaN, but got NaN (${debugInfo}).`);\n            }\n            if (!Number.isFinite(offset)) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            if (offset % 1 !== 0) {\n                throw new TypeError(`The \"offset\" property of a <Series.Sequence /> must be finite, but got ${offset} (${debugInfo}).`);\n            }\n            const currentStartFrame = startFrame + offset;\n            startFrame += durationInFramesProp + offset;\n            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, { from: currentStartFrame, durationInFrames: durationInFramesProp, ...passedProps, ref: castedChild.ref, children: child }));\n        });\n    }, [children]);\n    /* eslint-disable react/jsx-no-useless-fragment */\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.Fragment, { children: childrenValue });\n};\nSeries.Sequence = SeriesSequence;\n\nconst validateSpringDuration = (dur) => {\n    if (typeof dur === 'undefined') {\n        return;\n    }\n    if (typeof dur !== 'number') {\n        throw new TypeError(`A \"duration\" of a spring must be a \"number\" but is \"${typeof dur}\"`);\n    }\n    if (Number.isNaN(dur)) {\n        throw new TypeError('A \"duration\" of a spring is NaN, which it must not be');\n    }\n    if (!Number.isFinite(dur)) {\n        throw new TypeError('A \"duration\" of a spring must be finite, but is ' + dur);\n    }\n    if (dur <= 0) {\n        throw new TypeError('A \"duration\" of a spring must be positive, but is ' + dur);\n    }\n};\n\nconst defaultSpringConfig = {\n    damping: 10,\n    mass: 1,\n    stiffness: 100,\n    overshootClamping: false,\n};\nconst advanceCache = {};\nfunction advance({ animation, now, config, }) {\n    const { toValue, lastTimestamp, current, velocity } = animation;\n    const deltaTime = Math.min(now - lastTimestamp, 64);\n    const c = config.damping;\n    const m = config.mass;\n    const k = config.stiffness;\n    const cacheKey = [\n        toValue,\n        lastTimestamp,\n        current,\n        velocity,\n        c,\n        m,\n        k,\n        now,\n    ].join('-');\n    if (advanceCache[cacheKey]) {\n        return advanceCache[cacheKey];\n    }\n    const v0 = -velocity;\n    const x0 = toValue - current;\n    const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n    const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n    const omega1 = omega0 * Math.sqrt(1 - zeta ** 2); // exponential decay\n    const t = deltaTime / 1000;\n    const sin1 = Math.sin(omega1 * t);\n    const cos1 = Math.cos(omega1 * t);\n    // under damped\n    const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n    const underDampedFrag1 = underDampedEnvelope *\n        (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n    const underDampedPosition = toValue - underDampedFrag1;\n    // This looks crazy -- it's actually just the derivative of the oscillation function\n    const underDampedVelocity = zeta * omega0 * underDampedFrag1 -\n        underDampedEnvelope *\n            (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n    // critically damped\n    const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n    const criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n    const criticallyDampedVelocity = criticallyDampedEnvelope *\n        (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n    const animationNode = {\n        toValue,\n        prevPosition: current,\n        lastTimestamp: now,\n        current: zeta < 1 ? underDampedPosition : criticallyDampedPosition,\n        velocity: zeta < 1 ? underDampedVelocity : criticallyDampedVelocity,\n    };\n    advanceCache[cacheKey] = animationNode;\n    return animationNode;\n}\nconst calculationCache = {};\nfunction springCalculation({ from = 0, to = 1, frame, fps, config = {}, }) {\n    const cacheKey = [\n        from,\n        to,\n        frame,\n        fps,\n        config.damping,\n        config.mass,\n        config.overshootClamping,\n        config.stiffness,\n    ].join('-');\n    if (calculationCache[cacheKey]) {\n        return calculationCache[cacheKey];\n    }\n    let animation = {\n        lastTimestamp: 0,\n        current: from,\n        toValue: to,\n        velocity: 0,\n        prevPosition: 0,\n    };\n    const frameClamped = Math.max(0, frame);\n    const unevenRest = frameClamped % 1;\n    for (let f = 0; f <= Math.floor(frameClamped); f++) {\n        if (f === Math.floor(frameClamped)) {\n            f += unevenRest;\n        }\n        const time = (f / fps) * 1000;\n        animation = advance({\n            animation,\n            now: time,\n            config: {\n                ...defaultSpringConfig,\n                ...config,\n            },\n        });\n    }\n    calculationCache[cacheKey] = animation;\n    return animation;\n}\n\n/**\n * @description The function returns how long it takes for a spring animation to settle\n * @see [Documentation](https://www.remotion.dev/docs/measure-spring)\n */\nfunction measureSpring({ fps, config = {}, threshold = 0.005, from = 0, to = 1, }) {\n    if (typeof threshold !== 'number') {\n        throw new TypeError(`threshold must be a number, got ${threshold} of type ${typeof threshold}`);\n    }\n    if (threshold === 0) {\n        return Infinity;\n    }\n    if (threshold === 1) {\n        return 0;\n    }\n    if (isNaN(threshold)) {\n        throw new TypeError('Threshold is NaN');\n    }\n    if (!Number.isFinite(threshold)) {\n        throw new TypeError('Threshold is not finite');\n    }\n    if (threshold < 0) {\n        throw new TypeError('Threshold is below 0');\n    }\n    validateFps(fps, 'to the measureSpring() function', false);\n    const range = Math.abs(from - to);\n    let frame = 0;\n    let finishedFrame = 0;\n    const calc = () => {\n        return springCalculation({\n            fps,\n            frame,\n            config,\n            from,\n            to,\n        });\n    };\n    let animation = calc();\n    const calcDifference = () => {\n        return (Math.abs(animation.current - animation.toValue) /\n            (range === 0 ? 1 : range));\n    };\n    let difference = calcDifference();\n    while (difference >= threshold) {\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n    }\n    // Since spring is bouncy, just because it's under the threshold we\n    // cannot be sure it's done. We need to animate further until it stays in the\n    // threshold for, say, 20 frames.\n    finishedFrame = frame;\n    for (let i = 0; i < 20; i++) {\n        frame++;\n        animation = calc();\n        difference = calcDifference();\n        if (difference >= threshold) {\n            i = 0;\n            finishedFrame = frame + 1;\n        }\n    }\n    return finishedFrame;\n}\n\n/**\n * @description Calculates a position based on physical parameters, start and end value, and time.\n * @see [Documentation](https://www.remotion.dev/docs/spring)\n * @param {number} frame The current time value. Most of the time you want to pass in the return value of useCurrentFrame.\n * @param {number} fps The framerate at which the animation runs. Pass in the value obtained by `useVideoConfig()`.\n * @param {?boolean} reverse Whether the animation plays in reverse or not. Default `false`.\n * @param {?Object} config optional object that allows you to customize the physical properties of the animation.\n * @param {number} [config.mass=1] The weight of the spring. If you reduce the mass, the animation becomes faster!\n * @param {number} [config.damping=10] How hard the animation decelerates.\n * @param {number} [config.stiffness=100] Affects bounciness of the animation.\n * @param {boolean} [config.overshootClamping=false] Whether to prevent the animation going beyond the target value.\n * @param {?number} [config.from] The initial value of the animation. Default `0`\n * @param {?number} [config.to] The end value of the animation. Default `1`\n * @param {?number} [config.durationInFrames] Stretch the duration of an animation to  a set value.. Default `undefined`\n * @param {?number} [config.durationThreshold] How close to the end the animation is considered to be done. Default `0.005`\n * @param {?number} [config.delay] Delay the animation for this amount of frames. Default `0`\n */\nfunction spring({ frame: passedFrame, fps, config = {}, from = 0, to = 1, durationInFrames: passedDurationInFrames, durationRestThreshold, delay = 0, reverse = false, }) {\n    validateSpringDuration(passedDurationInFrames);\n    validateFrame({\n        frame: passedFrame,\n        durationInFrames: Infinity,\n        allowFloats: true,\n    });\n    validateFps(fps, 'to spring()', false);\n    const needsToCalculateNaturalDuration = reverse || typeof passedDurationInFrames !== 'undefined';\n    const naturalDuration = needsToCalculateNaturalDuration\n        ? measureSpring({\n            fps,\n            config,\n            from,\n            to,\n            threshold: durationRestThreshold,\n        })\n        : undefined;\n    const naturalDurationGetter = needsToCalculateNaturalDuration\n        ? {\n            get: () => naturalDuration,\n        }\n        : {\n            get: () => {\n                throw new Error('did not calculate natural duration, this is an error with Remotion. Please report');\n            },\n        };\n    const frame = (reverse\n        ? (passedDurationInFrames !== null && passedDurationInFrames !== void 0 ? passedDurationInFrames : naturalDurationGetter.get()) - passedFrame\n        : passedFrame) - (reverse ? -delay : delay);\n    const spr = springCalculation({\n        fps,\n        frame: passedDurationInFrames === undefined\n            ? frame\n            : frame / (passedDurationInFrames / naturalDurationGetter.get()),\n        config,\n        from,\n        to,\n    });\n    if (!config.overshootClamping) {\n        return spr.current;\n    }\n    if (to >= from) {\n        return Math.min(spr.current, to);\n    }\n    return Math.max(spr.current, to);\n}\n\n/**\n * @description A `<Still />` is a `<Composition />` that is only 1 frame long.\n * @see [Documentation](https://www.remotion.dev/docs/still)\n */\nconst Still = (props) => {\n    const newProps = {\n        ...props,\n        durationInFrames: 1,\n        fps: 1,\n    };\n    // @ts-expect-error TypeScript does not understand it, but should still fail on type mismatch\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement((Composition), newProps);\n};\n\nconst OffthreadVideoForRendering = ({ onError, volume: volumeProp, playbackRate, src, muted, allowAmplificationDuringRender, transparent = false, toneFrequency, ...props }) => {\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp();\n    const videoConfig = useUnsafeVideoConfig();\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    if (!src) {\n        throw new TypeError('No `src` was passed to <OffthreadVideo>.');\n    }\n    // Generate a string that's as unique as possible for this asset\n    // but at the same time the same on all threads\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => `offthreadvideo-${random(src !== null && src !== void 0 ? src : '')}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames}`, [\n        src,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames,\n    ]);\n    if (!videoConfig) {\n        throw new Error('No video config found');\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!src) {\n            throw new Error('No src passed');\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        if (muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        registerRenderAsset({\n            type: 'video',\n            src: getAbsoluteSrc(src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate !== null && playbackRate !== void 0 ? playbackRate : 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n            toneFrequency: toneFrequency !== null && toneFrequency !== void 0 ? toneFrequency : null,\n        });\n        return () => unregisterRenderAsset(id);\n    }, [\n        muted,\n        src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n    ]);\n    const currentTime = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return (getExpectedMediaFrameUncorrected({\n            frame,\n            playbackRate: playbackRate || 1,\n            startFrom: -mediaStartsAt,\n        }) / videoConfig.fps);\n    }, [frame, mediaStartsAt, playbackRate, videoConfig.fps]);\n    const actualSrc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return `http://localhost:${window.remotion_proxyPort}/proxy?src=${encodeURIComponent(getAbsoluteSrc(src))}&time=${encodeURIComponent(currentTime)}&transparent=${String(transparent)}`;\n    }, [currentTime, src, transparent]);\n    const onErr = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((e) => {\n        if (onError) {\n            onError === null || onError === void 0 ? void 0 : onError(e);\n        }\n        else {\n            cancelRender('Failed to load image with src ' + actualSrc);\n        }\n    }, [actualSrc, onError]);\n    const className = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        return [OFFTHREAD_VIDEO_CLASS_NAME, props.className]\n            .filter(truthy)\n            .join(' ');\n    }, [props.className]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Img, { src: actualSrc, className: className, ...props, onError: onErr }));\n};\n\nconst VideoForDevelopmentRefForwardingFunction = (props, ref) => {\n    var _a, _b;\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const volumePropFrame = useFrameForVolumeProp();\n    const { fps, durationInFrames } = useVideoConfig();\n    const parentSequence = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const { volume, muted, playbackRate, onlyWarnForMediaSeekingError, src, onDuration, \n    // @ts-expect-error\n    acceptableTimeShift, acceptableTimeShiftInSeconds, toneFrequency, ...nativeProps } = props;\n    if (typeof acceptableTimeShift !== 'undefined') {\n        throw new Error('acceptableTimeShift has been removed. Use acceptableTimeShiftInSeconds instead.');\n    }\n    const actualVolume = useMediaTagVolume(videoRef);\n    const [mediaVolume] = useMediaVolumeState();\n    const [mediaMuted] = useMediaMutedState();\n    useMediaInTimeline({\n        mediaRef: videoRef,\n        volume,\n        mediaVolume,\n        mediaType: 'video',\n        src,\n        playbackRate: (_a = props.playbackRate) !== null && _a !== void 0 ? _a : 1,\n    });\n    useSyncVolumeWithMediaTag({\n        volumePropFrame,\n        actualVolume,\n        volume,\n        mediaVolume,\n        mediaRef: videoRef,\n    });\n    useMediaPlayback({\n        mediaRef: videoRef,\n        src,\n        mediaType: 'video',\n        playbackRate: (_b = props.playbackRate) !== null && _b !== void 0 ? _b : 1,\n        onlyWarnForMediaSeekingError,\n        acceptableTimeshift: acceptableTimeShiftInSeconds !== null && acceptableTimeShiftInSeconds !== void 0 ? acceptableTimeShiftInSeconds : DEFAULT_ACCEPTABLE_TIMESHIFT,\n    });\n    const actualFrom = parentSequence\n        ? parentSequence.relativeFrom + parentSequence.cumulatedFrom\n        : 0;\n    const duration = parentSequence\n        ? Math.min(parentSequence.durationInFrames, durationInFrames)\n        : durationInFrames;\n    const actualSrc = useAppendVideoFragment({\n        actualSrc: usePreload(src),\n        actualFrom,\n        duration,\n        fps,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const errorHandler = () => {\n            var _a;\n            if (current === null || current === void 0 ? void 0 : current.error) {\n                console.error('Error occurred in video', current === null || current === void 0 ? void 0 : current.error);\n                // If user is handling the error, we don't cause an unhandled exception\n                if (props.onError) {\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${src}: Code ${current.error.code} - ${(_a = current === null || current === void 0 ? void 0 : current.error) === null || _a === void 0 ? void 0 : _a.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            }\n            else {\n                throw new Error('The browser threw an error');\n            }\n        };\n        current.addEventListener('error', errorHandler, { once: true });\n        return () => {\n            current.removeEventListener('error', errorHandler);\n        };\n    }, [props.onError, src]);\n    const currentOnDurationCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    currentOnDurationCallback.current = onDuration;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        if (current.duration) {\n            (_a = currentOnDurationCallback.current) === null || _a === void 0 ? void 0 : _a.call(currentOnDurationCallback, src, current.duration);\n            return;\n        }\n        const onLoadedMetadata = () => {\n            var _a;\n            (_a = currentOnDurationCallback.current) === null || _a === void 0 ? void 0 : _a.call(currentOnDurationCallback, src, current.duration);\n        };\n        current.addEventListener('loadedmetadata', onLoadedMetadata);\n        return () => {\n            current.removeEventListener('loadedmetadata', onLoadedMetadata);\n        };\n    }, [src]);\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", { ref: videoRef, \n        // Without this, on iOS Safari, the video cannot be seeked.\n        // if a seek is triggered before `loadedmetadata` is fired,\n        // the video will not seek, even if `loadedmetadata` is fired afterwards.\n        preload: isIosSafari() ? 'metadata' : 'auto', muted: muted || mediaMuted, playsInline: true, src: actualSrc, ...nativeProps }));\n};\n// Copy types from forwardRef but not necessary to remove ref\nconst VideoForDevelopment = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForDevelopmentRefForwardingFunction);\n\n/**\n * @description This method imports and displays a video, similar to <Video />. During rendering, it extracts the exact frame from the video and displays it in an <img> tag\n * @see [Documentation](https://www.remotion.dev/docs/offthreadvideo)\n */\nconst OffthreadVideo = (props) => {\n    // Should only destruct `startFrom` and `endAt` from props,\n    // rest gets drilled down\n    const { startFrom, endAt, ...otherProps } = props;\n    const environment = getRemotionEnvironment();\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => undefined, []);\n    if (typeof props.src !== 'string') {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    if (props.imageFormat) {\n        throw new TypeError(`The \\`<OffthreadVideo>\\` tag does no longer accept \\`imageFormat\\`. Use the \\`transparent\\` prop if you want to render a transparent video.`);\n    }\n    if (typeof startFrom !== 'undefined' || typeof endAt !== 'undefined') {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom !== null && startFrom !== void 0 ? startFrom : 0;\n        const endAtFrameNo = endAt !== null && endAt !== void 0 ? endAt : Infinity;\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, { layout: \"none\", from: 0 - startFromFrameNo, showInTimeline: false, durationInFrames: endAtFrameNo, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideo, { ...otherProps }) }));\n    }\n    validateMediaProps(props, 'Video');\n    if (environment.isRendering) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(OffthreadVideoForRendering, { ...otherProps });\n    }\n    const { transparent, ...withoutTransparent } = otherProps;\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForDevelopment, { onDuration: onDuration, onlyWarnForMediaSeekingError: true, ...withoutTransparent }));\n};\n\nconst VideoForRenderingForwardFunction = ({ onError, volume: volumeProp, allowAmplificationDuringRender, playbackRate, onDuration, toneFrequency, ...props }, ref) => {\n    const absoluteFrame = useTimelinePosition();\n    const frame = useCurrentFrame();\n    const volumePropsFrame = useFrameForVolumeProp();\n    const videoConfig = useUnsafeVideoConfig();\n    const videoRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const sequenceContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SequenceContext);\n    const mediaStartsAt = useMediaStartsAt();\n    const environment = getRemotionEnvironment();\n    const { registerRenderAsset, unregisterRenderAsset } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(RenderAssetManager);\n    // Generate a string that's as unique as possible for this asset\n    // but at the same time the same on all threads\n    const id = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        var _a;\n        return `video-${random((_a = props.src) !== null && _a !== void 0 ? _a : '')}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom}-${sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames}`;\n    }, [\n        props.src,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.cumulatedFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.relativeFrom,\n        sequenceContext === null || sequenceContext === void 0 ? void 0 : sequenceContext.durationInFrames,\n    ]);\n    if (!videoConfig) {\n        throw new Error('No video config found');\n    }\n    const volume = evaluateVolume({\n        volume: volumeProp,\n        frame: volumePropsFrame,\n        mediaVolume: 1,\n        allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!props.src) {\n            throw new Error('No src passed');\n        }\n        if (props.muted) {\n            return;\n        }\n        if (volume <= 0) {\n            return;\n        }\n        if (!window.remotion_audioEnabled) {\n            return;\n        }\n        registerRenderAsset({\n            type: 'video',\n            src: getAbsoluteSrc(props.src),\n            id,\n            frame: absoluteFrame,\n            volume,\n            mediaFrame: frame,\n            playbackRate: playbackRate !== null && playbackRate !== void 0 ? playbackRate : 1,\n            allowAmplificationDuringRender: allowAmplificationDuringRender !== null && allowAmplificationDuringRender !== void 0 ? allowAmplificationDuringRender : false,\n            toneFrequency: toneFrequency !== null && toneFrequency !== void 0 ? toneFrequency : null,\n        });\n        return () => unregisterRenderAsset(id);\n    }, [\n        props.muted,\n        props.src,\n        registerRenderAsset,\n        id,\n        unregisterRenderAsset,\n        volume,\n        frame,\n        absoluteFrame,\n        playbackRate,\n        allowAmplificationDuringRender,\n        toneFrequency,\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, () => {\n        return videoRef.current;\n    }, []);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!window.remotion_videoEnabled) {\n            return;\n        }\n        const { current } = videoRef;\n        if (!current) {\n            return;\n        }\n        const currentTime = (() => {\n            return getMediaTime({\n                fps: videoConfig.fps,\n                frame,\n                src: props.src,\n                playbackRate: playbackRate || 1,\n                startFrom: -mediaStartsAt,\n                mediaType: 'video',\n            });\n        })();\n        const handle = delayRender(`Rendering <Video /> with src=\"${props.src}\"`);\n        if (false) {}\n        if (isApproximatelyTheSame(current.currentTime, currentTime)) {\n            if (current.readyState >= 2) {\n                continueRender(handle);\n                return;\n            }\n            const loadedDataHandler = () => {\n                continueRender(handle);\n            };\n            current.addEventListener('loadeddata', loadedDataHandler, { once: true });\n            return () => {\n                current.removeEventListener('loadeddata', loadedDataHandler);\n            };\n        }\n        current.currentTime = currentTime;\n        const seekedHandler = () => {\n            warnAboutNonSeekableMedia(current, 'exception');\n            if (window.navigator.platform.startsWith('Mac')) {\n                // Improve me: This is ensures frame perfectness but slows down render.\n                // Please see this issue for context: https://github.com/remotion-dev/remotion/issues/200\n                // Only affects macOS since it uses VideoToolbox decoding.\n                setTimeout(() => {\n                    continueRender(handle);\n                }, 100);\n            }\n            else {\n                continueRender(handle);\n            }\n        };\n        current.addEventListener('seeked', seekedHandler, { once: true });\n        const endedHandler = () => {\n            continueRender(handle);\n        };\n        current.addEventListener('ended', endedHandler, { once: true });\n        const errorHandler = () => {\n            var _a;\n            if (current === null || current === void 0 ? void 0 : current.error) {\n                console.error('Error occurred in video', current === null || current === void 0 ? void 0 : current.error);\n                // If user is handling the error, we don't cause an unhandled exception\n                if (onError) {\n                    return;\n                }\n                throw new Error(`The browser threw an error while playing the video ${props.src}: Code ${current.error.code} - ${(_a = current === null || current === void 0 ? void 0 : current.error) === null || _a === void 0 ? void 0 : _a.message}. See https://remotion.dev/docs/media-playback-error for help. Pass an onError() prop to handle the error.`);\n            }\n            else {\n                throw new Error('The browser threw an error');\n            }\n        };\n        current.addEventListener('error', errorHandler, { once: true });\n        // If video skips to another frame or unmounts, we clear the created handle\n        return () => {\n            current.removeEventListener('ended', endedHandler);\n            current.removeEventListener('error', errorHandler);\n            current.removeEventListener('seeked', seekedHandler);\n            continueRender(handle);\n        };\n    }, [\n        volumePropsFrame,\n        props.src,\n        playbackRate,\n        videoConfig.fps,\n        frame,\n        mediaStartsAt,\n        onError,\n    ]);\n    const { src } = props;\n    // If video source switches, make new handle\n    if (environment.isRendering) {\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n            if (false) {}\n            const newHandle = delayRender('Loading <Video> duration with src=' + src);\n            const { current } = videoRef;\n            const didLoad = () => {\n                if (current === null || current === void 0 ? void 0 : current.duration) {\n                    onDuration(src, current.duration);\n                }\n                continueRender(newHandle);\n            };\n            if (current === null || current === void 0 ? void 0 : current.duration) {\n                onDuration(src, current.duration);\n                continueRender(newHandle);\n            }\n            else {\n                current === null || current === void 0 ? void 0 : current.addEventListener('loadedmetadata', didLoad, { once: true });\n            }\n            // If tag gets unmounted, clear pending handles because video metadata is not going to load\n            return () => {\n                current === null || current === void 0 ? void 0 : current.removeEventListener('loadedmetadata', didLoad);\n                continueRender(newHandle);\n            };\n        }, [src, onDuration]);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(\"video\", { ref: videoRef, ...props, onError: onError });\n};\nconst VideoForRendering = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(VideoForRenderingForwardFunction);\n\nconst VideoForwardingFunction = (props, ref) => {\n    var _a;\n    const { startFrom, endAt, ...otherProps } = props;\n    const { loop, ...propsOtherThanLoop } = props;\n    const { fps } = useVideoConfig();\n    const environment = getRemotionEnvironment();\n    const { durations, setDurations } = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(DurationsContext);\n    if (typeof ref === 'string') {\n        throw new Error('string refs are not supported');\n    }\n    if (typeof props.src !== 'string') {\n        throw new TypeError(`The \\`<Video>\\` tag requires a string for \\`src\\`, but got ${JSON.stringify(props.src)} instead.`);\n    }\n    const onDuration = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((src, durationInSeconds) => {\n        setDurations({ type: 'got-duration', durationInSeconds, src });\n    }, [setDurations]);\n    if (loop && props.src && durations[getAbsoluteSrc(props.src)] !== undefined) {\n        const mediaDuration = durations[getAbsoluteSrc(props.src)] * fps;\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Loop, { durationInFrames: calculateLoopDuration({\n                endAt,\n                mediaDuration,\n                playbackRate: (_a = props.playbackRate) !== null && _a !== void 0 ? _a : 1,\n                startFrom,\n            }), layout: \"none\", children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, { ...propsOtherThanLoop, ref: ref }) }));\n    }\n    if (typeof startFrom !== 'undefined' || typeof endAt !== 'undefined') {\n        validateStartFromProps(startFrom, endAt);\n        const startFromFrameNo = startFrom !== null && startFrom !== void 0 ? startFrom : 0;\n        const endAtFrameNo = endAt !== null && endAt !== void 0 ? endAt : Infinity;\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Sequence, { layout: \"none\", from: 0 - startFromFrameNo, showInTimeline: false, durationInFrames: endAtFrameNo, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(Video, { ...otherProps, ref: ref }) }));\n    }\n    validateMediaProps(props, 'Video');\n    if (environment.isRendering) {\n        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForRendering, { onDuration: onDuration, ...otherProps, ref: ref }));\n    }\n    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(VideoForDevelopment, { onlyWarnForMediaSeekingError: false, ...otherProps, ref: ref, onDuration: onDuration }));\n};\nconst forward = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef;\n/**\n * @description allows you to include a video file in your Remotion project. It wraps the native HTMLVideoElement.\n * @see [Documentation](https://www.remotion.dev/docs/video)\n */\nconst Video = forward(VideoForwardingFunction);\n\ncheckMultipleRemotionVersions();\nconst Experimental = {\n    /**\n     * @description This is a special component that will cause Remotion to only partially capture the frame of the video.\n     * @see [Documentation](https://www.remotion.dev/docs/clipper)\n     */\n    Clipper,\n    /**\n     * @description This is a special component, that, when rendered, will skip rendering the frame altogether.\n     * @see [Documentation](https://www.remotion.dev/docs/null)\n     */\n    Null,\n    useIsPlayer,\n};\nconst proxyObj = {};\nconst Config = new Proxy(proxyObj, {\n    get(_, prop) {\n        if (prop === 'Bundling' ||\n            prop === 'Rendering' ||\n            prop === 'Log' ||\n            prop === 'Puppeteer' ||\n            prop === 'Output') {\n            return Config;\n        }\n        return () => {\n            console.warn('⚠️  The CLI configuration has been extracted from Remotion Core.');\n            console.warn('Update the import from the config file:');\n            console.warn();\n            console.warn('- Delete:');\n            console.warn('import {Config} from \"remotion\";');\n            console.warn('+ Replace:');\n            console.warn('import {Config} from \"@remotion/cli/config\";');\n            console.warn();\n            console.warn('For more information, see https://www.remotion.dev/docs/4-0-migration.');\n            process.exit(1);\n        };\n    },\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVtb3Rpb25ANC4wLjQ3X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlOO0FBQ2pLO0FBQ2Y7O0FBRXpDLDRCQUE0QixvREFBYTtBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQztBQUNELGdDQUFnQyxXQUFXO0FBQzNDLHdDQUF3QywrQ0FBUTtBQUNoRCxvQkFBb0IsOENBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFFBQVEsc0RBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsWUFBWSxzREFBRyxpQ0FBaUMsb0NBQW9DO0FBQ3BGOztBQUVBLG1CQUFtQixxQkFBcUI7QUFDeEMsWUFBWSxnQkFBZ0IsRUFBRSxpREFBVTtBQUN4QyxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLHdCQUF3QixvREFBYTtBQUNyQyxtQ0FBbUMsV0FBVztBQUM5QyxXQUFXLHNEQUFHLDZCQUE2QixpQ0FBaUM7QUFDNUU7QUFDQTtBQUNBLFdBQVcsaURBQVU7QUFDckI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLE1BQU07QUFDM0M7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Ysc0JBQXNCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDZCQUE2QjtBQUNyRCw2QkFBNkIsK0NBQVE7QUFDckMsOEJBQThCLCtDQUFRLEdBQUc7QUFDekMsa0NBQWtDLCtDQUFRO0FBQzFDLDhCQUE4Qiw2Q0FBTTtBQUNwQyw4Q0FBOEMsK0NBQVE7QUFDdEQsNENBQTRDLCtDQUFRO0FBQ3BELDhCQUE4Qiw2Q0FBTTtBQUNwQztBQUNBO0FBQ0EsUUFBUSxzREFBZTtBQUN2QjtBQUNBLHVFQUF1RSxFQUFFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxpQ0FBaUMsOENBQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9DQUFvQyw4Q0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCx5QkFBeUIsOENBQU87QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2IsWUFBWSxJQUF5QztBQUNyRCxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxzREFBRywwQkFBMEIsK0JBQStCLHNEQUFHLDZCQUE2Qix1Q0FBdUMsc0RBQUcsZ0NBQWdDLDBDQUEwQyxzREFBRyx3QkFBd0IsVUFBVSxzREFBRyxxQkFBcUIsVUFBVSxzREFBRyx5QkFBeUIsVUFBVSxzREFBRywrQkFBK0IsZ0RBQWdELHNEQUFHLDZCQUE2QixvQkFBb0IsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztBQUNwZTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0NBQWdDLGFBQW9CO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEseUJBQXlCLHVDQUF1QztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxNQUFNO0FBQ2xGO0FBQ0E7QUFDQSxzQ0FBc0MsT0FBTztBQUM3QztBQUNBO0FBQ0EsK0VBQStFLE1BQU07QUFDckY7QUFDQTtBQUNBLGlEQUFpRCxNQUFNLCtCQUErQixpQkFBaUIsdURBQXVELGtCQUFrQjtBQUNoTDtBQUNBO0FBQ0EsaURBQWlELE1BQU0sK0JBQStCLGlCQUFpQix3REFBd0QscUJBQXFCO0FBQ3BMO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsNkNBQWdCO0FBQ2xELDRCQUE0Qiw2Q0FBZ0I7QUFDNUMsK0JBQStCLDZDQUFnQjtBQUMvQyw0QkFBNEIsNkNBQWdCO0FBQzVDLHlCQUF5Qiw2Q0FBZ0I7QUFDekMsdUNBQXVDLDZDQUFnQjtBQUN2RCxnQ0FBZ0MsNkNBQWdCO0FBQ2hELDJCQUEyQiw2Q0FBZ0I7QUFDM0Msc0NBQXNDLDZDQUFnQjtBQUN0RCxzQ0FBc0MsNkNBQWdCO0FBQ3RELG1DQUFtQyw2Q0FBZ0I7QUFDbkQsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQyxZQUFZLHNEQUFHLGlDQUFpQyxzREFBc0Qsc0RBQUcsMEJBQTBCLHdDQUF3QyxzREFBRyxpQ0FBaUMsK0NBQStDLHNEQUFHLDRCQUE0QiwwQ0FBMEMsc0RBQUcsZ0NBQWdDLGlEQUFpRCxzREFBRyw2QkFBNkIsa0RBQWtELHNEQUFHLGdDQUFnQyxxREFBcUQsc0RBQUcsdUNBQXVDLHFEQUFxRCxzREFBRyw2QkFBNkIsMkNBQTJDLHNEQUFHLGdDQUFnQyw4Q0FBOEMsc0RBQUcsNkJBQTZCLHFEQUFxRCxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHO0FBQ243Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDJDQUFjO0FBQ3hDO0FBQ0EsMkJBQTJCLDJDQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsK0NBQStDLFVBQVU7QUFDekQ7QUFDQTtBQUNBLFdBQVcsc0RBQUcsQ0FBQyx1REFBUSxJQUFJLG9CQUFvQjtBQUMvQztBQUNBLHVCQUF1QixpREFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCLDBCQUEwQiw4Q0FBTztBQUNqQztBQUNBO0FBQ0EsZUFBZSwyQ0FBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlLQUFpSyxZQUFZO0FBQzdLO0FBQ0E7QUFDQSxnSkFBZ0osYUFBYTtBQUM3SjtBQUNBLHlDQUF5QyxFQUFFLGVBQWUsbUNBQW1DO0FBQzdGO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBLG9CQUFvQiw4REFBOEQscUJBQXFCO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILFVBQVU7QUFDOUg7QUFDQTtBQUNBLDhHQUE4RyxRQUFRLEdBQUcsVUFBVTtBQUNuSTtBQUNBO0FBQ0EsOEdBQThHLFFBQVEsR0FBRyxVQUFVO0FBQ25JO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzREFBRyxhQUFhLHdIQUF3SDtBQUM1SixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EsV0FBVyxzREFBRyxDQUFDLHVEQUFRLElBQUkseUJBQXlCO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixXQUFXO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDLFlBQVksNENBQTRDO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLHFDQUFxQztBQUNyQyxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIseUNBQXlDLEdBQUc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsK0JBQStCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnQkFBZ0Isd0NBQXdDO0FBQ2pGO0FBQ0EsK0RBQStELFdBQVcsVUFBVSxpQkFBaUI7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0Esa0JBQWtCLG9DQUFvQyxrSEFBa0g7QUFDeEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnREFBbUI7QUFDOUI7O0FBRUEsc0NBQXNDLHFJQUFxSTtBQUMzSztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpREFBVTtBQUN0QztBQUNBLFlBQVksNkNBQTZDLEVBQUUsaURBQVU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOENBQU8seUJBQXlCLGtEQUFrRCxHQUFHLGdHQUFnRyxHQUFHLCtGQUErRixHQUFHLG1HQUFtRztBQUM1WTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDhDQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxzQkFBc0IsOENBQU87QUFDN0IsbUNBQW1DLDBCQUEwQixhQUFhLHdDQUF3QyxRQUFRLGdDQUFnQyxlQUFlLG9CQUFvQjtBQUM3TCxLQUFLO0FBQ0wsa0JBQWtCLGtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0IsOENBQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksc0RBQUcsUUFBUSxnRUFBZ0U7QUFDdkY7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiw2Q0FBTTtBQUMzQjtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDLDJCQUEyQixpREFBVTtBQUNyQyxZQUFZO0FBQ1o7QUFDQSx1RkFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSwwREFBbUI7QUFDdkI7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsSUFBSSxTQUFTLG9CQUFvQixJQUFJLHVIQUF1SDtBQUNsUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNDQUFzQyw2Q0FBTTtBQUM1QztBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLHNEQUFHLFlBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0EscUlBQXFJO0FBQ3JJO0FBQ0E7QUFDQSw0QkFBNEIsaURBQVU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQSx1QkFBdUIsa0RBQVc7QUFDbEM7QUFDQSxtR0FBbUcsMkJBQTJCO0FBQzlIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQUcsYUFBYSw2R0FBNkcsc0RBQUcsbUJBQW1CLGVBQWUsR0FBRztBQUNyTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFHLCtCQUErQixlQUFlO0FBQ2hFO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxzREFBRyx3QkFBd0IsbUZBQW1GO0FBQzFIOztBQUVBLDRDQUE0QyxnSEFBZ0g7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNkNBQU07QUFDM0IsNEJBQTRCLGlEQUFVO0FBQ3RDO0FBQ0E7QUFDQSxZQUFZLDZDQUE2QyxFQUFFLGlEQUFVO0FBQ3JFO0FBQ0E7QUFDQSxlQUFlLDhDQUFPO0FBQ3RCO0FBQ0Esd0JBQXdCLDZEQUE2RCxHQUFHLGdHQUFnRyxHQUFHLCtGQUErRixHQUFHLG1HQUFtRztBQUNoWSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksMERBQW1CO0FBQ3ZCO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVCxvRUFBb0UsVUFBVTtBQUM5RSxZQUFZLEtBQStCLEVBQUUsRUFHcEM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFlBQVk7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCxZQUFZO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsVUFBVSxTQUFTLG9CQUFvQixJQUFJLHVIQUF1SDtBQUN4UDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFlBQVk7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxRQUFRLHNEQUFlO0FBQ3ZCLGdCQUFnQixLQUErQixFQUFFLEVBRXBDO0FBQ2I7QUFDQSxvQkFBb0IsVUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdILFlBQVk7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsV0FBVyxzREFBRyxZQUFZLDJDQUEyQztBQUNyRTtBQUNBLDBCQUEwQixpREFBVTs7QUFFcEM7QUFDQTtBQUNBLFlBQVksa0NBQWtDO0FBQzlDLFlBQVksOEJBQThCO0FBQzFDLFlBQVksTUFBTTtBQUNsQjtBQUNBLFlBQVksMEJBQTBCLEVBQUUsaURBQVU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEYsMkJBQTJCO0FBQ3JIO0FBQ0EsdUJBQXVCLGtEQUFXO0FBQ2xDLHVCQUF1Qiw4Q0FBOEM7QUFDckUsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0Isc0RBQUcsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNkJBQTZCLHNEQUFHLFVBQVUsaUNBQWlDLEdBQUc7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBRyxhQUFhLDZHQUE2RyxzREFBRyxVQUFVLHlCQUF5QixHQUFHO0FBQ3RMO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBRyxzQkFBc0IsaURBQWlEO0FBQzFGO0FBQ0EsWUFBWSxzREFBRyx3QkFBd0Isc0ZBQXNGO0FBQzdIO0FBQ0EsZ0JBQWdCLDZDQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxRQUFRLGdCQUFnQjtBQUMxRDtBQUNBLGtDQUFrQyxRQUFRLDRCQUE0QjtBQUN0RTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRXFhIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vcmVtb3Rpb25ANC4wLjQ3X3JlYWN0LWRvbUAxOC4yLjBfcmVhY3RAMTguMi4wL25vZGVfbW9kdWxlcy9yZW1vdGlvbi9kaXN0L2VzbS9pbmRleC5tanM/YzYwYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgY3JlYXRlQ29udGV4dCwgdXNlU3RhdGUsIHVzZU1lbW8sIHVzZUxheW91dEVmZmVjdCwgdXNlQ29udGV4dCwgdXNlRWZmZWN0LCBmb3J3YXJkUmVmLCBDaGlsZHJlbiwgaXNWYWxpZEVsZW1lbnQsIHVzZVJlZiwgdXNlQ2FsbGJhY2ssIGNyZWF0ZVJlZiwgdXNlSW1wZXJhdGl2ZUhhbmRsZSwgdXNlUmVkdWNlciwgU3VzcGVuc2UgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBqc3gsIGpzeHMsIEZyYWdtZW50IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgTmF0aXZlTGF5ZXJzQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIHNldENsaXBSZWdpb246ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmVMYXllcnMgbm90IHNldCcpO1xuICAgIH0sXG4gICAgY2xpcFJlZ2lvbjogbnVsbCxcbn0pO1xuY29uc3QgTmF0aXZlTGF5ZXJzUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIGNvbnN0IFtjbGlwUmVnaW9uLCBzZXRDbGlwUmVnaW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldENsaXBSZWdpb24sXG4gICAgICAgICAgICBjbGlwUmVnaW9uLFxuICAgICAgICB9O1xuICAgIH0sIFtjbGlwUmVnaW9uLCBzZXRDbGlwUmVnaW9uXSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW90aW9uX2dldENsaXBSZWdpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaXBSZWdpb247XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbY2xpcFJlZ2lvbiwgc2V0Q2xpcFJlZ2lvbl0pO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChOYXRpdmVMYXllcnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgQ2xpcHBlciA9ICh7IGhlaWdodCwgd2lkdGgsIHgsIHkgfSkgPT4ge1xuICAgIGNvbnN0IHsgc2V0Q2xpcFJlZ2lvbiB9ID0gdXNlQ29udGV4dChOYXRpdmVMYXllcnNDb250ZXh0KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRDbGlwUmVnaW9uKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ2hpZGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVuZGVyIDxDbGlwcGVyPiwgYmVjYXVzZSBhbm90aGVyIDxOdWxsPiBpcyBhbHJlYWR5IHJlbmRlcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlaWdodCwgd2lkdGgsIHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbmRlciA8Q2xpcHBlcj4sIGJlY2F1c2UgYW5vdGhlciBjb21wb25lbnQgY2xpcHBpbmcgdGhlIHJlZ2lvbiB3YXMgYWxyZWFkeSByZW5kZXJlZCAobW9zdCBsaWtlbHkgPENsaXBwZXI+KScpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHNldENsaXBSZWdpb24obnVsbCk7XG4gICAgICAgIH07XG4gICAgfSwgW2hlaWdodCwgc2V0Q2xpcFJlZ2lvbiwgd2lkdGgsIHgsIHldKTtcbiAgICByZXR1cm4gbnVsbDtcbn07XG5cbmNvbnN0IElzUGxheWVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuY29uc3QgSXNQbGF5ZXJDb250ZXh0UHJvdmlkZXIgPSAoeyBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIHJldHVybiBqc3goSXNQbGF5ZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB0cnVlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG59O1xuY29uc3QgdXNlSXNQbGF5ZXIgPSAoKSA9PiB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoSXNQbGF5ZXJDb250ZXh0KTtcbn07XG5cbmZ1bmN0aW9uIHRydXRoeSh2YWx1ZSkge1xuICAgIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn1cblxuLy8gQXV0b21hdGljYWxseSBnZW5lcmF0ZWQgb24gcHVibGlzaFxuY29uc3QgVkVSU0lPTiA9ICc0LjAuNDcnO1xuXG5jb25zdCBjaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYWxyZWFkeUltcG9ydGVkID0gZ2xvYmFsVGhpcy5yZW1vdGlvbl9pbXBvcnRlZCB8fFxuICAgICAgICAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlbW90aW9uX2ltcG9ydGVkKTtcbiAgICBpZiAoYWxyZWFkeUltcG9ydGVkKSB7XG4gICAgICAgIGlmIChhbHJlYWR5SW1wb3J0ZWQgPT09IFZFUlNJT04pIHtcbiAgICAgICAgICAgIC8vIE5leHQuSlMgd2lsbCByZWxvYWQgdGhlIHBhY2thZ2UgYW5kIGNhdXNlIGEgc2VydmVyLXNpZGUgd2FybmluZy5cbiAgICAgICAgICAgIC8vIEl0J3Mgb2theSBpZiB0aGlzIGhhcHBlbnMgZHVyaW5nIFNTUiBpbiBkZXZlbG9wZW1lbnRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGDwn5qoIE11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGRldGVjdGVkOiAke1tcbiAgICAgICAgICAgIFZFUlNJT04sXG4gICAgICAgICAgICB0eXBlb2YgYWxyZWFkeUltcG9ydGVkID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgID8gYWxyZWFkeUltcG9ydGVkXG4gICAgICAgICAgICAgICAgOiAnYW4gb2xkZXIgdmVyc2lvbicsXG4gICAgICAgIF1cbiAgICAgICAgICAgIC5maWx0ZXIodHJ1dGh5KVxuICAgICAgICAgICAgLmpvaW4oJyBhbmQgJyl9LiBUaGlzIHdpbGwgY2F1c2UgdGhpbmdzIHRvIGJyZWFrIGluIGFuIHVuZXhwZWN0ZWQgd2F5LlxcbkNoZWNrIHRoYXQgYWxsIHlvdXIgUmVtb3Rpb24gcGFja2FnZXMgYXJlIG9uIHRoZSBzYW1lIHZlcnNpb24uIElmIHlvdXIgZGVwZW5kZW5jaWVzIGRlcGVuZCBvbiBSZW1vdGlvbiwgbWFrZSB0aGVtIHBlZXIgZGVwZW5kZW5jaWVzLiBZb3UgY2FuIGFsc28gcnVuIFxcYG5weCByZW1vdGlvbiB2ZXJzaW9uc1xcYCBmcm9tIHlvdXIgdGVybWluYWwgdG8gc2VlIHdoaWNoIHZlcnNpb25zIGFyZSBtaXNtYXRjaGluZy5gKTtcbiAgICB9XG4gICAgZ2xvYmFsVGhpcy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdGlvbl9pbXBvcnRlZCA9IFZFUlNJT047XG4gICAgfVxufTtcblxuY29uc3QgTnVsbCA9ICgpID0+IHtcbiAgICBjb25zdCB7IHNldENsaXBSZWdpb24gfSA9IHVzZUNvbnRleHQoTmF0aXZlTGF5ZXJzQ29udGV4dCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0Q2xpcFJlZ2lvbigoYykgPT4ge1xuICAgICAgICAgICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVuZGVyaW5nIG11bHRpcGxlIDxOdWxsPiBpcyBmaW5lLCBiZWNhdXNlIHRoZXkgYXJlIGFsbCBoaWRkZW5cbiAgICAgICAgICAgIGlmIChjID09PSAnaGlkZScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2hpZGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgcmVuZGVyIDxOdWxsPiwgYmVjYXVzZSBhbm90aGVyIGNvbXBvbmVudCBjbGlwcGluZyB0aGUgcmVnaW9uIHdhcyBhbHJlYWR5IHJlbmRlcmVkIChtb3N0IGxpa2VseSA8Q2xpcHBlcj4pJyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc2V0Q2xpcFJlZ2lvbihudWxsKTtcbiAgICAgICAgfTtcbiAgICB9LCBbc2V0Q2xpcFJlZ2lvbl0pO1xuICAgIHJldHVybiBudWxsO1xufTtcblxuY29uc3QgQWJzb2x1dGVGaWxsUmVmRm9yd2FyZGluZyA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgeyBzdHlsZSwgLi4ub3RoZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IGFjdHVhbFN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGJvdHRvbTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAnMTAwJScsXG4gICAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdjb2x1bW4nLFxuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgIH07XG4gICAgfSwgW3N0eWxlXSk7XG4gICAgcmV0dXJuIGpzeChcImRpdlwiLCB7IHJlZjogcmVmLCBzdHlsZTogYWN0dWFsU3R5bGUsIC4uLm90aGVyIH0pO1xufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIEFuIGFic29sdXRlbHkgcG9zaXRpb25lZCA8ZGl2PiBlbGVtZW50IHdpdGggMTAwJSB3aWR0aCwgaGVpZ2h0LCBhbmQgYSBjb2x1bW4gZmxleCBzdHlsZVxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvYWJzb2x1dGUtZmlsbClcbiAqL1xuY29uc3QgQWJzb2x1dGVGaWxsID0gZm9yd2FyZFJlZihBYnNvbHV0ZUZpbGxSZWZGb3J3YXJkaW5nKTtcblxuY29uc3QgZ2V0QWJzb2x1dGVTcmMgPSAocmVsYXRpdmVTcmMpID0+IHtcbiAgICByZXR1cm4gbmV3IFVSTChyZWxhdGl2ZVNyYywgd2luZG93LmxvY2F0aW9uLm9yaWdpbikuaHJlZjtcbn07XG5cbmNvbnN0IGNhbGN1bGF0ZUxvb3BEdXJhdGlvbiA9ICh7IGVuZEF0LCBtZWRpYUR1cmF0aW9uLCBwbGF5YmFja1JhdGUsIHN0YXJ0RnJvbSwgfSkgPT4ge1xuICAgIGxldCBkdXJhdGlvbiA9IG1lZGlhRHVyYXRpb247XG4gICAgLy8gQWNjb3VudCBmb3IgZW5kQXRcbiAgICBpZiAodHlwZW9mIGVuZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBkdXJhdGlvbiA9IGVuZEF0O1xuICAgIH1cbiAgICAvLyBBY2NvdW50IGZvciBzdGFydEZyb21cbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZHVyYXRpb24gLT0gc3RhcnRGcm9tO1xuICAgIH1cbiAgICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IGR1cmF0aW9uIC8gcGxheWJhY2tSYXRlO1xuICAgIHJldHVybiBNYXRoLmZsb29yKGFjdHVhbER1cmF0aW9uKTtcbn07XG5cbmNvbnN0IGlzRXJyb3JMaWtlID0gKGVycikgPT4ge1xuICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGVyciAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgnc3RhY2snIGluIGVycikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3ByZWZlci10cy1leHBlY3QtZXJyb3JcbiAgICAvLyBAdHMtaWdub3JlIHdlIGp1c3QgYXNzZXJ0ZWRcbiAgICBpZiAodHlwZW9mIGVyci5zdGFjayAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoISgnbWVzc2FnZScgaW4gZXJyKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcHJlZmVyLXRzLWV4cGVjdC1lcnJvclxuICAgIC8vIEB0cy1pZ25vcmUgd2UganVzdCBhc3NlcnRlZFxuICAgIGlmICh0eXBlb2YgZXJyLm1lc3NhZ2UgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gV2hlbiB5b3UgaW52b2tlIHRoaXMgZnVuY3Rpb24sIFJlbW90aW9uIHdpbGwgc3RvcCByZW5kZXJpbmcgYWxsIHRoZSBmcmFtZXMgd2l0aG91dCBhbnkgcmV0cmllc1xuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvY2FuY2VsLXJlbmRlcilcbiAqL1xuZnVuY3Rpb24gY2FuY2VsUmVuZGVyKGVycikge1xuICAgIGxldCBlcnJvcjtcbiAgICBpZiAoaXNFcnJvckxpa2UoZXJyKSkge1xuICAgICAgICBlcnJvciA9IGVycjtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGVyciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZXJyb3IgPSBFcnJvcihlcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXJyb3IgPSBFcnJvcignUmVuZGVyaW5nIHdhcyBjYW5jZWxsZWQnKTtcbiAgICB9XG4gICAgd2luZG93LnJlbW90aW9uX2NhbmNlbGxlZEVycm9yID0gZXJyb3Iuc3RhY2s7XG4gICAgdGhyb3cgZXJyb3I7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFByb3ZpZGVzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBSZW1vdGlvbiBFbnZpcm9ubWVudFxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvZ2V0LXJlbW90aW9uLWVudmlyb25tZW50KVxuICovXG5jb25zdCBnZXRSZW1vdGlvbkVudmlyb25tZW50ID0gKCkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIC8vIENoZWNrIGlmIGluc2lkZSBhIFJlbW90aW9uIGJ1bmRsZS5cbiAgICAgICAgLy8gTXVzdCBiZSBhIHZhcmlhYmxlIGluIGluZGV4LWh0bWwudHMgYW5kIGJlIGRlZmluZWQgYmVmb3JlIHNldHVwRW52VmFyaWFibGVzKClcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93LnJlbW90aW9uX2VkaXRvck5hbWUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93LnJlbW90aW9uX3Byb2plY3ROYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc1N0dWRpbzogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNSZW5kZXJpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgaXNQbGF5ZXI6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTdHVkaW86IGZhbHNlLFxuICAgICAgICAgICAgaXNSZW5kZXJpbmc6IGZhbHNlLFxuICAgICAgICAgICAgaXNQbGF5ZXI6IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gVGhlIFZpdGVzdCBmcmFtZXdvcmsgc2V0cyBOT0RFX0VOViBhcyB0ZXN0LlxuICAgIC8vIFJpZ2h0IG5vdyB3ZSBkb24ndCBuZWVkIHRvIHRyZWF0IGl0IGluIGEgc3BlY2lhbFxuICAgIC8vIHdheSB3aGljaCBpcyBnb29kIC0gZGVmYXVsdGluZyB0byBgcmVuZGVyaW5nYC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICd0ZXN0Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNTdHVkaW86IGZhbHNlLFxuICAgICAgICAgICAgaXNSZW5kZXJpbmc6IHRydWUsXG4gICAgICAgICAgICBpc1BsYXllcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlzU3R1ZGlvOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUmVuZGVyaW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzUGxheWVyOiB0cnVlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpc1N0dWRpbzogdHJ1ZSxcbiAgICAgICAgaXNSZW5kZXJpbmc6IGZhbHNlLFxuICAgICAgICBpc1BsYXllcjogZmFsc2UsXG4gICAgfTtcbn07XG5cbmNvbnN0IEhJRERFTl9OQU1FUyA9IFsnX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18nXTtcbmNvbnN0IGdldFRpbWVsaW5lQ2xpcE5hbWUgPSAoY2hpbGRyZW4pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJlZSA9IChfYSA9IENoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoKSA9PiB7XG4gICAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQoY2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdXN0IGJlIG5hbWUsIG5vdCBJRFxuICAgICAgICBjb25zdCBuYW1lID0gdHlwZW9mIGNoLnR5cGUgIT09ICdzdHJpbmcnICYmIGNoLnR5cGUubmFtZTtcbiAgICAgICAgaWYgKG5hbWUgJiYgIUhJRERFTl9OQU1FUy5pbmNsdWRlcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoLnByb3BzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaE5hbWUgPSBnZXRUaW1lbGluZUNsaXBOYW1lKGNoLnByb3BzLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIHJldHVybiBjaE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5maWx0ZXIoQm9vbGVhbik7XG4gICAgcmV0dXJuICh0cmVlID09PSBudWxsIHx8IHRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyZWUubGVuZ3RoKSA/IHRyZWVbMF0gOiAnJztcbn07XG5cbmNvbnN0IE5vbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGdldE5vbmNlOiAoKSA9PiAwLFxuICAgIGZhc3RSZWZyZXNoZXM6IDAsXG59KTtcbmNvbnN0IHVzZU5vbmNlID0gKCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gICAgY29uc3QgW25vbmNlLCBzZXROb25jZV0gPSB1c2VTdGF0ZSgoKSA9PiBjb250ZXh0LmdldE5vbmNlKCkpO1xuICAgIGNvbnN0IGxhc3RDb250ZXh0ID0gdXNlUmVmKGNvbnRleHQpO1xuICAgIC8vIE9ubHkgaWYgY29udGV4dCBjaGFuZ2VzLCBidXQgbm90IGluaXRpYWxseVxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChsYXN0Q29udGV4dC5jdXJyZW50ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdENvbnRleHQuY3VycmVudCA9IGNvbnRleHQ7XG4gICAgICAgIHNldE5vbmNlKGNvbnRleHQuZ2V0Tm9uY2UpO1xuICAgIH0sIFtjb250ZXh0XSk7XG4gICAgcmV0dXJuIG5vbmNlO1xufTtcblxuY29uc3QgU2VxdWVuY2VDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblxuY29uc3QgU2VxdWVuY2VNYW5hZ2VyID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgcmVnaXN0ZXJTZXF1ZW5jZTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlcXVlbmNlTWFuYWdlckNvbnRleHQgbm90IGluaXRpYWxpemVkJyk7XG4gICAgfSxcbiAgICB1bnJlZ2lzdGVyU2VxdWVuY2U6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXF1ZW5jZU1hbmFnZXJDb250ZXh0IG5vdCBpbml0aWFsaXplZCcpO1xuICAgIH0sXG4gICAgc2VxdWVuY2VzOiBbXSxcbn0pO1xuY29uc3QgU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIgPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3QgW3NlcXVlbmNlcywgc2V0U2VxdWVuY2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCByZWdpc3RlclNlcXVlbmNlID0gdXNlQ2FsbGJhY2soKHNlcSkgPT4ge1xuICAgICAgICBzZXRTZXF1ZW5jZXMoKHNlcXMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4uc2Vxcywgc2VxXTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHVucmVnaXN0ZXJTZXF1ZW5jZSA9IHVzZUNhbGxiYWNrKChzZXEpID0+IHtcbiAgICAgICAgc2V0U2VxdWVuY2VzKChzZXFzKSA9PiBzZXFzLmZpbHRlcigocykgPT4gcy5pZCAhPT0gc2VxKSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgICAgICAgICBzZXF1ZW5jZXMsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgICAgIH07XG4gICAgfSwgW3JlZ2lzdGVyU2VxdWVuY2UsIHNlcXVlbmNlcywgdW5yZWdpc3RlclNlcXVlbmNlXSk7XG4gICAgcmV0dXJuIChqc3goU2VxdWVuY2VNYW5hZ2VyLlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgQ29tcG9zaXRpb25NYW5hZ2VyID0gY3JlYXRlQ29udGV4dCh7XG4gICAgY29tcG9zaXRpb25zOiBbXSxcbiAgICByZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgcmVnaXN0ZXJGb2xkZXI6ICgpID0+IHVuZGVmaW5lZCxcbiAgICB1bnJlZ2lzdGVyRm9sZGVyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgc2V0Q3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGE6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBmb2xkZXJzOiBbXSxcbiAgICBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YTogbnVsbCxcbiAgICBjYW52YXNDb250ZW50OiBudWxsLFxuICAgIHNldENhbnZhc0NvbnRlbnQ6ICgpID0+IHVuZGVmaW5lZCxcbn0pO1xuXG5jb25zdCBwcm9ibGVtYXRpY0NoYXJhY3RlcnMgPSB7XG4gICAgJyUzQSc6ICc6JyxcbiAgICAnJTJGJzogJy8nLFxuICAgICclM0YnOiAnPycsXG4gICAgJyUyMyc6ICcjJyxcbiAgICAnJTVCJzogJ1snLFxuICAgICclNUQnOiAnXScsXG4gICAgJyU0MCc6ICdAJyxcbiAgICAnJTIxJzogJyEnLFxuICAgICclMjQnOiAnJCcsXG4gICAgJyUyNic6ICcmJyxcbiAgICAnJTI3JzogXCInXCIsXG4gICAgJyUyOCc6ICcoJyxcbiAgICAnJTI5JzogJyknLFxuICAgICclMkEnOiAnKicsXG4gICAgJyUyQic6ICcrJyxcbiAgICAnJTJDJzogJywnLFxuICAgICclM0InOiAnOycsXG59O1xuY29uc3QgZGlkV2FybiQxID0ge307XG5jb25zdCB3YXJuT25jZSQxID0gKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAoZGlkV2FybiQxW21lc3NhZ2VdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIGRpZFdhcm4kMVttZXNzYWdlXSA9IHRydWU7XG59O1xuY29uc3QgaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIgPSAocGF0aCkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHByb2JsZW1hdGljQ2hhcmFjdGVycykpIHtcbiAgICAgICAgaWYgKHBhdGguaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgY29udGFpbnNIZXg6IHRydWUsIGhleENvZGU6IGtleSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnRhaW5zSGV4OiBmYWxzZSB9O1xufTtcbmNvbnN0IHRyaW1MZWFkaW5nU2xhc2ggPSAocGF0aCkgPT4ge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gdHJpbUxlYWRpbmdTbGFzaChwYXRoLnN1YnN0cmluZygxKSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoO1xufTtcbmNvbnN0IGlubmVyID0gKHBhdGgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlbW90aW9uX3N0YXRpY0Jhc2UpIHtcbiAgICAgICAgaWYgKHBhdGguc3RhcnRzV2l0aCh3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHZhbHVlIFwiJHtwYXRofVwiIGlzIGFscmVhZHkgcHJlZml4ZWQgd2l0aCB0aGUgc3RhdGljIGJhc2UgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0uIFlvdSBkb24ndCBuZWVkIHRvIGNhbGwgc3RhdGljRmlsZSgpIG9uIGl0LmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgJHt3aW5kb3cucmVtb3Rpb25fc3RhdGljQmFzZX0vJHt0cmltTGVhZGluZ1NsYXNoKHBhdGgpfWA7XG4gICAgfVxuICAgIHJldHVybiBgLyR7dHJpbUxlYWRpbmdTbGFzaChwYXRoKX1gO1xufTtcbmNvbnN0IGVuY29kZUJ5U3BsaXR0aW5nID0gKHBhdGgpID0+IHtcbiAgICBjb25zdCBzcGxpdEJ5U2xhc2ggPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgY29uc3QgZW5jb2RlZEFycmF5ID0gc3BsaXRCeVNsYXNoLm1hcCgoZWxlbWVudCkgPT4ge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVsZW1lbnQpO1xuICAgIH0pO1xuICAgIGNvbnN0IG1lcmdlZCA9IGVuY29kZWRBcnJheS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZWZlcmVuY2UgYSBmaWxlIGZyb20gdGhlIHB1YmxpYy8gZm9sZGVyLiBJZiB0aGUgZmlsZSBkb2VzIG5vdCBhcHBlYXIgaW4gdGhlIGF1dG9jb21wbGV0ZSwgdHlwZSB0aGUgcGF0aCBtYW51YWxseS5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUpXG4gKi9cbmNvbnN0IHN0YXRpY0ZpbGUgPSAocGF0aCkgPT4ge1xuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVtb3RlIFVSTHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIFVSTCB3aXRob3V0IHdyYXBwaW5nIGl0IGluIHN0YXRpY0ZpbGUoKS4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVtb3RlLXVybHNgKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnLi4nKSB8fCBwYXRoLnN0YXJ0c1dpdGgoJy4vJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhdGljRmlsZSgpIGRvZXMgbm90IHN1cHBvcnQgcmVsYXRpdmUgcGF0aHMgLSBnb3QgXCIke3BhdGh9XCIuIEluc3RlYWQsIHBhc3MgdGhlIG5hbWUgb2YgYSBmaWxlIHRoYXQgaXMgaW5zaWRlIHRoZSBwdWJsaWMvIGZvbGRlci4gU2VlOiBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3N0YXRpY2ZpbGUtcmVsYXRpdmUtcGF0aHNgKTtcbiAgICB9XG4gICAgaWYgKHBhdGguc3RhcnRzV2l0aCgnL1VzZXJzJykgfHxcbiAgICAgICAgcGF0aC5zdGFydHNXaXRoKCcvaG9tZScpIHx8XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aCgnL3RtcCcpIHx8XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aCgnL2V0YycpIHx8XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aCgnL29wdCcpIHx8XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aCgnL3ZhcicpIHx8XG4gICAgICAgIHBhdGguc3RhcnRzV2l0aCgnQzonKSB8fFxuICAgICAgICBwYXRoLnN0YXJ0c1dpdGgoJ0Q6JykgfHxcbiAgICAgICAgcGF0aC5zdGFydHNXaXRoKCdFOicpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0YXRpY0ZpbGUoKSBkb2VzIG5vdCBzdXBwb3J0IGFic29sdXRlIHBhdGhzIC0gZ290IFwiJHtwYXRofVwiLiBJbnN0ZWFkLCBwYXNzIHRoZSBuYW1lIG9mIGEgZmlsZSB0aGF0IGlzIGluc2lkZSB0aGUgcHVibGljLyBmb2xkZXIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gICAgfVxuICAgIGlmIChwYXRoLnN0YXJ0c1dpdGgoJ3B1YmxpYy8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBEbyBub3QgaW5jbHVkZSB0aGUgcHVibGljLyBwcmVmaXggd2hlbiB1c2luZyBzdGF0aWNGaWxlKCkgLSBnb3QgXCIke3BhdGh9XCIuIFNlZTogaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9zdGF0aWNmaWxlLXJlbGF0aXZlLXBhdGhzYCk7XG4gICAgfVxuICAgIGNvbnN0IGluY2x1ZGVzSGV4ID0gaW5jbHVkZXNIZXhPZlVuc2FmZUNoYXIocGF0aCk7XG4gICAgaWYgKGluY2x1ZGVzSGV4LmNvbnRhaW5zSGV4KSB7XG4gICAgICAgIHdhcm5PbmNlJDEoYFdBUk5JTkc6IFlvdSBzZWVtIHRvIHBhc3MgYW4gYWxyZWFkeSBlbmNvZGVkIHBhdGggKHBhdGggY29udGFpbnMgJHtpbmNsdWRlc0hleC5oZXhDb2RlfSkuIFNpbmNlIFJlbW90aW9uIDQuMCwgdGhlIGVuY29kaW5nIGlzIGRvbmUgYnkgc3RhdGljRmlsZSgpIGl0c2VsZi4gWW91IG1heSB3YW50IHRvIHJlbW92ZSBhIGVuY29kZVVSSUNvbXBvbmVudCgpIHdyYXBwaW5nLmApO1xuICAgIH1cbiAgICBjb25zdCBwcmVwcm9jZXNzZWQgPSBlbmNvZGVCeVNwbGl0dGluZyhwYXRoKTtcbiAgICBjb25zdCBwcmVwYXJzZWQgPSBpbm5lcihwcmVwcm9jZXNzZWQpO1xuICAgIGlmICghcHJlcGFyc2VkLnN0YXJ0c1dpdGgoJy8nKSkge1xuICAgICAgICByZXR1cm4gYC8ke3ByZXBhcnNlZH1gO1xuICAgIH1cbiAgICByZXR1cm4gcHJlcGFyc2VkO1xufTtcblxuLy8gTXVzdCBrZWVwIHRoaXMgZmlsZSBpbiBzeW5jIHdpdGggdGhlIG9uZSBpbiBwYWNrYWdlcy9sYW1iZGEvc3JjL3NoYXJlZC9zZXJpYWxpemUtcHJvcHMudHMhXG5jb25zdCBEQVRFX1RPS0VOID0gJ3JlbW90aW9uLWRhdGU6JztcbmNvbnN0IEZJTEVfVE9LRU4gPSAncmVtb3Rpb24tZmlsZTonO1xuY29uc3Qgc2VyaWFsaXplSlNPTldpdGhEYXRlID0gKHsgZGF0YSwgaW5kZW50LCBzdGF0aWNCYXNlLCB9KSA9PiB7XG4gICAgbGV0IGN1c3RvbURhdGVVc2VkID0gZmFsc2U7XG4gICAgbGV0IGN1c3RvbUZpbGVVc2VkID0gZmFsc2U7XG4gICAgbGV0IG1hcFVzZWQgPSBmYWxzZTtcbiAgICBsZXQgc2V0VXNlZCA9IGZhbHNlO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShkYXRhLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpc1trZXldO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGN1c3RvbURhdGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBgJHtEQVRFX1RPS0VOfSR7aXRlbS50b0lTT1N0cmluZygpfWA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIG1hcFVzZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICBzZXRVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBzdGF0aWNCYXNlICE9PSBudWxsICYmXG4gICAgICAgICAgICBpdGVtLnN0YXJ0c1dpdGgoc3RhdGljQmFzZSkpIHtcbiAgICAgICAgICAgIGN1c3RvbUZpbGVVc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBgJHtGSUxFX1RPS0VOfSR7aXRlbS5yZXBsYWNlKHN0YXRpY0Jhc2UgKyAnLycsICcnKX1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LCBpbmRlbnQpO1xuICAgIHJldHVybiB7IHNlcmlhbGl6ZWRTdHJpbmcsIGN1c3RvbURhdGVVc2VkLCBjdXN0b21GaWxlVXNlZCwgbWFwVXNlZCwgc2V0VXNlZCB9O1xufTtcbmNvbnN0IGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMgPSAoZGF0YSkgPT4ge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEsIChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5zdGFydHNXaXRoKERBVEVfVE9LRU4pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUucmVwbGFjZShEQVRFX1RPS0VOLCAnJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLnN0YXJ0c1dpdGgoRklMRV9UT0tFTikpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGF0aWNGaWxlKHZhbHVlLnJlcGxhY2UoRklMRV9UT0tFTiwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59O1xuXG5sZXQgZGlkV2FyblNTUkltcG9ydCA9IGZhbHNlO1xuY29uc3Qgd2Fybk9uY2VTU1JJbXBvcnQgPSAoKSA9PiB7XG4gICAgaWYgKGRpZFdhcm5TU1JJbXBvcnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuU1NSSW1wb3J0ID0gdHJ1ZTtcbiAgICBjb25zb2xlLndhcm4oJ0NhbGxlZCBgZ2V0SW5wdXRQcm9wcygpYCBvbiB0aGUgc2VydmVyLiBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBhdmFpbGFibGUgc2VydmVyLXNpZGUgYW5kIGhhcyByZXR1cm5lZCBhbiBlbXB0eSBvYmplY3QuJyk7XG4gICAgY29uc29sZS53YXJuKFwiVG8gaGlkZSB0aGlzIHdhcm5pbmcsIGRvbid0IGNhbGwgdGhpcyBmdW5jdGlvbiBvbiB0aGUgc2VydmVyOlwiKTtcbiAgICBjb25zb2xlLndhcm4oXCIgIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8ge30gOiBnZXRJbnB1dFByb3BzKClcIik7XG59O1xuY29uc3QgZ2V0SW5wdXRQcm9wcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2Fybk9uY2VTU1JJbXBvcnQoKTtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzUGxheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignWW91IGNhbm5vdCBjYWxsIGBnZXRJbnB1dFByb3BzKClgIGZyb20gYSA8UGxheWVyPi4gSW5zdGVhZCwgdGhlIHByb3BzIGFyZSBhdmFpbGFibGUgYXMgUmVhY3QgcHJvcHMgZnJvbSBjb21wb25lbnQgdGhhdCB5b3UgcGFzc2VkIGFzIGBjb21wb25lbnRgIHByb3AuJyk7XG4gICAgfVxuICAgIGNvbnN0IHBhcmFtID0gd2luZG93LnJlbW90aW9uX2lucHV0UHJvcHM7XG4gICAgaWYgKCFwYXJhbSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IGRlc2VyaWFsaXplSlNPTldpdGhDdXN0b21GaWVsZHMocGFyYW0pO1xuICAgIHJldHVybiBwYXJzZWQ7XG59O1xuXG5jb25zdCBFZGl0b3JQcm9wc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICBwcm9wczoge30sXG4gICAgdXBkYXRlUHJvcHM6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9LFxufSk7XG5jb25zdCBFZGl0b3JQcm9wc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IFtwcm9wcywgc2V0UHJvcHNdID0gUmVhY3QudXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IHVwZGF0ZVByb3BzID0gdXNlQ2FsbGJhY2soKHsgZGVmYXVsdFByb3BzLCBpZCwgbmV3UHJvcHMsIH0pID0+IHtcbiAgICAgICAgc2V0UHJvcHMoKHByZXYpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICAgICAgICBbaWRdOiB0eXBlb2YgbmV3UHJvcHMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICAgICAgPyBuZXdQcm9wcygoX2EgPSBwcmV2W2lkXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFByb3BzKVxuICAgICAgICAgICAgICAgICAgICA6IG5ld1Byb3BzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGN0eCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4geyBwcm9wcywgdXBkYXRlUHJvcHMgfTtcbiAgICB9LCBbcHJvcHMsIHVwZGF0ZVByb3BzXSk7XG4gICAgcmV0dXJuIChqc3goRWRpdG9yUHJvcHNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjdHgsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZURpbWVuc2lvbihhbW91bnQsIG5hbWVPZlByb3AsIGxvY2F0aW9uKSB7XG4gICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGFtb3VudH1gKTtcbiAgICB9XG4gICAgaWYgKGlzTmFOKGFtb3VudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiJHtuYW1lT2ZQcm9wfVwiIHByb3AgJHtsb2NhdGlvbn0gbXVzdCBub3QgYmUgTmFOLCBidXQgaXMgTmFOLmApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhbW91bnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcIiR7bmFtZU9mUHJvcH1cIiBwcm9wICR7bG9jYXRpb259IG11c3QgYmUgZmluaXRlLCBidXQgaXMgJHthbW91bnR9LmApO1xuICAgIH1cbiAgICBpZiAoYW1vdW50ICUgMSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBpcyAke2Ftb3VudH0uYCk7XG4gICAgfVxuICAgIGlmIChhbW91bnQgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCIke25hbWVPZlByb3B9XCIgcHJvcCAke2xvY2F0aW9ufSBtdXN0IGJlIHBvc2l0aXZlLCBidXQgZ290ICR7YW1vdW50fS5gKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBhbGxvd0Zsb2F0cywgY29tcG9uZW50IH0gPSBvcHRpb25zO1xuICAgIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gaXMgbWlzc2luZy5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXJhdGlvbkluRnJhbWVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGEgbnVtYmVyLCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc31gKTtcbiAgICB9XG4gICAgaWYgKGR1cmF0aW9uSW5GcmFtZXMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJkdXJhdGlvbkluRnJhbWVzXCIgcHJvcCAke2NvbXBvbmVudH0gbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9LmApO1xuICAgIH1cbiAgICBpZiAoIWFsbG93RmxvYXRzICYmIGR1cmF0aW9uSW5GcmFtZXMgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcImR1cmF0aW9uSW5GcmFtZXNcIiBwcm9wICR7Y29tcG9uZW50fSBtdXN0IGJlIGFuIGludGVnZXIsIGJ1dCBnb3QgJHtkdXJhdGlvbkluRnJhbWVzfS5gKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZHVyYXRpb25JbkZyYW1lcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIFwiZHVyYXRpb25JbkZyYW1lc1wiIHByb3AgJHtjb21wb25lbnR9IG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZHVyYXRpb25JbkZyYW1lc30uYCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZwcyhmcHMsIGxvY2F0aW9uLCBpc0dpZikge1xuICAgIGlmICh0eXBlb2YgZnBzICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIG51bWJlciwgYnV0IHlvdSBwYXNzZWQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGZwc30gJHtsb2NhdGlvbn1gKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnBzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiZnBzXCIgbXVzdCBiZSBhIGZpbml0ZSwgYnV0IHlvdSBwYXNzZWQgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gICAgfVxuICAgIGlmIChpc05hTihmcHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCJmcHNcIiBtdXN0IG5vdCBiZSBOYU4sIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gICAgfVxuICAgIGlmIChmcHMgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBcImZwc1wiIG11c3QgYmUgcG9zaXRpdmUsIGJ1dCBnb3QgJHtmcHN9ICR7bG9jYXRpb259YCk7XG4gICAgfVxuICAgIGlmIChpc0dpZiAmJiBmcHMgPiA1MCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgRlBTIGZvciBhIEdJRiBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gNTAuIFVzZSB0aGUgLS1ldmVyeS1udGgtZnJhbWUgb3B0aW9uIHRvIGxvd2VyIHRoZSBGUFM6IGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmVuZGVyLWFzLWdpZmApO1xuICAgIH1cbn1cblxuY29uc3QgdmFsaWRhdGVDYWxjdWxhdGVkID0gKHsgY29tcG9zaXRpb24sIGNhbGN1bGF0ZWQsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2csIF9oO1xuICAgIGNvbnN0IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA9IGBjYWxjdWxhdGVkIGJ5IGNhbGN1bGF0ZU1ldGFkYXRhKCkgZm9yIHRoZSBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb24uaWR9XCJgO1xuICAgIGNvbnN0IGRlZmF1bHRFcnJvckxvY2F0aW9uID0gYG9mIHRoZSBcIjxDb21wb3NpdGlvbiAvPlwiIGNvbXBvbmVudCB3aXRoIHRoZSBpZCBcIiR7Y29tcG9zaXRpb24uaWR9XCJgO1xuICAgIGNvbnN0IHdpZHRoID0gKF9iID0gKF9hID0gY2FsY3VsYXRlZCA9PT0gbnVsbCB8fCBjYWxjdWxhdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxjdWxhdGVkLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjb21wb3NpdGlvbi53aWR0aCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdW5kZWZpbmVkO1xuICAgIHZhbGlkYXRlRGltZW5zaW9uKHdpZHRoLCAnd2lkdGgnLCAoY2FsY3VsYXRlZCA9PT0gbnVsbCB8fCBjYWxjdWxhdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxjdWxhdGVkLndpZHRoKSA/IGNhbGN1bGF0ZU1ldGFkYXRhRXJyb3JMb2NhdGlvbiA6IGRlZmF1bHRFcnJvckxvY2F0aW9uKTtcbiAgICBjb25zdCBoZWlnaHQgPSAoX2QgPSAoX2MgPSBjYWxjdWxhdGVkID09PSBudWxsIHx8IGNhbGN1bGF0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGN1bGF0ZWQuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBjb21wb3NpdGlvbi5oZWlnaHQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZURpbWVuc2lvbihoZWlnaHQsICdoZWlnaHQnLCAoY2FsY3VsYXRlZCA9PT0gbnVsbCB8fCBjYWxjdWxhdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxjdWxhdGVkLmhlaWdodCkgPyBjYWxjdWxhdGVNZXRhZGF0YUVycm9yTG9jYXRpb24gOiBkZWZhdWx0RXJyb3JMb2NhdGlvbik7XG4gICAgY29uc3QgZnBzID0gKF9mID0gKF9lID0gY2FsY3VsYXRlZCA9PT0gbnVsbCB8fCBjYWxjdWxhdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxjdWxhdGVkLmZwcykgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogY29tcG9zaXRpb24uZnBzKSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBudWxsO1xuICAgIHZhbGlkYXRlRnBzKGZwcywgKGNhbGN1bGF0ZWQgPT09IG51bGwgfHwgY2FsY3VsYXRlZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsY3VsYXRlZC5mcHMpID8gY2FsY3VsYXRlTWV0YWRhdGFFcnJvckxvY2F0aW9uIDogZGVmYXVsdEVycm9yTG9jYXRpb24sIGZhbHNlKTtcbiAgICBjb25zdCBkdXJhdGlvbkluRnJhbWVzID0gKF9oID0gKF9nID0gY2FsY3VsYXRlZCA9PT0gbnVsbCB8fCBjYWxjdWxhdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxjdWxhdGVkLmR1cmF0aW9uSW5GcmFtZXMpICE9PSBudWxsICYmIF9nICE9PSB2b2lkIDAgPyBfZyA6IGNvbXBvc2l0aW9uLmR1cmF0aW9uSW5GcmFtZXMpICE9PSBudWxsICYmIF9oICE9PSB2b2lkIDAgPyBfaCA6IG51bGw7XG4gICAgdmFsaWRhdGVEdXJhdGlvbkluRnJhbWVzKGR1cmF0aW9uSW5GcmFtZXMsIHtcbiAgICAgICAgYWxsb3dGbG9hdHM6IGZhbHNlLFxuICAgICAgICBjb21wb25lbnQ6IGBvZiB0aGUgXCI8Q29tcG9zaXRpb24gLz5cIiBjb21wb25lbnQgd2l0aCB0aGUgaWQgXCIke2NvbXBvc2l0aW9uLmlkfVwiYCxcbiAgICB9KTtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0LCBmcHMsIGR1cmF0aW9uSW5GcmFtZXMgfTtcbn07XG5jb25zdCByZXNvbHZlVmlkZW9Db25maWcgPSAoeyBjb21wb3NpdGlvbiwgZWRpdG9yUHJvcHM6IGVkaXRvclByb3BzT3JVbmRlZmluZWQsIHNpZ25hbCwgaW5wdXRQcm9wcywgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICBjb25zdCBjYWxjdWxhdGVkUHJvbSA9IGNvbXBvc2l0aW9uLmNhbGN1bGF0ZU1ldGFkYXRhXG4gICAgICAgID8gY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEoe1xuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiAoX2EgPSBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAuLi4oKF9iID0gY29tcG9zaXRpb24uZGVmYXVsdFByb3BzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fSksXG4gICAgICAgICAgICAgICAgLi4uKGVkaXRvclByb3BzT3JVbmRlZmluZWQgIT09IG51bGwgJiYgZWRpdG9yUHJvcHNPclVuZGVmaW5lZCAhPT0gdm9pZCAwID8gZWRpdG9yUHJvcHNPclVuZGVmaW5lZCA6IHt9KSxcbiAgICAgICAgICAgICAgICAuLi5pbnB1dFByb3BzLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiBzaWduYWwsXG4gICAgICAgIH0pXG4gICAgICAgIDogbnVsbDtcbiAgICBjb25zdCBmYWxsYmFja1Byb3BzID0ge1xuICAgICAgICAuLi4oKF9jID0gY29tcG9zaXRpb24uZGVmYXVsdFByb3BzKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSksXG4gICAgICAgIC4uLihpbnB1dFByb3BzICE9PSBudWxsICYmIGlucHV0UHJvcHMgIT09IHZvaWQgMCA/IGlucHV0UHJvcHMgOiB7fSksXG4gICAgfTtcbiAgICBpZiAoY2FsY3VsYXRlZFByb20gIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNhbGN1bGF0ZWRQcm9tID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAndGhlbicgaW4gY2FsY3VsYXRlZFByb20pIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRQcm9tLnRoZW4oKGMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGgsIGR1cmF0aW9uSW5GcmFtZXMsIGZwcyB9ID0gdmFsaWRhdGVDYWxjdWxhdGVkKHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkOiBjLFxuICAgICAgICAgICAgICAgIGNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICBmcHMsXG4gICAgICAgICAgICAgICAgZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgICAgICAgICBpZDogY29tcG9zaXRpb24uaWQsXG4gICAgICAgICAgICAgICAgZGVmYXVsdFByb3BzOiAoX2EgPSBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgICAgIHByb3BzOiAoX2IgPSBjLnByb3BzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxsYmFja1Byb3BzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSB2YWxpZGF0ZUNhbGN1bGF0ZWQoe1xuICAgICAgICBjYWxjdWxhdGVkOiBjYWxjdWxhdGVkUHJvbSxcbiAgICAgICAgY29tcG9zaXRpb24sXG4gICAgfSk7XG4gICAgaWYgKGNhbGN1bGF0ZWRQcm9tID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5kYXRhLFxuICAgICAgICAgICAgaWQ6IGNvbXBvc2l0aW9uLmlkLFxuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiAoX2QgPSBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IHt9LFxuICAgICAgICAgICAgcHJvcHM6IGZhbGxiYWNrUHJvcHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRhdGEsXG4gICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgZGVmYXVsdFByb3BzOiAoX2UgPSBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9LFxuICAgICAgICBwcm9wczogKF9nID0gKF9mID0gY2FsY3VsYXRlZFByb20ucHJvcHMpICE9PSBudWxsICYmIF9mICE9PSB2b2lkIDAgPyBfZiA6IGNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcykgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDoge30sXG4gICAgfTtcbn07XG5cbmNvbnN0IFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgcmVzb2x2ZUNvbXBvc2l0aW9uc1JlZiA9IGNyZWF0ZVJlZigpO1xuY29uc3QgbmVlZHNSZXNvbHV0aW9uID0gKGNvbXBvc2l0aW9uKSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY29tcG9zaXRpb24uY2FsY3VsYXRlTWV0YWRhdGEpO1xufTtcbmNvbnN0IFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZyA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBbY3VycmVudFJlbmRlck1vZGFsQ29tcG9zaXRpb24sIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgY29tcG9zaXRpb25zLCBjYW52YXNDb250ZW50LCBjdXJyZW50Q29tcG9zaXRpb25NZXRhZGF0YSB9ID0gdXNlQ29udGV4dChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICAgIGNvbnN0IHNlbGVjdGVkQ29tcG9zaXRpb24gPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4gY2FudmFzQ29udGVudCAmJlxuICAgICAgICBjYW52YXNDb250ZW50LnR5cGUgPT09ICdjb21wb3NpdGlvbicgJiZcbiAgICAgICAgY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkID09PSBjLmlkKTtcbiAgICBjb25zdCByZW5kZXJNb2RhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uKTtcbiAgICBjb25zdCB7IHByb3BzOiBhbGxFZGl0b3JQcm9wcyB9ID0gdXNlQ29udGV4dChFZGl0b3JQcm9wc0NvbnRleHQpO1xuICAgIGNvbnN0IFtyZXNvbHZlZENvbmZpZ3MsIHNldFJlc29sdmVkQ29uZmlnc10gPSB1c2VTdGF0ZSh7fSk7XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGl0b3JQcm9wcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZENvbXBvc2l0aW9uXG4gICAgICAgICAgICA/IChfYSA9IGFsbEVkaXRvclByb3BzW3NlbGVjdGVkQ29tcG9zaXRpb24uaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fVxuICAgICAgICAgICAgOiB7fTtcbiAgICB9LCBbYWxsRWRpdG9yUHJvcHMsIHNlbGVjdGVkQ29tcG9zaXRpb25dKTtcbiAgICBjb25zdCByZW5kZXJNb2RhbFByb3BzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIHJlbmRlck1vZGFsQ29tcG9zaXRpb25cbiAgICAgICAgICAgID8gKF9hID0gYWxsRWRpdG9yUHJvcHNbcmVuZGVyTW9kYWxDb21wb3NpdGlvbi5pZF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9XG4gICAgICAgICAgICA6IHt9O1xuICAgIH0sIFthbGxFZGl0b3JQcm9wcywgcmVuZGVyTW9kYWxDb21wb3NpdGlvbl0pO1xuICAgIGNvbnN0IGRvUmVzb2x1dGlvbiA9IHVzZUNhbGxiYWNrKChjb21wb3NpdGlvbiwgZWRpdG9yUHJvcHMpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgICAgICBpZiAoY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBjb250cm9sbGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0UHJvcHMgPSB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCBnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNQbGF5ZXJcbiAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgIDogKF9hID0gZ2V0SW5wdXRQcm9wcygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fTtcbiAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IGNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IHByb21Pck5vdCA9IHJlc29sdmVWaWRlb0NvbmZpZyh7XG4gICAgICAgICAgICBjb21wb3NpdGlvbixcbiAgICAgICAgICAgIGVkaXRvclByb3BzLFxuICAgICAgICAgICAgaW5wdXRQcm9wcyxcbiAgICAgICAgICAgIHNpZ25hbCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvbU9yTm90ID09PSAnb2JqZWN0JyAmJiAndGhlbicgaW4gcHJvbU9yTm90KSB7XG4gICAgICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICBbY29tcG9zaXRpb24uaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsb2FkaW5nJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcHJvbU9yTm90XG4gICAgICAgICAgICAgICAgLnRoZW4oKGMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICAgICAgW2NvbXBvc2l0aW9uLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBjLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldFJlc29sdmVkQ29uZmlncygocikgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICAgICAgW2NvbXBvc2l0aW9uLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRSZXNvbHZlZENvbmZpZ3MoKHIpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4ucixcbiAgICAgICAgICAgICAgICBbY29tcG9zaXRpb24uaWRdOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBwcm9tT3JOb3QsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udHJvbGxlcjtcbiAgICB9LCBbY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGFdKTtcbiAgICBjb25zdCBjdXJyZW50Q29tcG9zaXRpb24gPSAoY2FudmFzQ29udGVudCA9PT0gbnVsbCB8fCBjYW52YXNDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNDb250ZW50LnR5cGUpID09PSAnY29tcG9zaXRpb24nID8gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkIDogbnVsbDtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlc29sdmVDb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRSZW5kZXJNb2RhbENvbXBvc2l0aW9uOiAoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50UmVuZGVyTW9kYWxDb21wb3NpdGlvbihpZCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVsb2FkQ3VycmVudGx5U2VsZWN0ZWRDb21wb3NpdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBvc2l0aW9uID0gY29tcG9zaXRpb25zLmZpbmQoKGMpID0+IGMuaWQgPT09IGN1cnJlbnRDb21wb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGNvbXBvc2l0aW9uIHdpdGggaWQgJHtjdXJyZW50Q29tcG9zaXRpb259YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvclByb3BzID0gKF9hID0gYWxsRWRpdG9yUHJvcHNbY3VycmVudENvbXBvc2l0aW9uXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICAgICAgZG9SZXNvbHV0aW9uKGNvbXBvc2l0aW9uLCBlZGl0b3JQcm9wcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sIFthbGxFZGl0b3JQcm9wcywgY29tcG9zaXRpb25zLCBjdXJyZW50Q29tcG9zaXRpb24sIGRvUmVzb2x1dGlvbl0pO1xuICAgIGNvbnN0IGlzVGhlU2FtZSA9IChzZWxlY3RlZENvbXBvc2l0aW9uID09PSBudWxsIHx8IHNlbGVjdGVkQ29tcG9zaXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlbGVjdGVkQ29tcG9zaXRpb24uaWQpID09PSAocmVuZGVyTW9kYWxDb21wb3NpdGlvbiA9PT0gbnVsbCB8fCByZW5kZXJNb2RhbENvbXBvc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZW5kZXJNb2RhbENvbXBvc2l0aW9uLmlkKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoc2VsZWN0ZWRDb21wb3NpdGlvbiAmJiBuZWVkc1Jlc29sdXRpb24oc2VsZWN0ZWRDb21wb3NpdGlvbikpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBkb1Jlc29sdXRpb24oc2VsZWN0ZWRDb21wb3NpdGlvbiwgc2VsZWN0ZWRFZGl0b3JQcm9wcyk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbZG9SZXNvbHV0aW9uLCBzZWxlY3RlZENvbXBvc2l0aW9uLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlbmRlck1vZGFsQ29tcG9zaXRpb24gJiYgIWlzVGhlU2FtZSkge1xuICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGRvUmVzb2x1dGlvbihyZW5kZXJNb2RhbENvbXBvc2l0aW9uLCByZW5kZXJNb2RhbFByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtkb1Jlc29sdXRpb24sIGlzVGhlU2FtZSwgcmVuZGVyTW9kYWxDb21wb3NpdGlvbiwgcmVuZGVyTW9kYWxQcm9wc10pO1xuICAgIGNvbnN0IHJlc29sdmVkQ29uZmlnc0luY2x1ZGluZ1N0YXRpY09uZXMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGljQ29tcHMgPSBjb21wb3NpdGlvbnMuZmlsdGVyKChjKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYy5jYWxjdWxhdGVNZXRhZGF0YSA9PT0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXNvbHZlZENvbmZpZ3MsXG4gICAgICAgICAgICAuLi5zdGF0aWNDb21wcy5yZWR1Y2UoKGFjYywgY3VycikgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyLmlkXToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiB7IC4uLmN1cnIsIGRlZmF1bHRQcm9wczogKF9hID0gY3Vyci5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9IH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgfTtcbiAgICB9LCBbY29tcG9zaXRpb25zLCByZXNvbHZlZENvbmZpZ3NdKTtcbiAgICByZXR1cm4gKGpzeChSZXNvbHZlQ29tcG9zaXRpb25Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiByZXNvbHZlZENvbmZpZ3NJbmNsdWRpbmdTdGF0aWNPbmVzLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmNvbnN0IHVzZVJlc29sdmVkVmlkZW9Db25maWcgPSAocHJlZmVycmVkQ29tcG9zaXRpb25JZCkgPT4ge1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IHsgcHJvcHM6IGFsbEVkaXRvclByb3BzIH0gPSB1c2VDb250ZXh0KEVkaXRvclByb3BzQ29udGV4dCk7XG4gICAgY29uc3QgeyBjb21wb3NpdGlvbnMsIGNhbnZhc0NvbnRlbnQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gICAgY29uc3QgY3VycmVudENvbXBvc2l0aW9uID0gKGNhbnZhc0NvbnRlbnQgPT09IG51bGwgfHwgY2FudmFzQ29udGVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FudmFzQ29udGVudC50eXBlKSA9PT0gJ2NvbXBvc2l0aW9uJyA/IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCA6IG51bGw7XG4gICAgY29uc3QgY29tcG9zaXRpb25JZCA9IHByZWZlcnJlZENvbXBvc2l0aW9uSWQgIT09IG51bGwgJiYgcHJlZmVycmVkQ29tcG9zaXRpb25JZCAhPT0gdm9pZCAwID8gcHJlZmVycmVkQ29tcG9zaXRpb25JZCA6IGN1cnJlbnRDb21wb3NpdGlvbjtcbiAgICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiBjLmlkID09PSBjb21wb3NpdGlvbklkKTtcbiAgICBjb25zdCBzZWxlY3RlZEVkaXRvclByb3BzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIGNvbXBvc2l0aW9uID8gKF9hID0gYWxsRWRpdG9yUHJvcHNbY29tcG9zaXRpb24uaWRdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSA6IHt9O1xuICAgIH0sIFthbGxFZGl0b3JQcm9wcywgY29tcG9zaXRpb25dKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKCFjb21wb3NpdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLnByb3BzLFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0UHJvcHM6IChfYSA9IGNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge30sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFuZWVkc1Jlc29sdXRpb24oY29tcG9zaXRpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgICAgICByZXN1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGNvbXBvc2l0aW9uLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbXBvc2l0aW9uLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgZnBzOiBjb21wb3NpdGlvbi5mcHMsXG4gICAgICAgICAgICAgICAgICAgIGlkOiBjb21wb3NpdGlvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgZHVyYXRpb25JbkZyYW1lczogY29tcG9zaXRpb24uZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFByb3BzOiAoX2IgPSBjb21wb3NpdGlvbi5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKChfYyA9IGNvbXBvc2l0aW9uLmRlZmF1bHRQcm9wcykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHNlbGVjdGVkRWRpdG9yUHJvcHMgIT09IG51bGwgJiYgc2VsZWN0ZWRFZGl0b3JQcm9wcyAhPT0gdm9pZCAwID8gc2VsZWN0ZWRFZGl0b3JQcm9wcyA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1BsYXllclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChfZCA9IGdldElucHV0UHJvcHMoKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDoge30pLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGV4dFtjb21wb3NpdGlvbi5pZF0pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0W2NvbXBvc2l0aW9uLmlkXTtcbiAgICB9LCBbY29tcG9zaXRpb24sIGNvbnRleHQsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCBzZWxlY3RlZEVkaXRvclByb3BzXSk7XG59O1xuXG5jb25zdCB1c2VWaWRlbyA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBjYW52YXNDb250ZW50LCBjb21wb3NpdGlvbnMsIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIH0gPSB1c2VDb250ZXh0KENvbXBvc2l0aW9uTWFuYWdlcik7XG4gICAgY29uc3Qgc2VsZWN0ZWQgPSBjb21wb3NpdGlvbnMuZmluZCgoYykgPT4ge1xuICAgICAgICByZXR1cm4gKChjYW52YXNDb250ZW50ID09PSBudWxsIHx8IGNhbnZhc0NvbnRlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbnZhc0NvbnRlbnQudHlwZSkgPT09ICdjb21wb3NpdGlvbicgJiZcbiAgICAgICAgICAgIGMuaWQgPT09IGNhbnZhc0NvbnRlbnQuY29tcG9zaXRpb25JZCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmVzb2x2ZWQgPSB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnKChfYSA9IHNlbGVjdGVkID09PSBudWxsIHx8IHNlbGVjdGVkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZWxlY3RlZC5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNvbHZlZC50eXBlID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzb2x2ZWQudHlwZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNlbGVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4ucmVzb2x2ZWQucmVzdWx0LFxuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiAoX2EgPSBzZWxlY3RlZC5kZWZhdWx0UHJvcHMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHt9LFxuICAgICAgICAgICAgaWQ6IHNlbGVjdGVkLmlkLFxuICAgICAgICAgICAgLy8gV2Ugb3ZlcnJpZGUgdGhlIHNlbGVjdGVkIG1ldGFkYXRhIHdpdGggdGhlIG1ldGFkYXRhIHRoYXQgd2FzIHBhc3NlZCB0byByZW5kZXJNZWRpYSgpLFxuICAgICAgICAgICAgLy8gYW5kIGRvbid0IGFsbG93IGl0IHRvIGJlIGNoYW5nZWQgZHVyaW5nIHJlbmRlciBhbnltb3JlXG4gICAgICAgICAgICAuLi4oY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgIT09IG51bGwgJiYgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEgIT09IHZvaWQgMCA/IGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhIDoge30pLFxuICAgICAgICAgICAgY29tcG9uZW50OiBzZWxlY3RlZC5jb21wb25lbnQsXG4gICAgICAgIH07XG4gICAgfSwgW2N1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLCByZXNvbHZlZCwgc2VsZWN0ZWRdKTtcbn07XG5cbmNvbnN0IFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGZyYW1lOiB7fSxcbiAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICBwbGF5YmFja1JhdGU6IDEsXG4gICAgcm9vdElkOiAnJyxcbiAgICBpbXBlcmF0aXZlUGxheWluZzoge1xuICAgICAgICBjdXJyZW50OiBmYWxzZSxcbiAgICB9LFxuICAgIHNldFBsYXliYWNrUmF0ZTogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHQnKTtcbiAgICB9LFxuICAgIGF1ZGlvQW5kVmlkZW9UYWdzOiB7IGN1cnJlbnQ6IFtdIH0sXG59KTtcbmNvbnN0IFNldFRpbWVsaW5lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIHNldEZyYW1lOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdCcpO1xuICAgIH0sXG4gICAgc2V0UGxheWluZzogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHQnKTtcbiAgICB9LFxufSk7XG5jb25zdCBtYWtlS2V5ID0gKGNvbXBvc2l0aW9uKSA9PiB7XG4gICAgcmV0dXJuIGByZW1vdGlvbi50aW1lLiR7Y29tcG9zaXRpb259YDtcbn07XG5jb25zdCBwZXJzaXN0Q3VycmVudEZyYW1lID0gKGZyYW1lLCBjb21wb3NpdGlvbikgPT4ge1xuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG1ha2VLZXkoY29tcG9zaXRpb24pLCBTdHJpbmcoZnJhbWUpKTtcbn07XG5jb25zdCBnZXRGcmFtZUZvckNvbXBvc2l0aW9uID0gKGNvbXBvc2l0aW9uKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBmcmFtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKG1ha2VLZXkoY29tcG9zaXRpb24pKTtcbiAgICByZXR1cm4gZnJhbWVcbiAgICAgICAgPyBOdW1iZXIoZnJhbWUpXG4gICAgICAgIDogKF9iID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnID8gMCA6IChfYSA9IHdpbmRvdy5yZW1vdGlvbl9pbml0aWFsRnJhbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xufTtcbmNvbnN0IHVzZVRpbWVsaW5lUG9zaXRpb24gPSAoKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB2aWRlb0NvbmZpZyA9IHVzZVZpZGVvKCk7XG4gICAgY29uc3Qgc3RhdGUgPSB1c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gICAgaWYgKCF2aWRlb0NvbmZpZykge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiAoX2EgPSB3aW5kb3cucmVtb3Rpb25faW5pdGlhbEZyYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgIH1cbiAgICBjb25zdCB1bmNsYW1wZWQgPSAoX2IgPSBzdGF0ZS5mcmFtZVt2aWRlb0NvbmZpZy5pZF0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXJcbiAgICAgICAgPyAwXG4gICAgICAgIDogZ2V0RnJhbWVGb3JDb21wb3NpdGlvbih2aWRlb0NvbmZpZy5pZCkpO1xuICAgIHJldHVybiBNYXRoLm1pbih2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzIC0gMSwgdW5jbGFtcGVkKTtcbn07XG5jb25zdCB1c2VUaW1lbGluZVNldEZyYW1lID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgc2V0RnJhbWUgfSA9IHVzZUNvbnRleHQoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgICByZXR1cm4gc2V0RnJhbWU7XG59O1xuY29uc3QgdXNlUGxheWluZ1N0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmcgfSA9IHVzZUNvbnRleHQoVGltZWxpbmVDb250ZXh0KTtcbiAgICBjb25zdCB7IHNldFBsYXlpbmcgfSA9IHVzZUNvbnRleHQoU2V0VGltZWxpbmVDb250ZXh0KTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBbcGxheWluZywgc2V0UGxheWluZywgaW1wZXJhdGl2ZVBsYXlpbmddLCBbaW1wZXJhdGl2ZVBsYXlpbmcsIHBsYXlpbmcsIHNldFBsYXlpbmddKTtcbn07XG5cbnZhciBUaW1lbGluZVBvc2l0aW9uID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBUaW1lbGluZUNvbnRleHQ6IFRpbWVsaW5lQ29udGV4dCxcbiAgICBTZXRUaW1lbGluZUNvbnRleHQ6IFNldFRpbWVsaW5lQ29udGV4dCxcbiAgICBwZXJzaXN0Q3VycmVudEZyYW1lOiBwZXJzaXN0Q3VycmVudEZyYW1lLFxuICAgIGdldEZyYW1lRm9yQ29tcG9zaXRpb246IGdldEZyYW1lRm9yQ29tcG9zaXRpb24sXG4gICAgdXNlVGltZWxpbmVQb3NpdGlvbjogdXNlVGltZWxpbmVQb3NpdGlvbixcbiAgICB1c2VUaW1lbGluZVNldEZyYW1lOiB1c2VUaW1lbGluZVNldEZyYW1lLFxuICAgIHVzZVBsYXlpbmdTdGF0ZTogdXNlUGxheWluZ1N0YXRlXG59KTtcblxuY29uc3QgQ2FuVXNlUmVtb3Rpb25Ib29rcyA9IGNyZWF0ZUNvbnRleHQoZmFsc2UpO1xuY29uc3QgQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIHJldHVybiAoanN4KENhblVzZVJlbW90aW9uSG9va3MuUHJvdmlkZXIsIHsgdmFsdWU6IHRydWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCB1c2VVbnNhZmVWaWRlb0NvbmZpZyA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCBjdHhEdXJhdGlvbiA9IChfYSA9IGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGV4dC5kdXJhdGlvbkluRnJhbWVzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsO1xuICAgIGNvbnN0IHZpZGVvID0gdXNlVmlkZW8oKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghdmlkZW8pIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIGR1cmF0aW9uSW5GcmFtZXMsIGZwcywgaGVpZ2h0LCB3aWR0aCwgZGVmYXVsdFByb3BzLCBwcm9wcyB9ID0gdmlkZW87XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgZnBzLFxuICAgICAgICAgICAgZHVyYXRpb25JbkZyYW1lczogY3R4RHVyYXRpb24gIT09IG51bGwgJiYgY3R4RHVyYXRpb24gIT09IHZvaWQgMCA/IGN0eER1cmF0aW9uIDogZHVyYXRpb25JbkZyYW1lcyxcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICB9O1xuICAgIH0sIFtjdHhEdXJhdGlvbiwgdmlkZW9dKTtcbn07XG5cbi8qKlxuICogLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0IHNvbWUgaW5mbyBhYm91dCB0aGUgY29udGV4dCBvZiB0aGUgdmlkZW8gdGhhdCB5b3UgYXJlIG1ha2luZy5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3VzZS12aWRlby1jb25maWcpXG4gKiBAcmV0dXJucyBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGBmcHNgLCBgd2lkdGhgLCBgaGVpZ2h0YCBhbmQgYGR1cmF0aW9uSW5GcmFtZXNgLCBhbGwgb2YgdHlwZSBgbnVtYmVyYC5cbiAqL1xuY29uc3QgdXNlVmlkZW9Db25maWcgPSAoKSA9PiB7XG4gICAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICAgIGNvbnN0IGlzUGxheWVyID0gdXNlSXNQbGF5ZXIoKTtcbiAgICBpZiAoIXZpZGVvQ29uZmlnKSB7XG4gICAgICAgIGlmICgodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnJlbW90aW9uX2lzUGxheWVyKSB8fFxuICAgICAgICAgICAgaXNQbGF5ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihbXG4gICAgICAgICAgICAgICAgJ05vIHZpZGVvIGNvbmZpZyBmb3VuZC4gTGlrZWx5IHJlYXNvbnM6JyxcbiAgICAgICAgICAgICAgICAnLSBZb3UgYXJlIHByb2JhYmx5IGNhbGxpbmcgdXNlVmlkZW9Db25maWcoKSBmcm9tIG91dHNpZGUgdGhlIGNvbXBvbmVudCBwYXNzZWQgdG8gPFBsYXllciAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3BsYXllci9leGFtcGxlcyBmb3IgaG93IHRvIHNldCB1cCB0aGUgUGxheWVyIGNvcnJlY3RseS4nLFxuICAgICAgICAgICAgICAgICctIFlvdSBoYXZlIG11bHRpcGxlIHZlcnNpb25zIG9mIFJlbW90aW9uIGluc3RhbGxlZCB3aGljaCBjYXVzZXMgdGhlIFJlYWN0IGNvbnRleHQgdG8gZ2V0IGxvc3QuJyxcbiAgICAgICAgICAgIF0uam9pbignLScpKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHZpZGVvIGNvbmZpZyBmb3VuZC4gWW91IGFyZSBwcm9iYWJseSBjYWxsaW5nIHVzZVZpZGVvQ29uZmlnKCkgZnJvbSBhIGNvbXBvbmVudCB3aGljaCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCBhcyBhIDxDb21wb3NpdGlvbiAvPi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgIH1cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsZWQgdXNlVmlkZW9Db25maWcoKSBvdXRzaWRlIGEgUmVtb3Rpb24gY29tcG9zaXRpb24uJyk7XG4gICAgfVxuICAgIHJldHVybiB2aWRlb0NvbmZpZztcbn07XG5cbmNvbnN0IFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHsgZnJvbSA9IDAsIGR1cmF0aW9uSW5GcmFtZXMgPSBJbmZpbml0eSwgY2hpbGRyZW4sIG5hbWUsIHNob3dJblRpbWVsaW5lID0gdHJ1ZSwgbG9vcERpc3BsYXksIC4uLm90aGVyIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IHsgbGF5b3V0ID0gJ2Fic29sdXRlLWZpbGwnIH0gPSBvdGhlcjtcbiAgICBjb25zdCBbaWRdID0gdXNlU3RhdGUoKCkgPT4gU3RyaW5nKE1hdGgucmFuZG9tKCkpKTtcbiAgICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCB7IHJvb3RJZCB9ID0gdXNlQ29udGV4dChUaW1lbGluZUNvbnRleHQpO1xuICAgIGNvbnN0IGN1bXVsYXRlZEZyb20gPSBwYXJlbnRTZXF1ZW5jZVxuICAgICAgICA/IHBhcmVudFNlcXVlbmNlLmN1bXVsYXRlZEZyb20gKyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb21cbiAgICAgICAgOiAwO1xuICAgIGNvbnN0IG5vbmNlID0gdXNlTm9uY2UoKTtcbiAgICBpZiAobGF5b3V0ICE9PSAnYWJzb2x1dGUtZmlsbCcgJiYgbGF5b3V0ICE9PSAnbm9uZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIGxheW91dCBwcm9wIG9mIDxTZXF1ZW5jZSAvPiBleHBlY3RzIGVpdGhlciBcImFic29sdXRlLWZpbGxcIiBvciBcIm5vbmVcIiwgYnV0IHlvdSBwYXNzZWQ6ICR7bGF5b3V0fWApO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgaWYgKGxheW91dCA9PT0gJ25vbmUnICYmIHR5cGVvZiBvdGhlci5zdHlsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSWYgbGF5b3V0PVwibm9uZVwiLCB5b3UgbWF5IG5vdCBwYXNzIGEgc3R5bGUuJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZHVyYXRpb25JbkZyYW1lcyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byBkdXJhdGlvbkluRnJhbWVzIGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZHVyYXRpb25JbkZyYW1lc30sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICAgIH1cbiAgICBpZiAoZHVyYXRpb25JbkZyYW1lcyA8PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGR1cmF0aW9uSW5GcmFtZXMgbXVzdCBiZSBwb3NpdGl2ZSwgYnV0IGdvdCAke2R1cmF0aW9uSW5GcmFtZXN9YCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnJvbSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCB0byB0aGUgXCJmcm9tXCIgcHJvcHMgb2YgeW91ciA8U2VxdWVuY2U+IGFuIGFyZ3VtZW50IG9mIHR5cGUgJHt0eXBlb2YgZnJvbX0sIGJ1dCBpdCBtdXN0IGJlIGEgbnVtYmVyLmApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShmcm9tKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJmcm9tXCIgcHJvcCBvZiBhIHNlcXVlbmNlIG11c3QgYmUgZmluaXRlLCBidXQgZ290ICR7ZnJvbX0uYCk7XG4gICAgfVxuICAgIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VWaWRlb0NvbmZpZygpO1xuICAgIGNvbnN0IHBhcmVudFNlcXVlbmNlRHVyYXRpb24gPSBwYXJlbnRTZXF1ZW5jZVxuICAgICAgICA/IE1hdGgubWluKHBhcmVudFNlcXVlbmNlLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBkdXJhdGlvbkluRnJhbWVzKVxuICAgICAgICA6IGR1cmF0aW9uSW5GcmFtZXM7XG4gICAgY29uc3QgYWN0dWFsRHVyYXRpb25JbkZyYW1lcyA9IE1hdGgubWF4KDAsIE1hdGgubWluKHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXMgLSBmcm9tLCBwYXJlbnRTZXF1ZW5jZUR1cmF0aW9uKSk7XG4gICAgY29uc3QgeyByZWdpc3RlclNlcXVlbmNlLCB1bnJlZ2lzdGVyU2VxdWVuY2UgfSA9IHVzZUNvbnRleHQoU2VxdWVuY2VNYW5hZ2VyKTtcbiAgICBjb25zdCBjb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VtdWxhdGVkRnJvbSxcbiAgICAgICAgICAgIHJlbGF0aXZlRnJvbTogZnJvbSxcbiAgICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgICBwYXJlbnRGcm9tOiAoX2EgPSBwYXJlbnRTZXF1ZW5jZSA9PT0gbnVsbCB8fCBwYXJlbnRTZXF1ZW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBjdW11bGF0ZWRGcm9tLFxuICAgICAgICBmcm9tLFxuICAgICAgICBhY3R1YWxEdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBwYXJlbnRTZXF1ZW5jZSA9PT0gbnVsbCB8fCBwYXJlbnRTZXF1ZW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U2VxdWVuY2UucmVsYXRpdmVGcm9tLFxuICAgICAgICBpZCxcbiAgICBdKTtcbiAgICBjb25zdCB0aW1lbGluZUNsaXBOYW1lID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBnZXRUaW1lbGluZUNsaXBOYW1lKGNoaWxkcmVuKTtcbiAgICB9LCBbY2hpbGRyZW4sIG5hbWVdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXJTZXF1ZW5jZSh7XG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgZHVyYXRpb246IGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiB0aW1lbGluZUNsaXBOYW1lLFxuICAgICAgICAgICAgcGFyZW50OiAoX2EgPSBwYXJlbnRTZXF1ZW5jZSA9PT0gbnVsbCB8fCBwYXJlbnRTZXF1ZW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U2VxdWVuY2UuaWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgICAgICB0eXBlOiAnc2VxdWVuY2UnLFxuICAgICAgICAgICAgcm9vdElkLFxuICAgICAgICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIGxvb3BEaXNwbGF5LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBpZCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgcmVnaXN0ZXJTZXF1ZW5jZSxcbiAgICAgICAgdGltZWxpbmVDbGlwTmFtZSxcbiAgICAgICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgICAgICBwYXJlbnRTZXF1ZW5jZSA9PT0gbnVsbCB8fCBwYXJlbnRTZXF1ZW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50U2VxdWVuY2UuaWQsXG4gICAgICAgIGFjdHVhbER1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgc2hvd0luVGltZWxpbmUsXG4gICAgICAgIG5vbmNlLFxuICAgICAgICBsb29wRGlzcGxheSxcbiAgICBdKTtcbiAgICAvLyBDZWlsIHRvIHN1cHBvcnQgZmxvYXRzXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbW90aW9uLWRldi9yZW1vdGlvbi9pc3N1ZXMvMjk1OFxuICAgIGNvbnN0IGVuZFRocmVzaG9sZCA9IE1hdGguY2VpbChjdW11bGF0ZWRGcm9tICsgZnJvbSArIGR1cmF0aW9uSW5GcmFtZXMgLSAxKTtcbiAgICBjb25zdCBjb250ZW50ID0gYWJzb2x1dGVGcmFtZSA8IGN1bXVsYXRlZEZyb20gKyBmcm9tXG4gICAgICAgID8gbnVsbFxuICAgICAgICA6IGFic29sdXRlRnJhbWUgPiBlbmRUaHJlc2hvbGRcbiAgICAgICAgICAgID8gbnVsbFxuICAgICAgICAgICAgOiBjaGlsZHJlbjtcbiAgICBjb25zdCBzdHlsZUlmVGhlcmUgPSBvdGhlci5sYXlvdXQgPT09ICdub25lJyA/IHVuZGVmaW5lZCA6IG90aGVyLnN0eWxlO1xuICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmxleERpcmVjdGlvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgLi4uKHN0eWxlSWZUaGVyZSAhPT0gbnVsbCAmJiBzdHlsZUlmVGhlcmUgIT09IHZvaWQgMCA/IHN0eWxlSWZUaGVyZSA6IHt9KSxcbiAgICAgICAgfTtcbiAgICB9LCBbc3R5bGVJZlRoZXJlXSk7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCAmJiBsYXlvdXQgPT09ICdub25lJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJdCBpcyBub3Qgc3VwcG9ydGVkIHRvIHBhc3MgYm90aCBhIGByZWZgIGFuZCBgbGF5b3V0PVwibm9uZVwiYCB0byA8U2VxdWVuY2UgLz4uJyk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFNlcXVlbmNlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dFZhbHVlLCBjaGlsZHJlbjogY29udGVudCA9PT0gbnVsbCA/IG51bGwgOiBvdGhlci5sYXlvdXQgPT09ICdub25lJyA/IChjb250ZW50KSA6IChqc3goQWJzb2x1dGVGaWxsLCB7IHJlZjogcmVmLCBzdHlsZTogZGVmYXVsdFN0eWxlLCBjbGFzc05hbWU6IG90aGVyLmNsYXNzTmFtZSwgY2hpbGRyZW46IGNvbnRlbnQgfSkpIH0pKTtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBBIGNvbXBvbmVudCB0aGF0IHRpbWUtc2hpZnRzIGl0cyBjaGlsZHJlbiBhbmQgd3JhcHMgdGhlbSBpbiBhbiBhYnNvbHV0ZWx5IHBvc2l0aW9uZWQgPGRpdj4uXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9zZXF1ZW5jZSlcbiAqL1xuY29uc3QgU2VxdWVuY2UgPSBmb3J3YXJkUmVmKFNlcXVlbmNlUmVmRm9yd2FyZGluZ0Z1bmN0aW9uKTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBjdXJyZW50IGZyYW1lIG9mIHRoZSB2aWRlby4gRnJhbWVzIGFyZSAwLWluZGV4ZWQsIG1lYW5pbmcgdGhlIGZpcnN0IGZyYW1lIGlzIDAsIHRoZSBsYXN0IGZyYW1lIGlzIHRoZSBkdXJhdGlvbiBvZiB0aGUgY29tcG9zaXRpb24gaW4gZnJhbWVzIG1pbnVzIG9uZS5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvdXNlLWN1cnJlbnQtZnJhbWUpXG4gKi9cbmNvbnN0IHVzZUN1cnJlbnRGcmFtZSA9ICgpID0+IHtcbiAgICBjb25zdCBjYW5Vc2VSZW1vdGlvbkhvb2tzID0gdXNlQ29udGV4dChDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgICBpZiAoIWNhblVzZVJlbW90aW9uSG9va3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5yZW1vdGlvbl9pc1BsYXllcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUgY2FuIG9ubHkgYmUgY2FsbGVkIGluc2lkZSBhIGNvbXBvbmVudCB0aGF0IHdhcyBwYXNzZWQgdG8gPFBsYXllcj4uIFNlZTogaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcGxheWVyL2V4YW1wbGVzYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1c2VDdXJyZW50RnJhbWUoKSBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIGEgY29tcG9uZW50IHRoYXQgd2FzIHJlZ2lzdGVyZWQgYXMgYSBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3RoZS1mdW5kYW1lbnRhbHMjZGVmaW5pbmctY29tcG9zaXRpb25zYCk7XG4gICAgfVxuICAgIGNvbnN0IGZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFNlcXVlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgY29udGV4dE9mZnNldCA9IGNvbnRleHRcbiAgICAgICAgPyBjb250ZXh0LmN1bXVsYXRlZEZyb20gKyBjb250ZXh0LnJlbGF0aXZlRnJvbVxuICAgICAgICA6IDA7XG4gICAgcmV0dXJuIGZyYW1lIC0gY29udGV4dE9mZnNldDtcbn07XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgY29tcG9uZW50IGFsbG93cyB5b3UgdG8gcXVpY2tseSBsYXkgb3V0IGFuIGFuaW1hdGlvbiBzbyBpdCByZXBlYXRzIGl0c2VsZi5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2xvb3ApXG4gKi9cbmNvbnN0IExvb3AgPSAoeyBkdXJhdGlvbkluRnJhbWVzLCB0aW1lcyA9IEluZmluaXR5LCBjaGlsZHJlbiwgbmFtZSwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIGNvbnN0IGN1cnJlbnRGcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICAgIGNvbnN0IHsgZHVyYXRpb25JbkZyYW1lczogY29tcER1cmF0aW9uIH0gPSB1c2VWaWRlb0NvbmZpZygpO1xuICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzLCB7XG4gICAgICAgIGNvbXBvbmVudDogJ29mIHRoZSA8TG9vcCAvPiBjb21wb25lbnQnLFxuICAgICAgICBhbGxvd0Zsb2F0czogdHJ1ZSxcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIHRpbWVzICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIHRvIFwidGltZXNcIiBhbiBhcmd1bWVudCBvZiB0eXBlICR7dHlwZW9mIHRpbWVzfSwgYnV0IGl0IG11c3QgYmUgYSBudW1iZXIuYCk7XG4gICAgfVxuICAgIGlmICh0aW1lcyAhPT0gSW5maW5pdHkgJiYgdGltZXMgJSAxICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhbiBpbnRlZ2VyLCBidXQgZ290ICR7dGltZXN9LmApO1xuICAgIH1cbiAgICBpZiAodGltZXMgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFRoZSBcInRpbWVzXCIgcHJvcCBvZiBhIGxvb3AgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7dGltZXN9YCk7XG4gICAgfVxuICAgIGNvbnN0IG1heFRpbWVzID0gTWF0aC5jZWlsKGNvbXBEdXJhdGlvbiAvIGR1cmF0aW9uSW5GcmFtZXMpO1xuICAgIGNvbnN0IGFjdHVhbFRpbWVzID0gTWF0aC5taW4obWF4VGltZXMsIHRpbWVzKTtcbiAgICBjb25zdCBzdHlsZSA9IHByb3BzLmxheW91dCA9PT0gJ25vbmUnID8gdW5kZWZpbmVkIDogcHJvcHMuc3R5bGU7XG4gICAgY29uc3QgbWF4RnJhbWUgPSBkdXJhdGlvbkluRnJhbWVzICogKGFjdHVhbFRpbWVzIC0gMSk7XG4gICAgY29uc3Qgc3RhcnQgPSBNYXRoLmZsb29yKGN1cnJlbnRGcmFtZSAvIGR1cmF0aW9uSW5GcmFtZXMpICogZHVyYXRpb25JbkZyYW1lcztcbiAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oc3RhcnQsIG1heEZyYW1lKTtcbiAgICBjb25zdCBsb29wRGlzcGxheSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtYmVyT2ZUaW1lczogYWN0dWFsVGltZXMsXG4gICAgICAgICAgICBzdGFydE9mZnNldDogLWZyb20sXG4gICAgICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICB9O1xuICAgIH0sIFthY3R1YWxUaW1lcywgZHVyYXRpb25JbkZyYW1lcywgZnJvbV0pO1xuICAgIHJldHVybiAoanN4KFNlcXVlbmNlLCB7IGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXMsIGZyb206IGZyb20sIG5hbWU6IG5hbWUsIGxvb3BEaXNwbGF5OiBsb29wRGlzcGxheSwgbGF5b3V0OiBwcm9wcy5sYXlvdXQsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IHZhbGlkYXRlTWVkaWFQcm9wcyA9IChwcm9wcywgY29tcG9uZW50KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBwcm9wcy52b2x1bWUgIT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBwcm9wcy52b2x1bWUgIT09ICdmdW5jdGlvbicgJiZcbiAgICAgICAgdHlwZW9mIHByb3BzLnZvbHVtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGhhdmUgcGFzc2VkIGEgdm9sdW1lIG9mIHR5cGUgJHt0eXBlb2YgcHJvcHMudm9sdW1lfSB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBhIG51bWJlciBvciBhIGZ1bmN0aW9uIHdpdGggdGhlIHNpZ25hdHVyZSAnKGZyYW1lOiBudW1iZXIpID0+IG51bWJlcicgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BzLnZvbHVtZSA9PT0gJ251bWJlcicgJiYgcHJvcHMudm9sdW1lIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgaGF2ZSBwYXNzZWQgYSB2b2x1bWUgYmVsb3cgMCB0byB5b3VyIDwke2NvbXBvbmVudH0gLz4gY29tcG9uZW50LiBWb2x1bWUgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDFgKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09ICdudW1iZXInICYmXG4gICAgICAgIHR5cGVvZiBwcm9wcy5wbGF5YmFja1JhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiB0eXBlICR7dHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGEgcmVhbCBudW1iZXIgb3IgdW5kZWZpbmVkLmApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHByb3BzLnBsYXliYWNrUmF0ZSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgKGlzTmFOKHByb3BzLnBsYXliYWNrUmF0ZSkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNGaW5pdGUocHJvcHMucGxheWJhY2tSYXRlKSB8fFxuICAgICAgICAgICAgcHJvcHMucGxheWJhY2tSYXRlIDw9IDApKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBoYXZlIHBhc3NlZCBhIHBsYXliYWNrUmF0ZSBvZiAke3Byb3BzLnBsYXliYWNrUmF0ZX0gdG8geW91ciA8JHtjb21wb25lbnR9IC8+IGNvbXBvbmVudC4gUGxheWJhY2sgcmF0ZSBtdXN0IGJlIGEgcmVhbCBudW1iZXIgYWJvdmUgMC5gKTtcbiAgICB9XG59O1xuXG5jb25zdCB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzID0gKHN0YXJ0RnJvbSwgZW5kQXQpID0+IHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFydEZyb20gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIHN0YXJ0RnJvbSBwcm9wIG11c3QgYmUgYSBudW1iZXIsIGluc3RlYWQgZ290IHR5cGUgJHt0eXBlb2Ygc3RhcnRGcm9tfS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOYU4oc3RhcnRGcm9tKSB8fCBzdGFydEZyb20gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzdGFydEZyb20gcHJvcCBjYW4gbm90IGJlIE5hTiBvciBJbmZpbml0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRGcm9tIDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgc3RhcnRGcm9tIG11c3QgYmUgZ3JlYXRlciB0aGFuIGVxdWFsIHRvIDAgaW5zdGVhZCBnb3QgJHtzdGFydEZyb219LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5kQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW5kQXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGB0eXBlIG9mIGVuZEF0IHByb3AgbXVzdCBiZSBhIG51bWJlciwgaW5zdGVhZCBnb3QgdHlwZSAke3R5cGVvZiBlbmRBdH0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmFOKGVuZEF0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5kQXQgcHJvcCBjYW4gbm90IGJlIE5hTi4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kQXQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgZW5kQXQgbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlciwgaW5zdGVhZCBnb3QgJHtlbmRBdH0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuZEF0IDwgc3RhcnRGcm9tKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuZEF0IHByb3AgbXVzdCBiZSBncmVhdGVyIHRoYW4gc3RhcnRGcm9tIHByb3AuJyk7XG4gICAgfVxufTtcblxuY29uc3QgZHVyYXRpb25SZWR1Y2VyID0gKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2dvdC1kdXJhdGlvbic6XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLnN0YXRlLFxuICAgICAgICAgICAgICAgIFtnZXRBYnNvbHV0ZVNyYyhhY3Rpb24uc3JjKV06IGFjdGlvbi5kdXJhdGlvbkluU2Vjb25kcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxufTtcbmNvbnN0IER1cmF0aW9uc0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICBkdXJhdGlvbnM6IHt9LFxuICAgIHNldER1cmF0aW9uczogKCkgPT4ge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbnRleHQgbWlzc2luZycpO1xuICAgIH0sXG59KTtcbmNvbnN0IER1cmF0aW9uc0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBbZHVyYXRpb25zLCBzZXREdXJhdGlvbnNdID0gdXNlUmVkdWNlcihkdXJhdGlvblJlZHVjZXIsIHt9KTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZHVyYXRpb25zLFxuICAgICAgICAgICAgc2V0RHVyYXRpb25zLFxuICAgICAgICB9O1xuICAgIH0sIFtkdXJhdGlvbnNdKTtcbiAgICByZXR1cm4gKGpzeChEdXJhdGlvbnNDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IFByZWxvYWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7fSk7XG5sZXQgcHJlbG9hZHMgPSB7fTtcbmxldCB1cGRhdGVycyA9IFtdO1xuY29uc3Qgc2V0UHJlbG9hZHMgPSAodXBkYXRlcikgPT4ge1xuICAgIHByZWxvYWRzID0gdXBkYXRlcihwcmVsb2Fkcyk7XG4gICAgdXBkYXRlcnMuZm9yRWFjaCgodSkgPT4gdSgpKTtcbn07XG5jb25zdCBQcmVmZXRjaFByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IFtfcHJlbG9hZHMsIF9zZXRQcmVsb2Fkc10gPSB1c2VTdGF0ZSgoKSA9PiBwcmVsb2Fkcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlckZ1bmN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgX3NldFByZWxvYWRzKHByZWxvYWRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlcnMucHVzaCh1cGRhdGVyRnVuY3Rpb24pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdXBkYXRlcnMgPSB1cGRhdGVycy5maWx0ZXIoKHUpID0+IHUgIT09IHVwZGF0ZXJGdW5jdGlvbik7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoanN4KFByZWxvYWRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBfcHJlbG9hZHMsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCB1c2VQcmVsb2FkID0gKHNyYykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwcmVsb2FkcyA9IHVzZUNvbnRleHQoUHJlbG9hZENvbnRleHQpO1xuICAgIHJldHVybiAoX2EgPSBwcmVsb2Fkc1tzcmNdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzcmM7XG59O1xuY29uc3QgYmxvYlRvQmFzZTY0ID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRhVXJsID0gcmVhZGVyLnJlc3VsdDtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YVVybCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5vbmVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICB9KTtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXaGVuIHlvdSBjYWxsIHRoZSBwcmVGZXRjaCgpIGZ1bmN0aW9uLCBhbiBhc3NldCB3aWxsIGJlIGZldGNoZWQgYW5kIGtlcHQgaW4gbWVtb3J5IHNvIGl0IGlzIHJlYWR5IHdoZW4geW91IHdhbnQgdG8gcGxheSBpdCBpbiBhIDxQbGF5ZXI+LlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcHJlZmV0Y2gpXG4gKi9cbmNvbnN0IHByZWZldGNoID0gKHNyYywgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtZXRob2QgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWV0aG9kKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnYmxvYi11cmwnO1xuICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyZWU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHdhaXRVbnRpbERvbmU6ICgpID0+IFByb21pc2UucmVzb2x2ZShzcmMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgY2FuY2VsZWQgPSBmYWxzZTtcbiAgICBsZXQgb2JqZWN0VXJsID0gbnVsbDtcbiAgICBsZXQgcmVzb2x2ZSA9ICgpID0+IHVuZGVmaW5lZDtcbiAgICBsZXQgcmVqZWN0ID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgIGNvbnN0IHdhaXRVbnRpbERvbmUgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgcmVqZWN0ID0gcmVqO1xuICAgIH0pO1xuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgbGV0IGNhbkJlQWJvcnRlZCA9IHRydWU7XG4gICAgZmV0Y2goc3JjLCB7XG4gICAgICAgIHNpZ25hbDogY29udHJvbGxlci5zaWduYWwsXG4gICAgfSlcbiAgICAgICAgLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICBjYW5CZUFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGNhbmNlbGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yLCBzdGF0dXMgPSAke3Jlcy5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcy5ibG9iKCk7XG4gICAgfSlcbiAgICAgICAgLnRoZW4oKGJ1ZikgPT4ge1xuICAgICAgICBpZiAoIWJ1Zikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYnVmLnR5cGUuc3RhcnRzV2l0aCgndmlkZW8vJykgJiZcbiAgICAgICAgICAgICFidWYudHlwZS5zdGFydHNXaXRoKCdhdWRpby8nKSAmJlxuICAgICAgICAgICAgIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGVudFR5cGUpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENhbGxlZCBwcmVmZXRjaCgpIG9uICR7c3JjfSB3aGljaCByZXR1cm5lZCBhIFwiQ29udGVudC1UeXBlXCIgb2YgJHtidWYudHlwZX0uIFByZWZldGNoZWQgY29udGVudCBzaG91bGQgaGF2ZSBhIHByb3BlciBjb250ZW50IHR5cGUgKHZpZGVvLy4uLiBvciBhdWRpby8uLi4pIG9yIGEgY29udGVudFR5cGUgcGFzc2VkIHRoZSBvcHRpb25zIG9mIHByZWZldGNoKCkuIE90aGVyd2lzZSwgcHJlZmV0Y2hpbmcgd2lsbCBub3Qgd29yayBwcm9wZXJseSBpbiBhbGwgYnJvd3NlcnMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWN0dWFsQmxvYiA9IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY29udGVudFR5cGUpXG4gICAgICAgICAgICA/IG5ldyBCbG9iKFtidWZdLCB7IHR5cGU6IG9wdGlvbnMuY29udGVudFR5cGUgfSlcbiAgICAgICAgICAgIDogYnVmO1xuICAgICAgICBpZiAobWV0aG9kID09PSAnYmFzZTY0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2JUb0Jhc2U2NChhY3R1YWxCbG9iKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChhY3R1YWxCbG9iKTtcbiAgICB9KVxuICAgICAgICAudGhlbigodXJsKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFVybCA9IHVybDtcbiAgICAgICAgc2V0UHJlbG9hZHMoKHApID0+ICh7XG4gICAgICAgICAgICAuLi5wLFxuICAgICAgICAgICAgW3NyY106IG9iamVjdFVybCxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXNvbHZlKG9iamVjdFVybCk7XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJlZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKG9iamVjdFVybCkge1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09ICdibG9iLXVybCcpIHtcbiAgICAgICAgICAgICAgICAgICAgVVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZXRQcmVsb2FkcygocCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5ID0geyAuLi5wIH07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBjb3B5W3NyY107XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3B5O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChjYW5CZUFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB3YWl0VW50aWxEb25lOiAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gd2FpdFVudGlsRG9uZTtcbiAgICAgICAgfSxcbiAgICB9O1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuZnVuY3Rpb24gbXVsYmVycnkzMihhKSB7XG4gICAgbGV0IHQgPSBhICsgMHg2ZDJiNzlmNTtcbiAgICB0ID0gTWF0aC5pbXVsKHQgXiAodCA+Pj4gMTUpLCB0IHwgMSk7XG4gICAgdCBePSB0ICsgTWF0aC5pbXVsKHQgXiAodCA+Pj4gNyksIHQgfCA2MSk7XG4gICAgcmV0dXJuICgodCBeICh0ID4+PiAxNCkpID4+PiAwKSAvIDQyOTQ5NjcyOTY7XG59XG5mdW5jdGlvbiBoYXNoQ29kZShzdHIpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGNociA9IDA7XG4gICAgbGV0IGhhc2ggPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSAoaGFzaCA8PCA1KSAtIGhhc2ggKyBjaHI7XG4gICAgICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gICAgfVxuICAgIHJldHVybiBoYXNoO1xufVxuLyoqXG4gKiBAZGVzY3JpcHRpb24gQSBkZXRlcm1pbmlzdGljIHBzZXVkby1yYW5kb20gbnVtYmVyIGdlbmVyYXRvci4gUGFzcyBpbiB0aGUgc2FtZSBzZWVkIGFuZCBnZXQgdGhlIHNhbWUgcHNldWRvcmFuZG9tIG51bWJlci5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvcmFuZG9tKVxuICovXG5jb25zdCByYW5kb20gPSAoc2VlZCwgZHVtbXkpID0+IHtcbiAgICBpZiAoZHVtbXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdyYW5kb20oKSB0YWtlcyBvbmx5IG9uZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoc2VlZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTWF0aC5yYW5kb20oKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzZWVkID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbXVsYmVycnkzMihoYXNoQ29kZShzZWVkKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc2VlZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG11bGJlcnJ5MzIoc2VlZCAqIDEwMDAwMDAwMDAwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdyYW5kb20oKSBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyIG9yIGEgc3RyaW5nJyk7XG59O1xuXG5jb25zdCB1c2VNZWRpYVN0YXJ0c0F0ID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCBzdGFydHNBdCA9IE1hdGgubWluKDAsIChfYSA9IHBhcmVudFNlcXVlbmNlID09PSBudWxsIHx8IHBhcmVudFNlcXVlbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApO1xuICAgIHJldHVybiBzdGFydHNBdDtcbn07XG4vKipcbiAqIFdoZW4gcGFzc2luZyBhIGZ1bmN0aW9uIGFzIHRoZSBwcm9wIGZvciBgdm9sdW1lYCxcbiAqIHdlIGNhbGN1bGF0ZSB0aGUgd2F5IG1vcmUgaW50dWl0aXZlIHZhbHVlIGZvciBjdXJyZW50RnJhbWVcbiAqL1xuY29uc3QgdXNlRnJhbWVGb3JWb2x1bWVQcm9wID0gKCkgPT4ge1xuICAgIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gICAgY29uc3Qgc3RhcnRzQXQgPSB1c2VNZWRpYVN0YXJ0c0F0KCk7XG4gICAgcmV0dXJuIGZyYW1lICsgc3RhcnRzQXQ7XG59O1xuXG5jb25zdCBnZXRBc3NldERpc3BsYXlOYW1lID0gKGZpbGVuYW1lKSA9PiB7XG4gICAgaWYgKC9kYXRhOnxibG9iOi8udGVzdChmaWxlbmFtZS5zdWJzdHJpbmcoMCwgNSkpKSB7XG4gICAgICAgIHJldHVybiAnRGF0YSBVUkwnO1xuICAgIH1cbiAgICBjb25zdCBzcGxpdHRlZCA9IGZpbGVuYW1lXG4gICAgICAgIC5zcGxpdCgnLycpXG4gICAgICAgIC5tYXAoKHMpID0+IHMuc3BsaXQoJ1xcXFwnKSlcbiAgICAgICAgLmZsYXQoMSk7XG4gICAgcmV0dXJuIHNwbGl0dGVkW3NwbGl0dGVkLmxlbmd0aCAtIDFdO1xufTtcblxuY29uc3QgcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvciA9IChtZWRpYVJlZiwgbWVkaWFUeXBlKSA9PiB7XG4gICAgY29uc3QgeyBjdXJyZW50IH0gPSBtZWRpYVJlZjtcbiAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcm9tID0gY3VycmVudC5wbGF5KCk7XG4gICAgaWYgKHByb20uY2F0Y2gpIHtcbiAgICAgICAgcHJvbS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQYXVzZSB3YXMgY2FsbGVkIGFmdGVyIHBsYXkgaW4gQ2hyb21lXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3JlcXVlc3Qgd2FzIGludGVycnVwdGVkIGJ5IGEgY2FsbCB0byBwYXVzZScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGF1c2Ugd2FzIGNhbGxlZCBhZnRlciBwbGF5IGluIFNhZmFyaVxuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdUaGUgb3BlcmF0aW9uIHdhcyBhYm9ydGVkLicpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGF1c2Ugd2FzIGNhbGxlZCBhZnRlciBwbGF5IGluIEZpcmVmb3hcbiAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmNsdWRlcygnVGhlIGZldGNoaW5nIHByb2Nlc3MgZm9yIHRoZSBtZWRpYSByZXNvdXJjZSB3YXMgYWJvcnRlZCBieSB0aGUgdXNlciBhZ2VudCcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR290IHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IGF1ZGlvIHNvdXJjZSBpbiBDaHJvbWl1bVxuICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluY2x1ZGVzKCdyZXF1ZXN0IHdhcyBpbnRlcnJ1cHRlZCBieSBhIG5ldyBsb2FkIHJlcXVlc3QnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEF1ZGlvIHRhZyBnb3QgdW5tb3VudGVkXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ2JlY2F1c2UgdGhlIG1lZGlhIHdhcyByZW1vdmVkIGZyb20gdGhlIGRvY3VtZW50JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgQ291bGQgbm90IHBsYXkgJHttZWRpYVR5cGV9IGR1ZSB0byBmb2xsb3dpbmcgZXJyb3I6IGAsIGVycik7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQubXV0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVGhlIHZpZGVvIHdpbGwgYmUgbXV0ZWQgYW5kIHdlJ2xsIHJldHJ5IHBsYXlpbmcgaXQuYCwgZXJyKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnBsYXkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufTtcblxuY29uc3QgZXZhbHVhdGVWb2x1bWUgPSAoeyBmcmFtZSwgdm9sdW1lLCBtZWRpYVZvbHVtZSA9IDEsIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciwgfSkgPT4ge1xuICAgIGNvbnN0IG1heFZvbHVtZSA9IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA/IEluZmluaXR5IDogMTtcbiAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKG1heFZvbHVtZSwgdm9sdW1lICogbWVkaWFWb2x1bWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcihtZWRpYVZvbHVtZSk7XG4gICAgfVxuICAgIGNvbnN0IGV2YWx1YXRlZCA9IHZvbHVtZShmcmFtZSkgKiBtZWRpYVZvbHVtZTtcbiAgICBpZiAodHlwZW9mIGV2YWx1YXRlZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IHBhc3NlZCBpbiBhIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCBkaWQgbm90IHJldHVybiBhIG51bWJlciBidXQgYSB2YWx1ZSBvZiB0eXBlICR7dHlwZW9mIGV2YWx1YXRlZH0gZm9yIGZyYW1lICR7ZnJhbWV9YCk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4oZXZhbHVhdGVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBZb3UgcGFzc2VkIGluIGEgZnVuY3Rpb24gdG8gdGhlIHZvbHVtZSBwcm9wIGJ1dCBpdCByZXR1cm5lZCBOYU4gZm9yIGZyYW1lICR7ZnJhbWV9LmApO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShldmFsdWF0ZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFlvdSBwYXNzZWQgaW4gYSBmdW5jdGlvbiB0byB0aGUgdm9sdW1lIHByb3AgYnV0IGl0IHJldHVybmVkIGEgbm9uLWZpbml0ZSBudW1iZXIgZm9yIGZyYW1lICR7ZnJhbWV9LmApO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4Vm9sdW1lLCBldmFsdWF0ZWQpKTtcbn07XG5cbmNvbnN0IGRpZFdhcm4gPSB7fTtcbmNvbnN0IHdhcm5PbmNlID0gKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAoZGlkV2FyblttZXNzYWdlXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICBkaWRXYXJuW21lc3NhZ2VdID0gdHJ1ZTtcbn07XG5jb25zdCB1c2VNZWRpYUluVGltZWxpbmUgPSAoeyB2b2x1bWUsIG1lZGlhVm9sdW1lLCBtZWRpYVJlZiwgc3JjLCBtZWRpYVR5cGUsIHBsYXliYWNrUmF0ZSwgfSkgPT4ge1xuICAgIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCB7IHJvb3RJZCwgYXVkaW9BbmRWaWRlb1RhZ3MgfSA9IHVzZUNvbnRleHQoVGltZWxpbmVDb250ZXh0KTtcbiAgICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2VcbiAgICAgICAgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gKyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tXG4gICAgICAgIDogMDtcbiAgICBjb25zdCBbcGxheWluZ10gPSB1c2VQbGF5aW5nU3RhdGUoKTtcbiAgICBjb25zdCBzdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgICBjb25zdCB7IHJlZ2lzdGVyU2VxdWVuY2UsIHVucmVnaXN0ZXJTZXF1ZW5jZSB9ID0gdXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICAgIGNvbnN0IFtpZF0gPSB1c2VTdGF0ZSgoKSA9PiBTdHJpbmcoTWF0aC5yYW5kb20oKSkpO1xuICAgIGNvbnN0IFtpbml0aWFsVm9sdW1lXSA9IHVzZVN0YXRlKCgpID0+IHZvbHVtZSk7XG4gICAgY29uc3Qgbm9uY2UgPSB1c2VOb25jZSgpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gcGFyZW50U2VxdWVuY2VcbiAgICAgICAgPyBNYXRoLm1pbihwYXJlbnRTZXF1ZW5jZS5kdXJhdGlvbkluRnJhbWVzLCB2aWRlb0NvbmZpZy5kdXJhdGlvbkluRnJhbWVzKVxuICAgICAgICA6IHZpZGVvQ29uZmlnLmR1cmF0aW9uSW5GcmFtZXM7XG4gICAgY29uc3QgZG9lc1ZvbHVtZUNoYW5nZSA9IHR5cGVvZiB2b2x1bWUgPT09ICdmdW5jdGlvbic7XG4gICAgY29uc3Qgdm9sdW1lcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZvbHVtZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiB2b2x1bWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBBcnJheShNYXRoLmZsb29yKE1hdGgubWF4KDAsIGR1cmF0aW9uICsgc3RhcnRzQXQpKSlcbiAgICAgICAgICAgIC5maWxsKHRydWUpXG4gICAgICAgICAgICAubWFwKChfLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICAgICAgICAgIGZyYW1lOiBpICsgc3RhcnRzQXQsXG4gICAgICAgICAgICAgICAgdm9sdW1lLFxuICAgICAgICAgICAgICAgIG1lZGlhVm9sdW1lLFxuICAgICAgICAgICAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5qb2luKCcsJyk7XG4gICAgfSwgW2R1cmF0aW9uLCBzdGFydHNBdCwgdm9sdW1lLCBtZWRpYVZvbHVtZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2Ygdm9sdW1lID09PSAnbnVtYmVyJyAmJiB2b2x1bWUgIT09IGluaXRpYWxWb2x1bWUpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGBSZW1vdGlvbjogVGhlICR7bWVkaWFUeXBlfSB3aXRoIHNyYyAke3NyY30gaGFzIGNoYW5nZWQgaXQncyB2b2x1bWUuIFByZWZlciB0aGUgY2FsbGJhY2sgc3ludGF4IGZvciBzZXR0aW5nIHZvbHVtZSB0byBnZXQgYmV0dGVyIHRpbWVsaW5lIGRpc3BsYXk6IGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3VzaW5nLWF1ZGlvLyNjb250cm9sbGluZy12b2x1bWVgKTtcbiAgICAgICAgfVxuICAgIH0sIFtpbml0aWFsVm9sdW1lLCBtZWRpYVR5cGUsIHNyYywgdm9sdW1lXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIW1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzcmMgcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNTdHVkaW8gJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0Jykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVyU2VxdWVuY2Uoe1xuICAgICAgICAgICAgdHlwZTogbWVkaWFUeXBlLFxuICAgICAgICAgICAgc3JjLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIGZyb206IDAsXG4gICAgICAgICAgICBwYXJlbnQ6IChfYSA9IHBhcmVudFNlcXVlbmNlID09PSBudWxsIHx8IHBhcmVudFNlcXVlbmNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnRTZXF1ZW5jZS5pZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBnZXRBc3NldERpc3BsYXlOYW1lKHNyYyksXG4gICAgICAgICAgICByb290SWQsXG4gICAgICAgICAgICB2b2x1bWU6IHZvbHVtZXMsXG4gICAgICAgICAgICBzaG93SW5UaW1lbGluZTogdHJ1ZSxcbiAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgc3RhcnRNZWRpYUZyb206IDAgLSBzdGFydHNBdCxcbiAgICAgICAgICAgIGRvZXNWb2x1bWVDaGFuZ2UsXG4gICAgICAgICAgICBsb29wRGlzcGxheTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJTZXF1ZW5jZShpZCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBhY3R1YWxGcm9tLFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgaWQsXG4gICAgICAgIHBhcmVudFNlcXVlbmNlLFxuICAgICAgICBzcmMsXG4gICAgICAgIHJlZ2lzdGVyU2VxdWVuY2UsXG4gICAgICAgIHJvb3RJZCxcbiAgICAgICAgdW5yZWdpc3RlclNlcXVlbmNlLFxuICAgICAgICB2aWRlb0NvbmZpZyxcbiAgICAgICAgdm9sdW1lcyxcbiAgICAgICAgZG9lc1ZvbHVtZUNoYW5nZSxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIHN0YXJ0c0F0LFxuICAgICAgICBwbGF5YmFja1JhdGUsXG4gICAgXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFnID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwbGF5OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGF5aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IHBsYXkgaWYgZm9yIGV4YW1wbGUgaW4gYSA8RnJlZXplPiBzdGF0ZS5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGxheUFuZEhhbmRsZU5vdEFsbG93ZWRFcnJvcihtZWRpYVJlZiwgbWVkaWFUeXBlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQucHVzaCh0YWcpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgYXVkaW9BbmRWaWRlb1RhZ3MuY3VycmVudCA9IGF1ZGlvQW5kVmlkZW9UYWdzLmN1cnJlbnQuZmlsdGVyKChhKSA9PiBhLmlkICE9PSBpZCk7XG4gICAgICAgIH07XG4gICAgfSwgW2F1ZGlvQW5kVmlkZW9UYWdzLCBpZCwgbWVkaWFSZWYsIG1lZGlhVHlwZSwgcGxheWluZ10pO1xufTtcblxuLy8gVGFrZW4gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL2Jsb2IvMGI5ZWE2MGI0ZmVlOGNhY2MzNmU3MTYwZTMxYjkxZmMxMTRkYmMwZC9MaWJyYXJpZXMvQW5pbWF0ZWQvc3JjL25vZGVzL0FuaW1hdGVkSW50ZXJwb2xhdGlvbi5qc1xuZnVuY3Rpb24gaW50ZXJwb2xhdGVGdW5jdGlvbihpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGV4dHJhcG9sYXRlTGVmdCwgZXh0cmFwb2xhdGVSaWdodCwgZWFzaW5nIH0gPSBvcHRpb25zO1xuICAgIGxldCByZXN1bHQgPSBpbnB1dDtcbiAgICBjb25zdCBbaW5wdXRNaW4sIGlucHV0TWF4XSA9IGlucHV0UmFuZ2U7XG4gICAgY29uc3QgW291dHB1dE1pbiwgb3V0cHV0TWF4XSA9IG91dHB1dFJhbmdlO1xuICAgIGlmIChyZXN1bHQgPCBpbnB1dE1pbikge1xuICAgICAgICBpZiAoZXh0cmFwb2xhdGVMZWZ0ID09PSAnaWRlbnRpdHknKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHRyYXBvbGF0ZUxlZnQgPT09ICdjbGFtcCcpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGlucHV0TWluO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChyZXN1bHQgPiBpbnB1dE1heCkge1xuICAgICAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0cmFwb2xhdGVSaWdodCA9PT0gJ2NsYW1wJykge1xuICAgICAgICAgICAgcmVzdWx0ID0gaW5wdXRNYXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG91dHB1dE1pbiA9PT0gb3V0cHV0TWF4KSB7XG4gICAgICAgIHJldHVybiBvdXRwdXRNaW47XG4gICAgfVxuICAgIC8vIElucHV0IFJhbmdlXG4gICAgcmVzdWx0ID0gKHJlc3VsdCAtIGlucHV0TWluKSAvIChpbnB1dE1heCAtIGlucHV0TWluKTtcbiAgICAvLyBFYXNpbmdcbiAgICByZXN1bHQgPSBlYXNpbmcocmVzdWx0KTtcbiAgICAvLyBPdXRwdXQgUmFuZ2VcbiAgICByZXN1bHQgPSByZXN1bHQgKiAob3V0cHV0TWF4IC0gb3V0cHV0TWluKSArIG91dHB1dE1pbjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZmluZFJhbmdlKGlucHV0LCBpbnB1dFJhbmdlKSB7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMTsgaSA8IGlucHV0UmFuZ2UubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIGlmIChpbnB1dFJhbmdlW2ldID49IGlucHV0KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaSAtIDE7XG59XG5mdW5jdGlvbiBjaGVja1ZhbGlkSW5wdXRSYW5nZShhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoIShhcnJbaV0gPiBhcnJbaSAtIDFdKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnB1dFJhbmdlIG11c3QgYmUgc3RyaWN0bHkgbW9ub3RvbmljYWxseSBub24tZGVjcmVhc2luZyBidXQgZ290IFske2Fyci5qb2luKCcsJyl9XWApO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tJbmZpbml0ZVJhbmdlKG5hbWUsIGFycikge1xuICAgIGlmIChhcnIubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArICcgbXVzdCBoYXZlIGF0IGxlYXN0IDIgZWxlbWVudHMnKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpbmRleCBpbiBhcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJbaW5kZXhdICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke25hbWV9IG11c3QgY29udGFpbiBvbmx5IG51bWJlcnNgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyW2luZGV4XSA9PT0gLUluZmluaXR5IHx8IGFycltpbmRleF0gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bmFtZX0gbXVzdCBjb250YWluIG9ubHkgZmluaXRlIG51bWJlcnMsIGJ1dCBnb3QgWyR7YXJyLmpvaW4oJywnKX1dYCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIE1hcCBhIHZhbHVlIGZyb20gYW4gaW5wdXQgcmFuZ2UgdG8gYW4gb3V0cHV0IHJhbmdlLlxuICogQGxpbmsgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7IW51bWJlcn0gaW5wdXQgdmFsdWUgdG8gaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7IW51bWJlcltdfSBpbnB1dFJhbmdlIHJhbmdlIG9mIHZhbHVlcyB0aGF0IHlvdSBleHBlY3QgdGhlIGlucHV0IHRvIGFzc3VtZS5cbiAqIEBwYXJhbSB7IW51bWJlcltdfSBvdXRwdXRSYW5nZSByYW5nZSBvZiBvdXRwdXQgdmFsdWVzIHRoYXQgeW91IHdhbnQgdGhlIGlucHV0IHRvIG1hcCB0by5cbiAqIEBwYXJhbSB7P29iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHs/RnVuY3Rpb259IG9wdGlvbnMuZWFzaW5nIGVhc2luZyBmdW5jdGlvbiB3aGljaCBhbGxvd3MgeW91IHRvIGN1c3RvbWl6ZSB0aGUgaW5wdXQsIGZvciBleGFtcGxlIHRvIGFwcGx5IGEgY2VydGFpbiBlYXNpbmcgZnVuY3Rpb24uIEJ5IGRlZmF1bHQsIHRoZSBpbnB1dCBpcyBsZWZ0IHVubW9kaWZpZWQsIHJlc3VsdGluZyBpbiBhIHB1cmUgbGluZWFyIGludGVycG9sYXRpb24ge0BsaW5rIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2Vhc2luZ31cbiAqIEBwYXJhbSB7c3RyaW5nPX0gW29wdGlvbnMuZXh0cmFwb2xhdGVMZWZ0PVwiZXh0ZW5kXCJdIFdoYXQgc2hvdWxkIGhhcHBlbiBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgb3V0c2lkZSBsZWZ0IHRoZSBpbnB1dCByYW5nZSwgZGVmYXVsdDogXCJleHRlbmRcIiB7QGxpbmsgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvaW50ZXJwb2xhdGUjZXh0cmFwb2xhdGVsZWZ0fVxuICogQHBhcmFtIHtzdHJpbmc9fSBbb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0PVwiZXh0ZW5kXCJdIFNhbWUgYXMgZXh0cmFwb2xhdGVMZWZ0LCBleGNlcHQgZm9yIHZhbHVlcyBvdXRzaWRlIHJpZ2h0IHRoZSBpbnB1dCByYW5nZSB7QGxpbmsgaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvaW50ZXJwb2xhdGUjZXh0cmFwb2xhdGVyaWdodH1cbiAqL1xuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgY2FuIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dFJhbmdlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvdXRwdXRSYW5nZSBjYW4gbm90IGJlIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAoaW5wdXRSYW5nZS5sZW5ndGggIT09IG91dHB1dFJhbmdlLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0UmFuZ2UgKCcgK1xuICAgICAgICAgICAgaW5wdXRSYW5nZS5sZW5ndGggK1xuICAgICAgICAgICAgJykgYW5kIG91dHB1dFJhbmdlICgnICtcbiAgICAgICAgICAgIG91dHB1dFJhbmdlLmxlbmd0aCArXG4gICAgICAgICAgICAnKSBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoJyk7XG4gICAgfVxuICAgIGNoZWNrSW5maW5pdGVSYW5nZSgnaW5wdXRSYW5nZScsIGlucHV0UmFuZ2UpO1xuICAgIGNoZWNrSW5maW5pdGVSYW5nZSgnb3V0cHV0UmFuZ2UnLCBvdXRwdXRSYW5nZSk7XG4gICAgY2hlY2tWYWxpZElucHV0UmFuZ2UoaW5wdXRSYW5nZSk7XG4gICAgY29uc3QgZWFzaW5nID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVhc2luZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKChudW0pID0+IG51bSk7XG4gICAgbGV0IGV4dHJhcG9sYXRlTGVmdCA9ICdleHRlbmQnO1xuICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHRyYXBvbGF0ZUxlZnQgPSBvcHRpb25zLmV4dHJhcG9sYXRlTGVmdDtcbiAgICB9XG4gICAgbGV0IGV4dHJhcG9sYXRlUmlnaHQgPSAnZXh0ZW5kJztcbiAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5leHRyYXBvbGF0ZVJpZ2h0KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4dHJhcG9sYXRlUmlnaHQgPSBvcHRpb25zLmV4dHJhcG9sYXRlUmlnaHQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBpbnRlcnBvbGF0ZSBhbiBpbnB1dCB3aGljaCBpcyBub3QgYSBudW1iZXInKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBmaW5kUmFuZ2UoaW5wdXQsIGlucHV0UmFuZ2UpO1xuICAgIHJldHVybiBpbnRlcnBvbGF0ZUZ1bmN0aW9uKGlucHV0LCBbaW5wdXRSYW5nZVtyYW5nZV0sIGlucHV0UmFuZ2VbcmFuZ2UgKyAxXV0sIFtvdXRwdXRSYW5nZVtyYW5nZV0sIG91dHB1dFJhbmdlW3JhbmdlICsgMV1dLCB7XG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgZXh0cmFwb2xhdGVMZWZ0LFxuICAgICAgICBleHRyYXBvbGF0ZVJpZ2h0LFxuICAgIH0pO1xufVxuXG4vLyBDYWxjdWxhdGUgdGhlIGAuY3VycmVudFRpbWVgIG9mIGEgdmlkZW8gb3IgYXVkaW8gZWxlbWVudFxuY29uc3QgZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQgPSAoeyBmcmFtZSwgcGxheWJhY2tSYXRlLCBzdGFydEZyb20sIH0pID0+IHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGUoZnJhbWUsIFstMSwgc3RhcnRGcm9tLCBzdGFydEZyb20gKyAxXSwgWy0xLCBzdGFydEZyb20sIHN0YXJ0RnJvbSArIHBsYXliYWNrUmF0ZV0pO1xufTtcbmNvbnN0IGdldE1lZGlhVGltZSA9ICh7IGZwcywgZnJhbWUsIHNyYywgcGxheWJhY2tSYXRlLCBzdGFydEZyb20sIG1lZGlhVHlwZSwgfSkgPT4ge1xuICAgIGNvbnN0IGV4cGVjdGVkRnJhbWUgPSBnZXRFeHBlY3RlZE1lZGlhRnJhbWVVbmNvcnJlY3RlZCh7XG4gICAgICAgIGZyYW1lLFxuICAgICAgICBwbGF5YmFja1JhdGUsXG4gICAgICAgIHN0YXJ0RnJvbSxcbiAgICB9KTtcbiAgICBjb25zdCBpc0Nocm9tZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9DaHJvbWVcXC8oWzAtOV0rKS8pO1xuICAgIGlmIChpc0Nocm9tZSAmJlxuICAgICAgICBOdW1iZXIoaXNDaHJvbWVbMV0pIDwgMTEyICYmXG4gICAgICAgIG1lZGlhVHlwZSA9PT0gJ3ZpZGVvJyAmJlxuICAgICAgICBzcmMuZW5kc1dpdGgoJy5tcDQnKSkge1xuICAgICAgICAvLyBJbiBDaHJvbWUsIGZvciBNUDRzLCBpZiAzMGZwcywgdGhlIGZpcnN0IGZyYW1lIGlzIHN0aWxsIGRpc3BsYXllZCBhdCAwLjAzMzMzM1xuICAgICAgICAvLyBldmVuIHRob3VnaCBhZnRlciB0aGF0IGl0IGluY3JlYXNlcyBieSAwLjAzMzMzMzMzMyBlYWNoLlxuICAgICAgICAvLyBTbyBmcmFtZSA9IDAgaW4gUmVtb3Rpb24gaXMgbGlrZSBmcmFtZSA9IDEgZm9yIHRoZSBicm93c2VyXG4gICAgICAgIHJldHVybiAoZXhwZWN0ZWRGcmFtZSArIDEpIC8gZnBzO1xuICAgIH1cbiAgICAvLyBGb3IgV2ViTSB2aWRlb3MsIHdlIG5lZWQgdG8gYWRkIGEgbGl0dGxlIGJpdCBvZiBzaGlmdCB0byBnZXQgdGhlIHJpZ2h0IGZyYW1lLlxuICAgIGNvbnN0IG1zUGVyRnJhbWUgPSAxMDAwIC8gZnBzO1xuICAgIGNvbnN0IG1zU2hpZnQgPSBtc1BlckZyYW1lIC8gMjtcbiAgICByZXR1cm4gKGV4cGVjdGVkRnJhbWUgKiBtc1BlckZyYW1lICsgbXNTaGlmdCkgLyAxMDAwO1xufTtcblxuY29uc3QgdG9TZWNvbmRzID0gKHRpbWUsIGZwcykgPT4ge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKCh0aW1lIC8gZnBzKSAqIDEwMCkgLyAxMDA7XG59O1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3JlbW90aW9uLWRldi9yZW1vdGlvbi9pc3N1ZXMvMTY1NVxuY29uc3QgaXNJT1NTYWZhcmlDYXNlID0gKGFjdHVhbFNyYykgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogL2lQKGFkfG9kfGhvbmUpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgIEJvb2xlYW4obmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8pKSAmJlxuICAgICAgICAgICAgYWN0dWFsU3JjLnN0YXJ0c1dpdGgoJ2Jsb2I6Jyk7XG59O1xuY29uc3QgYXBwZW5kVmlkZW9GcmFnbWVudCA9ICh7IGFjdHVhbFNyYywgYWN0dWFsRnJvbSwgZHVyYXRpb24sIGZwcywgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaXNJT1NTYWZhcmlDYXNlKGFjdHVhbFNyYykpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgICB9XG4gICAgaWYgKGFjdHVhbFNyYy5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAgIHJldHVybiBhY3R1YWxTcmM7XG4gICAgfVxuICAgIGNvbnN0IGV4aXN0aW5nSGFzaCA9IEJvb2xlYW4obmV3IFVSTChhY3R1YWxTcmMsIChfYSA9ICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IG51bGwgOiB3aW5kb3cubG9jYXRpb24uaHJlZikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICdodHRwOi8vbG9jYWxob3N0OjMwMDAnKS5oYXNoKTtcbiAgICBpZiAoZXhpc3RpbmdIYXNoKSB7XG4gICAgICAgIHJldHVybiBhY3R1YWxTcmM7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGFjdHVhbEZyb20pKSB7XG4gICAgICAgIHJldHVybiBhY3R1YWxTcmM7XG4gICAgfVxuICAgIGFjdHVhbFNyYyArPSBgI3Q9JHt0b1NlY29uZHMoLWFjdHVhbEZyb20sIGZwcyl9YDtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXJhdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGFjdHVhbFNyYztcbiAgICB9XG4gICAgYWN0dWFsU3JjICs9IGAsJHt0b1NlY29uZHMoZHVyYXRpb24sIGZwcyl9YDtcbiAgICByZXR1cm4gYWN0dWFsU3JjO1xufTtcbmNvbnN0IGlzU3Vic2V0T2ZEdXJhdGlvbiA9IChwcmV2U3RhcnRGcm9tLCBuZXdTdGFydEZyb20sIHByZXZEdXJhdGlvbiwgbmV3RHVyYXRpb24pID0+IHtcbiAgICByZXR1cm4gKHByZXZTdGFydEZyb20gPD0gbmV3U3RhcnRGcm9tICYmXG4gICAgICAgIHByZXZTdGFydEZyb20gKyBwcmV2RHVyYXRpb24gPj0gbmV3U3RhcnRGcm9tICsgbmV3RHVyYXRpb24pO1xufTtcbmNvbnN0IHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQgPSAoeyBhY3R1YWxTcmM6IGluaXRpYWxBY3R1YWxTcmMsIGFjdHVhbEZyb206IGluaXRpYWxBY3R1YWxGcm9tLCBkdXJhdGlvbjogaW5pdGlhbER1cmF0aW9uLCBmcHMsIH0pID0+IHtcbiAgICBjb25zdCBhY3R1YWxGcm9tUmVmID0gdXNlUmVmKGluaXRpYWxBY3R1YWxGcm9tKTtcbiAgICBjb25zdCBhY3R1YWxEdXJhdGlvbiA9IHVzZVJlZihpbml0aWFsRHVyYXRpb24pO1xuICAgIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVJlZihpbml0aWFsQWN0dWFsU3JjKTtcbiAgICBpZiAoIWlzU3Vic2V0T2ZEdXJhdGlvbiB8fCBpbml0aWFsQWN0dWFsU3JjICE9PSBhY3R1YWxTcmMuY3VycmVudCkge1xuICAgICAgICBhY3R1YWxGcm9tUmVmLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsRnJvbTtcbiAgICAgICAgYWN0dWFsRHVyYXRpb24uY3VycmVudCA9IGluaXRpYWxEdXJhdGlvbjtcbiAgICAgICAgYWN0dWFsU3JjLmN1cnJlbnQgPSBpbml0aWFsQWN0dWFsU3JjO1xuICAgIH1cbiAgICBjb25zdCBhcHBlbmRlZCA9IGFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgICAgICBhY3R1YWxTcmM6IGFjdHVhbFNyYy5jdXJyZW50LFxuICAgICAgICBhY3R1YWxGcm9tOiBhY3R1YWxGcm9tUmVmLmN1cnJlbnQsXG4gICAgICAgIGR1cmF0aW9uOiBhY3R1YWxEdXJhdGlvbi5jdXJyZW50LFxuICAgICAgICBmcHMsXG4gICAgfSk7XG4gICAgcmV0dXJuIGFwcGVuZGVkO1xufTtcbmNvbnN0IGlzSW9zU2FmYXJpID0gKCkgPT4ge1xuICAgIHJldHVybiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IGZhbHNlXG4gICAgICAgIDogL2lQKGFkfG9kfGhvbmUpL2kudGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgICAgIEJvb2xlYW4obmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvVmVyc2lvblxcL1tcXGQuXSsuKlNhZmFyaS8pKTtcbn07XG5cbmNvbnN0IGFscmVhZHlXYXJuZWQgPSB7fTtcbmNvbnN0IHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEgPSAocmVmLCB0eXBlKSA9PiB7XG4gICAgLy8gTWVkaWEgaXMgbm90IGxvYWRlZCB5ZXQsIGJ1dCB0aGlzIGRvZXMgbm90IHlldCBtZWFuIHNvbWV0aGluZyBpcyB3cm9uZyB3aXRoIHRoZSBtZWRpYVxuICAgIGlmIChyZWYgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVmLnNlZWthYmxlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChyZWYuc2Vla2FibGUubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhbHJlYWR5V2FybmVkW3JlZi5zcmNdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSB7IHN0YXJ0OiByZWYuc2Vla2FibGUuc3RhcnQoMCksIGVuZDogcmVmLnNlZWthYmxlLmVuZCgwKSB9O1xuICAgIGlmIChyYW5nZS5zdGFydCA9PT0gMCAmJiByYW5nZS5lbmQgPT09IDApIHtcbiAgICAgICAgY29uc3QgbXNnID0gYFRoZSBtZWRpYSAke3JlZi5zcmN9IGNhbm5vdCBiZSBzZWVrZWQuIFRoaXMgY291bGQgYmUgb25lIG9mIHR3byByZWFzb25zOiAxKSBUaGUgbWVkaWEgcmVzb3VyY2Ugd2FzIHJlcGxhY2VkIHdoaWxlIHRoZSB2aWRlbyBpcyBwbGF5aW5nIGJ1dCBpdCB3YXMgbm90IGxvYWRlZCB5ZXQuIDIpIFRoZSBtZWRpYSBkb2VzIG5vdCBzdXBwb3J0IHNlZWtpbmcuIFBsZWFzZSBzZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9ub24tc2Vla2FibGUtbWVkaWEgZm9yIGFzc2lzdGFuY2UuYDtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdjb25zb2xlLWVycm9yJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGUgPT09ICdjb25zb2xlLXdhcm5pbmcnKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFRoZSBtZWRpYSAke3JlZi5zcmN9IGRvZXMgbm90IHN1cHBvcnQgc2Vla2luZy4gVGhlIHZpZGVvIHdpbGwgcmVuZGVyIGZpbmUsIGJ1dCBtYXkgbm90IHBsYXkgY29ycmVjdGx5IGluIHRoZSBSZW1vdGlvbiBTdHVkaW8gYW5kIGluIHRoZSA8UGxheWVyPi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvbm9uLXNlZWthYmxlLW1lZGlhIGZvciBhbiBleHBsYW5hdGlvbi5gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICB9XG4gICAgICAgIGFscmVhZHlXYXJuZWRbcmVmLnNyY10gPSB0cnVlO1xuICAgIH1cbn07XG5cbmNvbnN0IERFRkFVTFRfQUNDRVBUQUJMRV9USU1FU0hJRlQgPSAwLjQ1O1xuY29uc3Qgc2VlayA9IChtZWRpYVJlZiwgdGltZSkgPT4ge1xuICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGlPUyBzZWVraW5nIGRvZXMgbm90IHN1cHBvcnQgbXVsdGlwbGUgZGVjaW1hbHNcbiAgICBpZiAoaXNJb3NTYWZhcmkoKSkge1xuICAgICAgICBtZWRpYVJlZi5jdXJyZW50LmN1cnJlbnRUaW1lID0gTnVtYmVyKHRpbWUudG9GaXhlZCgxKSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbWVkaWFSZWYuY3VycmVudC5jdXJyZW50VGltZSA9IHRpbWU7XG59O1xuY29uc3QgdXNlTWVkaWFQbGF5YmFjayA9ICh7IG1lZGlhUmVmLCBzcmMsIG1lZGlhVHlwZSwgcGxheWJhY2tSYXRlOiBsb2NhbFBsYXliYWNrUmF0ZSwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciwgYWNjZXB0YWJsZVRpbWVzaGlmdCwgfSkgPT4ge1xuICAgIGNvbnN0IHsgcGxheWJhY2tSYXRlOiBnbG9iYWxQbGF5YmFja1JhdGUgfSA9IHVzZUNvbnRleHQoVGltZWxpbmVDb250ZXh0KTtcbiAgICBjb25zdCBmcmFtZSA9IHVzZUN1cnJlbnRGcmFtZSgpO1xuICAgIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgW3BsYXlpbmddID0gdXNlUGxheWluZ1N0YXRlKCk7XG4gICAgY29uc3QgeyBmcHMgfSA9IHVzZVZpZGVvQ29uZmlnKCk7XG4gICAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgICBjb25zdCBwbGF5YmFja1JhdGUgPSBsb2NhbFBsYXliYWNrUmF0ZSAqIGdsb2JhbFBsYXliYWNrUmF0ZTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcGxheWluZykge1xuICAgICAgICAgICAgKF9hID0gbWVkaWFSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbbWVkaWFSZWYsIG1lZGlhVHlwZSwgcGxheWluZ10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZ05hbWUgPSBtZWRpYVR5cGUgPT09ICdhdWRpbycgPyAnPEF1ZGlvPicgOiAnPFZpZGVvPic7XG4gICAgICAgIGlmICghbWVkaWFSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAke21lZGlhVHlwZX0gcmVmIGZvdW5kYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzcmMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gJ3NyYycgYXR0cmlidXRlIHdhcyBwYXNzZWQgdG8gdGhlICR7dGFnTmFtZX0gZWxlbWVudC5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbGF5YmFja1JhdGVUb1NldCA9IE1hdGgubWF4KDAsIHBsYXliYWNrUmF0ZSk7XG4gICAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBsYXliYWNrUmF0ZSAhPT0gcGxheWJhY2tSYXRlVG9TZXQpIHtcbiAgICAgICAgICAgIG1lZGlhUmVmLmN1cnJlbnQucGxheWJhY2tSYXRlID0gcGxheWJhY2tSYXRlVG9TZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzaXJlZFVuY2xhbXBlZFRpbWUgPSBnZXRNZWRpYVRpbWUoe1xuICAgICAgICAgICAgZnBzLFxuICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICBzcmMsXG4gICAgICAgICAgICBwbGF5YmFja1JhdGU6IGxvY2FsUGxheWJhY2tSYXRlLFxuICAgICAgICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgICAgICAgIG1lZGlhVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHsgZHVyYXRpb24gfSA9IG1lZGlhUmVmLmN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IHNob3VsZEJlVGltZSA9ICFOdW1iZXIuaXNOYU4oZHVyYXRpb24pICYmIE51bWJlci5pc0Zpbml0ZShkdXJhdGlvbilcbiAgICAgICAgICAgID8gTWF0aC5taW4oZHVyYXRpb24sIGRlc2lyZWRVbmNsYW1wZWRUaW1lKVxuICAgICAgICAgICAgOiBkZXNpcmVkVW5jbGFtcGVkVGltZTtcbiAgICAgICAgY29uc3QgaXNUaW1lID0gbWVkaWFSZWYuY3VycmVudC5jdXJyZW50VGltZTtcbiAgICAgICAgY29uc3QgdGltZVNoaWZ0ID0gTWF0aC5hYnMoc2hvdWxkQmVUaW1lIC0gaXNUaW1lKTtcbiAgICAgICAgaWYgKHRpbWVTaGlmdCA+IGFjY2VwdGFibGVUaW1lc2hpZnQpIHtcbiAgICAgICAgICAgIC8vIElmIHNjcnViYmluZyBhcm91bmQsIGFkanVzdCB0aW1pbmdcbiAgICAgICAgICAgIC8vIG9yIGlmIHRpbWUgc2hpZnQgaXMgYmlnZ2VyIHRoYW4gMC40NXNlY1xuICAgICAgICAgICAgc2VlayhtZWRpYVJlZiwgc2hvdWxkQmVUaW1lKTtcbiAgICAgICAgICAgIGlmICghb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcikge1xuICAgICAgICAgICAgICAgIHdhcm5BYm91dE5vblNlZWthYmxlTWVkaWEobWVkaWFSZWYuY3VycmVudCwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciA/ICdjb25zb2xlLXdhcm5pbmcnIDogJ2NvbnNvbGUtZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IHBlcmZvcm0gYSBzZWVrIGlmIHRoZSB0aW1lIGlzIG5vdCBhbHJlYWR5IHRoZSBzYW1lLlxuICAgICAgICAvLyBDaHJvbWUgcm91bmRzIHRvIDYgZGlnaXRzLCBzbyAwLjAzMzMzMzMzMyAtPiAwLjAzMzMzMyxcbiAgICAgICAgLy8gdGhlcmVmb3JlIGEgdGhyZXNob2xkIGlzIGFsbG93ZWQuXG4gICAgICAgIC8vIFJlZmVyIHRvIHRoZSBodHRwczovL2dpdGh1Yi5jb20vcmVtb3Rpb24tZGV2L3ZpZGVvLWJ1ZmZlcmluZy1leGFtcGxlXG4gICAgICAgIC8vIHdoaWNoIGlzIGZpeGVkIGJ5IG9ubHkgc2Vla2luZyBjb25kaXRpb25hbGx5LlxuICAgICAgICBjb25zdCBtYWtlc1NlbnNlVG9TZWVrID0gTWF0aC5hYnMobWVkaWFSZWYuY3VycmVudC5jdXJyZW50VGltZSAtIHNob3VsZEJlVGltZSkgPiAwLjAwMDAxO1xuICAgICAgICBpZiAoIXBsYXlpbmcgfHwgYWJzb2x1dGVGcmFtZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKG1ha2VzU2Vuc2VUb1NlZWspIHtcbiAgICAgICAgICAgICAgICBzZWVrKG1lZGlhUmVmLCBzaG91bGRCZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtZWRpYVJlZi5jdXJyZW50LnBhdXNlZCAmJiAhbWVkaWFSZWYuY3VycmVudC5lbmRlZCAmJiBwbGF5aW5nKSB7XG4gICAgICAgICAgICBpZiAobWFrZXNTZW5zZVRvU2Vlaykge1xuICAgICAgICAgICAgICAgIHNlZWsobWVkaWFSZWYsIHNob3VsZEJlVGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwbGF5QW5kSGFuZGxlTm90QWxsb3dlZEVycm9yKG1lZGlhUmVmLCBtZWRpYVR5cGUpO1xuICAgICAgICB9XG4gICAgfSwgW1xuICAgICAgICBhYnNvbHV0ZUZyYW1lLFxuICAgICAgICBmcHMsXG4gICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIG1lZGlhUmVmLFxuICAgICAgICBtZWRpYVR5cGUsXG4gICAgICAgIHBsYXlpbmcsXG4gICAgICAgIHNyYyxcbiAgICAgICAgbWVkaWFTdGFydHNBdCxcbiAgICAgICAgbG9jYWxQbGF5YmFja1JhdGUsXG4gICAgICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3IsXG4gICAgICAgIGFjY2VwdGFibGVUaW1lc2hpZnQsXG4gICAgXSk7XG59O1xuXG4vLyBSZXR1cm5zIHRoZSByZWFsIHZvbHVtZSBvZiB0aGUgYXVkaW8gb3IgdmlkZW8gd2hpbGUgcGxheWluZyxcbi8vIG5vIG1hdHRlciB3aGF0IHRoZSBzdXBwb3NlZCB2b2x1bWUgc2hvdWxkIGJlXG5jb25zdCB1c2VNZWRpYVRhZ1ZvbHVtZSA9IChtZWRpYVJlZikgPT4ge1xuICAgIGNvbnN0IFthY3R1YWxWb2x1bWUsIHNldEFjdHVhbFZvbHVtZV0gPSB1c2VTdGF0ZSgxKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uQ2hhbmdlID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0QWN0dWFsVm9sdW1lKHJlZi52b2x1bWUpO1xuICAgICAgICB9O1xuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcigndm9sdW1lY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgICByZXR1cm4gKCkgPT4gcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3ZvbHVtZWNoYW5nZScsIG9uQ2hhbmdlKTtcbiAgICB9LCBbbWVkaWFSZWZdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSBtZWRpYVJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIXJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYudm9sdW1lICE9PSBhY3R1YWxWb2x1bWUpIHtcbiAgICAgICAgICAgIHNldEFjdHVhbFZvbHVtZShyZWYudm9sdW1lKTtcbiAgICAgICAgfVxuICAgIH0sIFthY3R1YWxWb2x1bWUsIG1lZGlhUmVmXSk7XG4gICAgcmV0dXJuIGFjdHVhbFZvbHVtZTtcbn07XG5cbmNvbnN0IEZMT0FUSU5HX1BPSU5UX0VSUk9SX1RIUkVTSE9MRCA9IDAuMDAwMDE7XG5jb25zdCBpc0FwcHJveGltYXRlbHlUaGVTYW1lID0gKG51bTEsIG51bTIpID0+IHtcbiAgICByZXR1cm4gTWF0aC5hYnMobnVtMSAtIG51bTIpIDwgRkxPQVRJTkdfUE9JTlRfRVJST1JfVEhSRVNIT0xEO1xufTtcblxuY29uc3QgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyA9ICh7IHZvbHVtZVByb3BGcmFtZSwgYWN0dWFsVm9sdW1lLCB2b2x1bWUsIG1lZGlhVm9sdW1lLCBtZWRpYVJlZiwgfSkgPT4ge1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZXJQcmVmZXJyZWRWb2x1bWUgPSBldmFsdWF0ZVZvbHVtZSh7XG4gICAgICAgICAgICBmcmFtZTogdm9sdW1lUHJvcEZyYW1lLFxuICAgICAgICAgICAgdm9sdW1lLFxuICAgICAgICAgICAgbWVkaWFWb2x1bWUsXG4gICAgICAgICAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFpc0FwcHJveGltYXRlbHlUaGVTYW1lKHVzZXJQcmVmZXJyZWRWb2x1bWUsIGFjdHVhbFZvbHVtZSkgJiZcbiAgICAgICAgICAgIG1lZGlhUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG1lZGlhUmVmLmN1cnJlbnQudm9sdW1lID0gdXNlclByZWZlcnJlZFZvbHVtZTtcbiAgICAgICAgfVxuICAgIH0sIFthY3R1YWxWb2x1bWUsIHZvbHVtZVByb3BGcmFtZSwgbWVkaWFSZWYsIHZvbHVtZSwgbWVkaWFWb2x1bWVdKTtcbn07XG5cbmNvbnN0IE1lZGlhVm9sdW1lQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIG1lZGlhTXV0ZWQ6IGZhbHNlLFxuICAgIG1lZGlhVm9sdW1lOiAxLFxufSk7XG5jb25zdCBTZXRNZWRpYVZvbHVtZUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICBzZXRNZWRpYU11dGVkOiAoKSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVmYXVsdCcpO1xuICAgIH0sXG4gICAgc2V0TWVkaWFWb2x1bWU6ICgpID0+IHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWZhdWx0Jyk7XG4gICAgfSxcbn0pO1xuY29uc3QgdXNlTWVkaWFWb2x1bWVTdGF0ZSA9ICgpID0+IHtcbiAgICBjb25zdCB7IG1lZGlhVm9sdW1lIH0gPSB1c2VDb250ZXh0KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gICAgY29uc3QgeyBzZXRNZWRpYVZvbHVtZSB9ID0gdXNlQ29udGV4dChTZXRNZWRpYVZvbHVtZUNvbnRleHQpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIFttZWRpYVZvbHVtZSwgc2V0TWVkaWFWb2x1bWVdO1xuICAgIH0sIFttZWRpYVZvbHVtZSwgc2V0TWVkaWFWb2x1bWVdKTtcbn07XG5jb25zdCB1c2VNZWRpYU11dGVkU3RhdGUgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBtZWRpYU11dGVkIH0gPSB1c2VDb250ZXh0KE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gICAgY29uc3QgeyBzZXRNZWRpYU11dGVkIH0gPSB1c2VDb250ZXh0KFNldE1lZGlhVm9sdW1lQ29udGV4dCk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gW21lZGlhTXV0ZWQsIHNldE1lZGlhTXV0ZWRdO1xuICAgIH0sIFttZWRpYU11dGVkLCBzZXRNZWRpYU11dGVkXSk7XG59O1xuXG5jb25zdCBFTVBUWV9BVURJTyA9ICdkYXRhOmF1ZGlvL21wMztiYXNlNjQsLytNWXhBQUpjQVY4QUFnQUFCbi8vLy8vLysvZ1E1QkFNQStENFBnK0JBUUJBRUF3RDRQZytENEVCQUVBUURBUGcrK2hZQkgvLy9oVUZRVkJVRlJFRFFOSG1mLy8vLy8vLytNWXhCVUdrQUdJTUFBQUFQLzI5WHQ2bFV4QlRVVXpMakV3TUZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWLytNWXhEVUFBQU5JQUFBQUFGVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWVlZWJztcbmNvbnN0IGNvbXBhcmVQcm9wcyA9IChvYmoxLCBvYmoyKSA9PiB7XG4gICAgY29uc3Qga2V5c0EgPSBPYmplY3Qua2V5cyhvYmoxKS5zb3J0KCk7XG4gICAgY29uc3Qga2V5c0IgPSBPYmplY3Qua2V5cyhvYmoyKS5zb3J0KCk7XG4gICAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBOb3QgdGhlIHNhbWUga2V5c1xuICAgICAgICBpZiAoa2V5c0FbaV0gIT09IGtleXNCW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90IHRoZSBzYW1lIHZhbHVlc1xuICAgICAgICBpZiAob2JqMVtrZXlzQVtpXV0gIT09IG9iajJba2V5c0JbaV1dKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgZGlkUHJvcENoYW5nZSA9IChrZXksIG5ld1Byb3AsIHByZXZQcm9wKSA9PiB7XG4gICAgLy8gL211c2ljLm1wMyBhbmQgaHR0cDovL2xvY2FsaG9zdDozMDAwL211c2ljLm1wMyBhcmUgdGhlIHNhbWVcbiAgICBpZiAoa2V5ID09PSAnc3JjJyAmJlxuICAgICAgICAhcHJldlByb3Auc3RhcnRzV2l0aCgnZGF0YTonKSAmJlxuICAgICAgICAhbmV3UHJvcC5zdGFydHNXaXRoKCdkYXRhOicpKSB7XG4gICAgICAgIHJldHVybiAobmV3IFVSTChwcmV2UHJvcCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikudG9TdHJpbmcoKSAhPT1cbiAgICAgICAgICAgIG5ldyBVUkwobmV3UHJvcCwgd2luZG93LmxvY2F0aW9uLm9yaWdpbikudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIGlmIChwcmV2UHJvcCA9PT0gbmV3UHJvcCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbmNvbnN0IFNoYXJlZEF1ZGlvQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5jb25zdCBTaGFyZWRBdWRpb0NvbnRleHRQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50IH0pID0+IHtcbiAgICBjb25zdCBhdWRpb3MgPSB1c2VSZWYoW10pO1xuICAgIGNvbnN0IFtpbml0aWFsTnVtYmVyT2ZBdWRpb1RhZ3NdID0gdXNlU3RhdGUobnVtYmVyT2ZBdWRpb1RhZ3MpO1xuICAgIGlmIChudW1iZXJPZkF1ZGlvVGFncyAhPT0gaW5pdGlhbE51bWJlck9mQXVkaW9UYWdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIG51bWJlciBvZiBzaGFyZWQgYXVkaW8gdGFncyBoYXMgY2hhbmdlZCBkeW5hbWljYWxseS4gT25jZSB5b3UgaGF2ZSBzZXQgdGhpcyBwcm9wZXJ0eSwgeW91IGNhbm5vdCBjaGFuZ2UgaXQgYWZ0ZXJ3YXJkcy4nKTtcbiAgICB9XG4gICAgY29uc3QgcmVmcyA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IEFycmF5KG51bWJlck9mQXVkaW9UYWdzKS5maWxsKHRydWUpLm1hcCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBpZDogTWF0aC5yYW5kb20oKSwgcmVmOiBjcmVhdGVSZWYoKSB9O1xuICAgICAgICB9KTtcbiAgICB9LCBbbnVtYmVyT2ZBdWRpb1RhZ3NdKTtcbiAgICBjb25zdCB0YWtlbkF1ZGlvcyA9IHVzZVJlZihuZXcgQXJyYXkobnVtYmVyT2ZBdWRpb1RhZ3MpLmZpbGwoZmFsc2UpKTtcbiAgICBjb25zdCByZXJlbmRlckF1ZGlvcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgcmVmcy5mb3JFYWNoKCh7IHJlZiwgaWQgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IChfYSA9IGF1ZGlvcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoYSkgPT4gYS5pZCA9PT0gaWQpO1xuICAgICAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSByZWY7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXaG9sZSBwbGF5ZXIgaGFzIGJlZW4gdW5tb3VudGVkLCB0aGUgcmVmcyBkb24ndCBleGlzdCBhbnltb3JlLlxuICAgICAgICAgICAgICAgIC8vIEl0IGlzIG5vdCBhbiBlcnJvciBhbnltb3JlIHRob3VnaFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnNyYyA9IEVNUFRZX0FVRElPO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGF1ZGlvIGRhdGEgdG8gYmUgdGhlcmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEucHJvcHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZGlkUHJvcENoYW5nZShrZXksIGRhdGEucHJvcHNba2V5XSwgY3VycmVudFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRba2V5XSA9IGRhdGEucHJvcHNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3JlZnNdKTtcbiAgICBjb25zdCByZWdpc3RlckF1ZGlvID0gdXNlQ2FsbGJhY2soKGF1ZCwgYXVkaW9JZCkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBmb3VuZCA9IChfYSA9IGF1ZGlvcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZmluZCgoYSkgPT4gYS5hdWRpb0lkID09PSBhdWRpb0lkKTtcbiAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlyc3RGcmVlQXVkaW8gPSB0YWtlbkF1ZGlvcy5jdXJyZW50LmZpbmRJbmRleCgoYSkgPT4gYSA9PT0gZmFsc2UpO1xuICAgICAgICBpZiAoZmlyc3RGcmVlQXVkaW8gPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRyaWVkIHRvIHNpbXVsdGFuZW91c2x5IG1vdW50ICR7bnVtYmVyT2ZBdWRpb1RhZ3MgKyAxfSA8QXVkaW8gLz4gdGFncyBhdCB0aGUgc2FtZSB0aW1lLiBXaXRoIHRoZSBjdXJyZW50IHNldHRpbmdzLCB0aGUgbWF4aW11bSBhbW91bnQgb2YgPEF1ZGlvIC8+IHRhZ3MgaXMgbGltaXRlZCB0byAke251bWJlck9mQXVkaW9UYWdzfSBhdCB0aGUgc2FtZSB0aW1lLiBSZW1vdGlvbiBwcmUtbW91bnRzIHNpbGVudCBhdWRpbyB0YWdzIHRvIGhlbHAgYXZvaWQgYnJvd3NlciBhdXRvcGxheSByZXN0cmljdGlvbnMuIFNlZSBodHRwczovL3JlbW90aW9uLmRldi9kb2NzL3BsYXllci9hdXRvcGxheSN1c2UtdGhlLW51bWJlcm9mc2hhcmVkYXVkaW90YWdzLXByb3BlcnR5IGZvciBtb3JlIGluZm9ybWF0aW9uIG9uIGhvdyB0byBpbmNyZWFzZSB0aGlzIGxpbWl0LmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgaWQsIHJlZiB9ID0gcmVmc1tmaXJzdEZyZWVBdWRpb107XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IFsuLi50YWtlbkF1ZGlvcy5jdXJyZW50XTtcbiAgICAgICAgY2xvbmVkW2ZpcnN0RnJlZUF1ZGlvXSA9IGlkO1xuICAgICAgICB0YWtlbkF1ZGlvcy5jdXJyZW50ID0gY2xvbmVkO1xuICAgICAgICBjb25zdCBuZXdFbGVtID0ge1xuICAgICAgICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgZWw6IHJlZixcbiAgICAgICAgICAgIGF1ZGlvSWQsXG4gICAgICAgIH07XG4gICAgICAgIChfYiA9IGF1ZGlvcy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHVzaChuZXdFbGVtKTtcbiAgICAgICAgcmVyZW5kZXJBdWRpb3MoKTtcbiAgICAgICAgcmV0dXJuIG5ld0VsZW07XG4gICAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICAgIGNvbnN0IHVucmVnaXN0ZXJBdWRpbyA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNsb25lZCA9IFsuLi50YWtlbkF1ZGlvcy5jdXJyZW50XTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZWZzLmZpbmRJbmRleCgocikgPT4gci5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFcnJvciBvY2N1cmVkIGluICcpO1xuICAgICAgICB9XG4gICAgICAgIGNsb25lZFtpbmRleF0gPSBmYWxzZTtcbiAgICAgICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IGNsb25lZDtcbiAgICAgICAgYXVkaW9zLmN1cnJlbnQgPSAoX2EgPSBhdWRpb3MuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZpbHRlcigoYSkgPT4gYS5pZCAhPT0gaWQpO1xuICAgICAgICByZXJlbmRlckF1ZGlvcygpO1xuICAgIH0sIFtyZWZzLCByZXJlbmRlckF1ZGlvc10pO1xuICAgIGNvbnN0IHVwZGF0ZUF1ZGlvID0gdXNlQ2FsbGJhY2soKHsgYXVkLCBhdWRpb0lkLCBpZCwgfSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGF1ZGlvcy5jdXJyZW50ID0gKF9hID0gYXVkaW9zLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKHByZXZBKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldkEuaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNUaGVTYW1lID0gY29tcGFyZVByb3BzKGF1ZCwgcHJldkEucHJvcHMpO1xuICAgICAgICAgICAgICAgIGlmIChpc1RoZVNhbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZBO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2QSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHM6IGF1ZCxcbiAgICAgICAgICAgICAgICAgICAgYXVkaW9JZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByZXZBO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcmVyZW5kZXJBdWRpb3NdKTtcbiAgICBjb25zdCBwbGF5QWxsQXVkaW9zID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICByZWZzLmZvckVhY2goKHJlZikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gcmVmLnJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGxheSgpO1xuICAgICAgICB9KTtcbiAgICB9LCBbcmVmc10pO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWdpc3RlckF1ZGlvLFxuICAgICAgICAgICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgICAgICAgICAgdXBkYXRlQXVkaW8sXG4gICAgICAgICAgICBwbGF5QWxsQXVkaW9zLFxuICAgICAgICAgICAgbnVtYmVyT2ZBdWRpb1RhZ3MsXG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBudW1iZXJPZkF1ZGlvVGFncyxcbiAgICAgICAgcGxheUFsbEF1ZGlvcyxcbiAgICAgICAgcmVnaXN0ZXJBdWRpbyxcbiAgICAgICAgdW5yZWdpc3RlckF1ZGlvLFxuICAgICAgICB1cGRhdGVBdWRpbyxcbiAgICBdKTtcbiAgICAvLyBGaXhpbmcgYSBidWc6IEluIFJlYWN0LCBpZiBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgdXNpbmcgdXNlSW5zZXJ0aW9uRWZmZWN0LCB0aGVuXG4gICAgLy8gdGhlIGNsZWFudXAgZnVuY3Rpb24gZG9lcyBzb21ldGltZXMgbm90IHdvcmsgcHJvcGVybHkuIFRoYXQgaXMgd2h5IHdoZW4gd2VcbiAgICAvLyBhcmUgY2hhbmdpbmcgdGhlIGNvbXBvc2l0aW9uLCB3ZSByZXNldCB0aGUgYXVkaW8gc3RhdGUuXG4gICAgLy8gVE9ETzogUG9zc2libHkgdGhpcyBkb2VzIG5vdCBzYXZlIHRoZSBwcm9ibGVtIGNvbXBsZXRlbHksIHNpbmNlIHRoZVxuICAgIC8vIGlmIGFuIGF1ZGlvIHRhZyB0aGF0IGlzIGluc2lkZSBhIHNlcXVlbmNlIHdpbGwgYWxzbyBub3QgYmUgcmVtb3ZlZFxuICAgIC8vIGZyb20gdGhlIHNoYXJlZCBhdWRpb3MuXG4gICAgY29uc3QgcmVzZXRBdWRpbyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgdGFrZW5BdWRpb3MuY3VycmVudCA9IG5ldyBBcnJheShudW1iZXJPZkF1ZGlvVGFncykuZmlsbChmYWxzZSk7XG4gICAgICAgIGF1ZGlvcy5jdXJyZW50ID0gW107XG4gICAgICAgIHJlcmVuZGVyQXVkaW9zKCk7XG4gICAgfSwgW251bWJlck9mQXVkaW9UYWdzLCByZXJlbmRlckF1ZGlvc10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICByZXNldEF1ZGlvKCk7XG4gICAgICAgIH07XG4gICAgfSwgW2NvbXBvbmVudCwgcmVzZXRBdWRpb10pO1xuICAgIHJldHVybiAoanN4cyhTaGFyZWRBdWRpb0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogW3JlZnMubWFwKCh7IGlkLCByZWYgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgLy8gV2l0aG91dCBwcmVsb2FkPVwibWV0YWRhdGFcIiwgaU9TIHdpbGwgc2VlayB0aGUgdGltZSBpbnRlcm5hbGx5XG4gICAgICAgICAgICAgICAgLy8gYnV0IG5vdCBhY3R1YWxseSB3aXRoIHNvdW5kLiBBZGRpbmcgYHByZWxvYWQ9XCJtZXRhZGF0YVwiYCBoZWxwcyBoZXJlLlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGlzY29yZC5jb20vY2hhbm5lbHMvODA5NTAxMzU1NTA0OTU5NTI4LzgxNzMwNjQxNDA2OTcxMDg0OC8xMTMwNTE5NTgzMzY3ODg4OTA2XG4gICAgICAgICAgICAgICAganN4KFwiYXVkaW9cIiwgeyByZWY6IHJlZiwgcHJlbG9hZDogXCJtZXRhZGF0YVwiLCBzcmM6IEVNUFRZX0FVRElPIH0sIGlkKSk7XG4gICAgICAgICAgICB9KSwgY2hpbGRyZW5dIH0pKTtcbn07XG5jb25zdCB1c2VTaGFyZWRBdWRpbyA9IChhdWQsIGF1ZGlvSWQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY3R4ID0gdXNlQ29udGV4dChTaGFyZWRBdWRpb0NvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIFdlIHdvcmsgYXJvdW5kIHRoaXMgaW4gUmVhY3QgMTggc28gYW4gYXVkaW8gdGFnIHdpbGwgb25seSByZWdpc3RlciBpdHNlbGYgb25jZVxuICAgICAqL1xuICAgIGNvbnN0IFtlbGVtXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKGN0eCAmJiBjdHgubnVtYmVyT2ZBdWRpb1RhZ3MgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnJlZ2lzdGVyQXVkaW8oYXVkLCBhdWRpb0lkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWw6IFJlYWN0LmNyZWF0ZVJlZigpLFxuICAgICAgICAgICAgaWQ6IE1hdGgucmFuZG9tKCksXG4gICAgICAgICAgICBwcm9wczogYXVkLFxuICAgICAgICAgICAgYXVkaW9JZCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBFZmZlY3RzIGluIFJlYWN0IDE4IGZpcmUgdHdpY2UsIGFuZCB3ZSBhcmUgbG9va2luZyBmb3IgYSB3YXkgdG8gb25seSBmaXJlIGl0IG9uY2UuXG4gICAgICogLSB1c2VJbnNlcnRpb25FZmZlY3Qgb25seSBmaXJlcyBvbmNlLiBJZiBpdCdzIGF2YWlsYWJsZSB3ZSBhcmUgaW4gUmVhY3QgMTguXG4gICAgICogLSB1c2VMYXlvdXRFZmZlY3Qgb25seSBmaXJlcyBvbmNlIGluIFJlYWN0IDE3LlxuICAgICAqXG4gICAgICogTmVlZCB0byBpbXBvcnQgaXQgZnJvbSBSZWFjdCB0byBmaXggUmVhY3QgMTcgRVNNIHN1cHBvcnQuXG4gICAgICovXG4gICAgY29uc3QgZWZmZWN0VG9Vc2UgPSAoX2EgPSBSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFJlYWN0LnVzZUxheW91dEVmZmVjdDtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBlZmZlY3RUb1VzZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgICAgICAgICBjdHgudXBkYXRlQXVkaW8oeyBpZDogZWxlbS5pZCwgYXVkLCBhdWRpb0lkIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBbYXVkLCBjdHgsIGVsZW0uaWQsIGF1ZGlvSWRdKTtcbiAgICAgICAgZWZmZWN0VG9Vc2UoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4ICYmIGN0eC5udW1iZXJPZkF1ZGlvVGFncyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4LnVucmVnaXN0ZXJBdWRpbyhlbGVtLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCBbY3R4LCBlbGVtLmlkXSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtO1xufTtcblxuY29uc3QgQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgY29uc3QgW2luaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHNdID0gdXNlU3RhdGUocHJvcHMuc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MpO1xuICAgIGlmIChwcm9wcy5zaG91bGRQcmVNb3VudEF1ZGlvVGFncyAhPT0gaW5pdGlhbFNob3VsZFByZU1vdW50QXVkaW9FbGVtZW50cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjaGFuZ2UgdGhlIGJlaGF2aW9yIGZvciBwcmUtbW91bnRpbmcgYXVkaW8gdGFncyBkeW5hbWljYWxseS4nKTtcbiAgICB9XG4gICAgY29uc3QgW21lZGlhVm9sdW1lXSA9IHVzZU1lZGlhVm9sdW1lU3RhdGUoKTtcbiAgICBjb25zdCBbbWVkaWFNdXRlZF0gPSB1c2VNZWRpYU11dGVkU3RhdGUoKTtcbiAgICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AoKTtcbiAgICBjb25zdCB7IHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSwgc2hvdWxkUHJlTW91bnRBdWRpb1RhZ3MsIHNyYywgb25EdXJhdGlvbiwgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcywgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb24sIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciwgLi4ubmF0aXZlUHJvcHMgfSA9IHByb3BzO1xuICAgIGlmICghc3JjKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJObyAnc3JjJyB3YXMgcGFzc2VkIHRvIDxBdWRpbz4uXCIpO1xuICAgIH1cbiAgICBjb25zdCBwcmVsb2FkZWRTcmMgPSB1c2VQcmVsb2FkKHNyYyk7XG4gICAgY29uc3QgcHJvcHNUb1Bhc3MgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG11dGVkOiBtdXRlZCB8fCBtZWRpYU11dGVkLFxuICAgICAgICAgICAgc3JjOiBwcmVsb2FkZWRTcmMsXG4gICAgICAgICAgICAuLi5uYXRpdmVQcm9wcyxcbiAgICAgICAgfTtcbiAgICB9LCBbbWVkaWFNdXRlZCwgbXV0ZWQsIG5hdGl2ZVByb3BzLCBwcmVsb2FkZWRTcmNdKTtcbiAgICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFNlcXVlbmNlQ29udGV4dCk7XG4gICAgLy8gR2VuZXJhdGUgYSBzdHJpbmcgdGhhdCdzIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZSBmb3IgdGhpcyBhc3NldFxuICAgIC8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGRldGVybWluaXN0aWMuIFdlIHVzZSBpdCB0byBjb21iYXQgc3RyaWN0IG1vZGUgaXNzdWVzLlxuICAgIGNvbnN0IGlkID0gdXNlTWVtbygoKSA9PiBgYXVkaW8tJHtyYW5kb20oc3JjICE9PSBudWxsICYmIHNyYyAhPT0gdm9pZCAwID8gc3JjIDogJycpfS0ke3NlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmR1cmF0aW9uSW5GcmFtZXN9LW11dGVkOiR7cHJvcHMubXV0ZWR9LWxvb3A6JHtwcm9wcy5sb29wfWAsIFtcbiAgICAgICAgc3JjLFxuICAgICAgICBzZXF1ZW5jZUNvbnRleHQgPT09IG51bGwgfHwgc2VxdWVuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXF1ZW5jZUNvbnRleHQucmVsYXRpdmVGcm9tLFxuICAgICAgICBzZXF1ZW5jZUNvbnRleHQgPT09IG51bGwgfHwgc2VxdWVuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXF1ZW5jZUNvbnRleHQuY3VtdWxhdGVkRnJvbSxcbiAgICAgICAgc2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmR1cmF0aW9uSW5GcmFtZXMsXG4gICAgICAgIHByb3BzLm11dGVkLFxuICAgICAgICBwcm9wcy5sb29wLFxuICAgIF0pO1xuICAgIGNvbnN0IGF1ZGlvUmVmID0gdXNlU2hhcmVkQXVkaW8ocHJvcHNUb1Bhc3MsIGlkKS5lbDtcbiAgICBjb25zdCBhY3R1YWxWb2x1bWUgPSB1c2VNZWRpYVRhZ1ZvbHVtZShhdWRpb1JlZik7XG4gICAgdXNlU3luY1ZvbHVtZVdpdGhNZWRpYVRhZyh7XG4gICAgICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICAgICAgYWN0dWFsVm9sdW1lLFxuICAgICAgICB2b2x1bWUsXG4gICAgICAgIG1lZGlhVm9sdW1lLFxuICAgICAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgfSk7XG4gICAgdXNlTWVkaWFJblRpbWVsaW5lKHtcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgbWVkaWFSZWY6IGF1ZGlvUmVmLFxuICAgICAgICBzcmMsXG4gICAgICAgIG1lZGlhVHlwZTogJ2F1ZGlvJyxcbiAgICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgIT09IG51bGwgJiYgcGxheWJhY2tSYXRlICE9PSB2b2lkIDAgPyBwbGF5YmFja1JhdGUgOiAxLFxuICAgIH0pO1xuICAgIHVzZU1lZGlhUGxheWJhY2soe1xuICAgICAgICBtZWRpYVJlZjogYXVkaW9SZWYsXG4gICAgICAgIHNyYyxcbiAgICAgICAgbWVkaWFUeXBlOiAnYXVkaW8nLFxuICAgICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSAhPT0gbnVsbCAmJiBwbGF5YmFja1JhdGUgIT09IHZvaWQgMCA/IHBsYXliYWNrUmF0ZSA6IDEsXG4gICAgICAgIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IGZhbHNlLFxuICAgICAgICBhY2NlcHRhYmxlVGltZXNoaWZ0OiBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzICE9PSBudWxsICYmIGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgIT09IHZvaWQgMCA/IGFjY2VwdGFibGVUaW1lU2hpZnRJblNlY29uZHMgOiBERUZBVUxUX0FDQ0VQVEFCTEVfVElNRVNISUZULFxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBhdWRpb1JlZi5jdXJyZW50O1xuICAgIH0sIFthdWRpb1JlZl0pO1xuICAgIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYoKTtcbiAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSBhdWRpb1JlZjtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIChfYSA9IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY3VycmVudE9uRHVyYXRpb25DYWxsYmFjaywgY3VycmVudC5zcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2ssIGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIG9uTG9hZGVkTWV0YWRhdGEpO1xuICAgICAgICB9O1xuICAgIH0sIFthdWRpb1JlZiwgc3JjXSk7XG4gICAgaWYgKGluaXRpYWxTaG91bGRQcmVNb3VudEF1ZGlvRWxlbWVudHMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBqc3goXCJhdWRpb1wiLCB7IHJlZjogYXVkaW9SZWYsIHByZWxvYWQ6IFwibWV0YWRhdGFcIiwgLi4ucHJvcHNUb1Bhc3MgfSk7XG59O1xuY29uc3QgQXVkaW9Gb3JEZXZlbG9wbWVudCA9IGZvcndhcmRSZWYoQXVkaW9Gb3JEZXZlbG9wbWVudEZvcndhcmRSZWZGdW5jdGlvbik7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9yZW5kZXJSZWFkeSA9IGZhbHNlO1xufVxubGV0IGhhbmRsZXMgPSBbXTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzID0ge307XG59XG5jb25zdCBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOID0gJ1RoZSBkZWxheVJlbmRlciB3YXMgY2FsbGVkOic7XG5jb25zdCBkZWZhdWx0VGltZW91dCA9IDMwMDAwO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQ2FsbCB0aGlzIGZ1bmN0aW9uIHRvIHRlbGwgUmVtb3Rpb24gdG8gd2FpdCBiZWZvcmUgY2FwdHVyaW5nIHRoaXMgZnJhbWUgdW50aWwgZGF0YSBoYXMgbG9hZGVkLiBVc2UgY29udGludWVSZW5kZXIoKSB0byB1bmJsb2NrIHRoZSByZW5kZXIuXG4gKiBAcGFyYW0gbGFiZWwgX29wdGlvbmFsXyBBIGxhYmVsIHRvIGlkZW50aWZ5IHRoZSBjYWxsIGluIGNhc2UgaXQgZG9lcyB0aW1lIG91dC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IEFuIGlkZW50aWZpZXIgdG8gYmUgcGFzc2VkIHRvIGNvbnRpbnVlUmVuZGVyKCkuXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9kZWxheS1yZW5kZXIpXG4gKi9cbmNvbnN0IGRlbGF5UmVuZGVyID0gKGxhYmVsKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKHR5cGVvZiBsYWJlbCAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGxhYmVsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsYWJlbCBwYXJhbWV0ZXIgb2YgZGVsYXlSZW5kZXIoKSBtdXN0IGJlIGEgc3RyaW5nIG9yIHVuZGVmaW5lZCwgZ290OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGxhYmVsKSk7XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZSA9IE1hdGgucmFuZG9tKCk7XG4gICAgaGFuZGxlcy5wdXNoKGhhbmRsZSk7XG4gICAgY29uc3QgY2FsbGVkID0gKF9iID0gKF9hID0gRXJyb3IoKS5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoL15FcnJvci9nLCAnJykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnO1xuICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgY29uc3QgdGltZW91dFRvVXNlID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgID8gZGVmYXVsdFRpbWVvdXRcbiAgICAgICAgICAgIDogKChfYyA9IHdpbmRvdy5yZW1vdGlvbl9wdXBwZXRlZXJUaW1lb3V0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0VGltZW91dCkgLSAyMDAwO1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdGlvbl9kZWxheVJlbmRlclRpbWVvdXRzW2hhbmRsZV0gPSB7XG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsICE9PSBudWxsICYmIGxhYmVsICE9PSB2b2lkIDAgPyBsYWJlbCA6IG51bGwsXG4gICAgICAgICAgICAgICAgdGltZW91dDogc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBgQSBkZWxheVJlbmRlcigpYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsID8gYFwiJHtsYWJlbH1cImAgOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgYHdhcyBjYWxsZWQgYnV0IG5vdCBjbGVhcmVkIGFmdGVyICR7dGltZW91dFRvVXNlfW1zLiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy90aW1lb3V0IGZvciBoZWxwLmAsXG4gICAgICAgICAgICAgICAgICAgICAgICBERUxBWV9SRU5ERVJfQ0FMTFNUQUNLX1RPS0VOLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKHRydXRoeSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9LCB0aW1lb3V0VG9Vc2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2luZG93LnJlbW90aW9uX3JlbmRlclJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGU7XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gVW5ibG9jayBhIHJlbmRlciB0aGF0IGhhcyBiZWVuIGJsb2NrZWQgYnkgZGVsYXlSZW5kZXIoKVxuICogQHBhcmFtIGhhbmRsZSBUaGUgcmV0dXJuIHZhbHVlIG9mIGRlbGF5UmVuZGVyKCkuXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9jb250aW51ZS1yZW5kZXIpXG4gKi9cbmNvbnN0IGNvbnRpbnVlUmVuZGVyID0gKGhhbmRsZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY29udGludWVSZW5kZXIoKSBtZXRob2QgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHBhcmFtZXRlciB0aGF0IGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKS4gTm8gdmFsdWUgd2FzIHBhc3NlZC4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBoYW5kbGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBwYXJhbWV0ZXIgcGFzc2VkIGludG8gY29udGludWVSZW5kZXIoKSBtdXN0IGJlIHRoZSByZXR1cm4gdmFsdWUgb2YgZGVsYXlSZW5kZXIoKSB3aGljaCBpcyBhIG51bWJlci4gR290OiAnICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGhhbmRsZSkpO1xuICAgIH1cbiAgICBoYW5kbGVzID0gaGFuZGxlcy5maWx0ZXIoKGgpID0+IHtcbiAgICAgICAgaWYgKGggPT09IGhhbmRsZSkge1xuICAgICAgICAgICAgaWYgKGdldFJlbW90aW9uRW52aXJvbm1lbnQoKS5pc1JlbmRlcmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdLnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3aW5kb3cucmVtb3Rpb25fZGVsYXlSZW5kZXJUaW1lb3V0c1toYW5kbGVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3aW5kb3cucmVtb3Rpb25fcmVuZGVyUmVhZHkgPSB0cnVlO1xuICAgIH1cbn07XG5cbmNvbnN0IFJlbmRlckFzc2V0TWFuYWdlciA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIC8vIE11c3QgYmUgdW5kZWZpbmVkLCBvdGhlcndpc2UgZXJyb3IgaW4gUGxheWVyXG4gICAgcmVnaXN0ZXJSZW5kZXJBc3NldDogKCkgPT4gdW5kZWZpbmVkLFxuICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldDogKCkgPT4gdW5kZWZpbmVkLFxuICAgIHJlbmRlckFzc2V0czogW10sXG59KTtcbmNvbnN0IFJlbmRlckFzc2V0TWFuYWdlclByb3ZpZGVyID0gKHsgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IFtyZW5kZXJBc3NldHMsIHNldFJlbmRlckFzc2V0c10gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgcmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrKChyZW5kZXJBc3NldCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJBc3NldHMoKGFzc2V0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hc3NldHMsIHJlbmRlckFzc2V0XTtcbiAgICAgICAgfSk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IHVucmVnaXN0ZXJSZW5kZXJBc3NldCA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICBzZXRSZW5kZXJBc3NldHMoKGFzc3RzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYXNzdHMuZmlsdGVyKChhKSA9PiBhLmlkICE9PSBpZCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdGlvbl9jb2xsZWN0QXNzZXRzID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldFJlbmRlckFzc2V0cyhbXSk7IC8vIGNsZWFyIGFzc2V0cyBhdCBuZXh0IHJlbmRlclxuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJBc3NldHM7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW3JlbmRlckFzc2V0c10pO1xuICAgIGNvbnN0IGNvbnRleHRWYWx1ZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgICAgICAgIHVucmVnaXN0ZXJSZW5kZXJBc3NldCxcbiAgICAgICAgICAgIHJlbmRlckFzc2V0cyxcbiAgICAgICAgfTtcbiAgICB9LCBbcmVuZGVyQXNzZXRzLCByZWdpc3RlclJlbmRlckFzc2V0LCB1bnJlZ2lzdGVyUmVuZGVyQXNzZXRdKTtcbiAgICByZXR1cm4gKGpzeChSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRWYWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbmNvbnN0IEF1ZGlvRm9yUmVuZGVyaW5nUmVmRm9yd2FyZGluZ0Z1bmN0aW9uID0gKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICAgIGNvbnN0IHZvbHVtZVByb3BGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcCgpO1xuICAgIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gICAgY29uc3Qgc2VxdWVuY2VDb250ZXh0ID0gdXNlQ29udGV4dChTZXF1ZW5jZUNvbnRleHQpO1xuICAgIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gICAgLy8gR2VuZXJhdGUgYSBzdHJpbmcgdGhhdCdzIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZSBmb3IgdGhpcyBhc3NldFxuICAgIC8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIHRoZSBzYW1lIG9uIGFsbCB0aHJlYWRzXG4gICAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYGF1ZGlvLSR7cmFuZG9tKChfYSA9IHByb3BzLnNyYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpfS0ke3NlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmR1cmF0aW9uSW5GcmFtZXN9YDtcbiAgICB9LCBbcHJvcHMuc3JjLCBzZXF1ZW5jZUNvbnRleHRdKTtcbiAgICBjb25zdCB7IHZvbHVtZTogdm9sdW1lUHJvcCwgcGxheWJhY2tSYXRlLCBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsIG9uRHVyYXRpb24sIHRvbmVGcmVxdWVuY3ksIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uLCBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzLCAuLi5uYXRpdmVQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgICAgIGZyYW1lOiB2b2x1bWVQcm9wRnJhbWUsXG4gICAgICAgIG1lZGlhVm9sdW1lOiAxLFxuICAgICAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXI6IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciAhPT0gbnVsbCAmJiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgIT09IHZvaWQgMCA/IGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciA6IGZhbHNlLFxuICAgIH0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBhdWRpb1JlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcHJvcHMuc3JjKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNyYyBwYXNzZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl9hdWRpb0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMubXV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodm9sdW1lIDw9IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlclJlbmRlckFzc2V0KHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICBzcmM6IGdldEFic29sdXRlU3JjKHByb3BzLnNyYyksXG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGZyYW1lOiBhYnNvbHV0ZUZyYW1lLFxuICAgICAgICAgICAgdm9sdW1lLFxuICAgICAgICAgICAgbWVkaWFGcmFtZTogZnJhbWUsXG4gICAgICAgICAgICBwbGF5YmFja1JhdGU6IChfYSA9IHByb3BzLnBsYXliYWNrUmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMSxcbiAgICAgICAgICAgIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlcjogYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyICE9PSBudWxsICYmIGFsbG93QW1wbGlmaWNhdGlvbkR1cmluZ1JlbmRlciAhPT0gdm9pZCAwID8gYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyIDogZmFsc2UsXG4gICAgICAgICAgICB0b25lRnJlcXVlbmN5OiB0b25lRnJlcXVlbmN5ICE9PSBudWxsICYmIHRvbmVGcmVxdWVuY3kgIT09IHZvaWQgMCA/IHRvbmVGcmVxdWVuY3kgOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVucmVnaXN0ZXJSZW5kZXJBc3NldChpZCk7XG4gICAgfSwgW1xuICAgICAgICBwcm9wcy5tdXRlZCxcbiAgICAgICAgcHJvcHMuc3JjLFxuICAgICAgICByZWdpc3RlclJlbmRlckFzc2V0LFxuICAgICAgICBhYnNvbHV0ZUZyYW1lLFxuICAgICAgICBpZCxcbiAgICAgICAgdW5yZWdpc3RlclJlbmRlckFzc2V0LFxuICAgICAgICB2b2x1bWUsXG4gICAgICAgIHZvbHVtZVByb3BGcmFtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgcHJvcHMucGxheWJhY2tSYXRlLFxuICAgICAgICBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsXG4gICAgICAgIHRvbmVGcmVxdWVuY3ksXG4gICAgXSk7XG4gICAgY29uc3QgeyBzcmMgfSA9IHByb3BzO1xuICAgIC8vIFRoZSA8YXVkaW8+IHRhZyBpcyBvbmx5IHJlbmRlcmVkIGlmIHRoZSBkdXJhdGlvbiBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIGZvciB0aGUgYGxvb3BgXG4gICAgLy8gYXR0cmlidXRlIHRvIHdvcmssIG9yIGlmIHRoZSB1c2VyIGFzc2lnbnMgYSByZWYgdG8gaXQuXG4gICAgY29uc3QgbmVlZHNUb1JlbmRlckF1ZGlvVGFnID0gcmVmIHx8IF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uO1xuICAgIC8vIElmIGF1ZGlvIHNvdXJjZSBzd2l0Y2hlcywgbWFrZSBuZXcgaGFuZGxlXG4gICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5lZWRzVG9SZW5kZXJBdWRpb1RhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0hhbmRsZSA9IGRlbGF5UmVuZGVyKCdMb2FkaW5nIDxBdWRpbz4gZHVyYXRpb24gd2l0aCBzcmM9JyArIHNyYyk7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gYXVkaW9SZWY7XG4gICAgICAgIGNvbnN0IGRpZExvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgb25EdXJhdGlvbihjdXJyZW50LnNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmR1cmF0aW9uKSB7XG4gICAgICAgICAgICBvbkR1cmF0aW9uKGN1cnJlbnQuc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKG5ld0hhbmRsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGFnIGdldHMgdW5tb3VudGVkLCBjbGVhciBwZW5kaW5nIGhhbmRsZXMgYmVjYXVzZSB2aWRlbyBtZXRhZGF0YSBpcyBub3QgZ29pbmcgdG8gbG9hZFxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgZGlkTG9hZCk7XG4gICAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtzcmMsIG9uRHVyYXRpb24sIG5lZWRzVG9SZW5kZXJBdWRpb1RhZ10pO1xuICAgIGlmICghbmVlZHNUb1JlbmRlckF1ZGlvVGFnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4ganN4KFwiYXVkaW9cIiwgeyByZWY6IGF1ZGlvUmVmLCAuLi5uYXRpdmVQcm9wcyB9KTtcbn07XG5jb25zdCBBdWRpb0ZvclJlbmRlcmluZyA9IGZvcndhcmRSZWYoQXVkaW9Gb3JSZW5kZXJpbmdSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG5jb25zdCBBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGF1ZGlvQ29udGV4dCA9IHVzZUNvbnRleHQoU2hhcmVkQXVkaW9Db250ZXh0KTtcbiAgICBjb25zdCB7IHN0YXJ0RnJvbSwgZW5kQXQsIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0KER1cmF0aW9uc0NvbnRleHQpO1xuICAgIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPEF1ZGlvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9uRXJyb3IgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBjb25zb2xlLmxvZyhlLmN1cnJlbnRUYXJnZXQuZXJyb3IpO1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBgbG9vcGAgcHJvcGVydHksIHdlIGRvbid0IG5lZWQgdG8gZ2V0IHRoZSBkdXJhdGlvblxuICAgICAgICAvLyBhbmQgdGhpcyBkb2VzIG5vdCBuZWVkIHRvIGJlIGEgZmF0YWwgZXJyb3JcbiAgICAgICAgY29uc3QgZXJyTWVzc2FnZSA9IGBDb3VsZCBub3QgcGxheSBhdWRpbyB3aXRoIHNyYyAke290aGVyUHJvcHMuc3JjfTogJHtlLmN1cnJlbnRUYXJnZXQuZXJyb3J9LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy9tZWRpYS1wbGF5YmFjay1lcnJvciBmb3IgaGVscC5gO1xuICAgICAgICBpZiAobG9vcCkge1xuICAgICAgICAgICAgY2FuY2VsUmVuZGVyKG5ldyBFcnJvcihlcnJNZXNzYWdlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZXJyTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LCBbbG9vcCwgb3RoZXJQcm9wcy5zcmNdKTtcbiAgICBjb25zdCBvbkR1cmF0aW9uID0gdXNlQ2FsbGJhY2soKHNyYywgZHVyYXRpb25JblNlY29uZHMpID0+IHtcbiAgICAgICAgc2V0RHVyYXRpb25zKHsgdHlwZTogJ2dvdC1kdXJhdGlvbicsIGR1cmF0aW9uSW5TZWNvbmRzLCBzcmMgfSk7XG4gICAgfSwgW3NldER1cmF0aW9uc10pO1xuICAgIGlmIChsb29wICYmIHByb3BzLnNyYyAmJiBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBkdXJhdGlvbiA9IE1hdGguZmxvb3IoZHVyYXRpb25zW2dldEFic29sdXRlU3JjKHByb3BzLnNyYyldICogZnBzKTtcbiAgICAgICAgcmV0dXJuIChqc3goTG9vcCwgeyBsYXlvdXQ6IFwibm9uZVwiLCBkdXJhdGlvbkluRnJhbWVzOiBjYWxjdWxhdGVMb29wRHVyYXRpb24oe1xuICAgICAgICAgICAgICAgIGVuZEF0LFxuICAgICAgICAgICAgICAgIG1lZGlhRHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogKF9hID0gcHJvcHMucGxheWJhY2tSYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSxcbiAgICAgICAgICAgIH0pLCBjaGlsZHJlbjoganN4KEF1ZGlvLCB7IC4uLnByb3BzT3RoZXJUaGFuTG9vcCwgcmVmOiByZWYgfSkgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVuZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgICAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tICE9PSBudWxsICYmIHN0YXJ0RnJvbSAhPT0gdm9pZCAwID8gc3RhcnRGcm9tIDogMDtcbiAgICAgICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgIT09IG51bGwgJiYgZW5kQXQgIT09IHZvaWQgMCA/IGVuZEF0IDogSW5maW5pdHk7XG4gICAgICAgIHJldHVybiAoanN4KFNlcXVlbmNlLCB7IGxheW91dDogXCJub25lXCIsIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLCBzaG93SW5UaW1lbGluZTogZmFsc2UsIGR1cmF0aW9uSW5GcmFtZXM6IGVuZEF0RnJhbWVObywgY2hpbGRyZW46IGpzeChBdWRpbywgeyBfcmVtb3Rpb25JbnRlcm5hbE5lZWRzRHVyYXRpb25DYWxjdWxhdGlvbjogQm9vbGVhbihsb29wKSwgLi4ub3RoZXJQcm9wcywgcmVmOiByZWYgfSkgfSkpO1xuICAgIH1cbiAgICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMsICdBdWRpbycpO1xuICAgIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgICAgICByZXR1cm4gKGpzeChBdWRpb0ZvclJlbmRlcmluZywgeyBvbkR1cmF0aW9uOiBvbkR1cmF0aW9uLCAuLi5wcm9wcywgcmVmOiByZWYsIG9uRXJyb3I6IG9uRXJyb3IsIF9yZW1vdGlvbkludGVybmFsTmVlZHNEdXJhdGlvbkNhbGN1bGF0aW9uOiBCb29sZWFuKGxvb3ApIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goQXVkaW9Gb3JEZXZlbG9wbWVudCwgeyBzaG91bGRQcmVNb3VudEF1ZGlvVGFnczogYXVkaW9Db250ZXh0ICE9PSBudWxsICYmIGF1ZGlvQ29udGV4dC5udW1iZXJPZkF1ZGlvVGFncyA+IDAsIC4uLnByb3BzLCByZWY6IHJlZiwgb25FcnJvcjogb25FcnJvciwgb25EdXJhdGlvbjogb25EdXJhdGlvbiwgX3JlbW90aW9uSW50ZXJuYWxOZWVkc0R1cmF0aW9uQ2FsY3VsYXRpb246IEJvb2xlYW4obG9vcCkgfSkpO1xufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIFdpdGggdGhpcyBjb21wb25lbnQsIHlvdSBjYW4gYWRkIGF1ZGlvIHRvIHlvdXIgdmlkZW8uIEFsbCBhdWRpbyBmb3JtYXRzIHdoaWNoIGFyZSBzdXBwb3J0ZWQgYnkgQ2hyb21pdW0gYXJlIHN1cHBvcnRlZCBieSB0aGUgY29tcG9uZW50LlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvYXVkaW8pXG4gKi9cbmNvbnN0IEF1ZGlvID0gZm9yd2FyZFJlZihBdWRpb1JlZkZvcndhcmRpbmdGdW5jdGlvbik7XG5cbmNvbnN0IGdldFJlZ2V4JDEgPSAoKSA9PiAvXihbYS16QS1aMC05LV0pKyQvZztcbmNvbnN0IGlzRm9sZGVyTmFtZVZhbGlkID0gKG5hbWUpID0+IG5hbWUubWF0Y2goZ2V0UmVnZXgkMSgpKTtcbmNvbnN0IHZhbGlkYXRlRm9sZGVyTmFtZSA9IChuYW1lKSA9PiB7XG4gICAgaWYgKG5hbWUgPT09IHVuZGVmaW5lZCB8fCBuYW1lID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHBhc3MgYSBuYW1lIHRvIGEgPEZvbGRlciAvPi4nKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJuYW1lXCIgeW91IHBhc3MgaW50byA8Rm9sZGVyIC8+IG11c3QgYmUgYSBzdHJpbmcuIEdvdDogJHt0eXBlb2YgbmFtZX1gKTtcbiAgICB9XG4gICAgaWYgKCFpc0ZvbGRlck5hbWVWYWxpZChuYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvbGRlciBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYS16LCBBLVosIDAtOSBhbmQgLS4gWW91IHBhc3NlZCAke25hbWV9YCk7XG4gICAgfVxufTtcblxuY29uc3QgRm9sZGVyQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe1xuICAgIGZvbGRlck5hbWU6IG51bGwsXG4gICAgcGFyZW50TmFtZTogbnVsbCxcbn0pO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gQnkgd3JhcHBpbmcgYSA8Q29tcG9zaXRpb24gLz4gaW5zaWRlIGEgPEZvbGRlciAvPiwgeW91IGNhbiB2aXN1YWxseSBjYXRlZ29yaXplIGl0IGluIHlvdXIgc2lkZWJhciwgc2hvdWxkIHlvdSBoYXZlIG1hbnkgY29tcG9zaXRpb25zLlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvZm9sZGVyKVxuICovXG5jb25zdCBGb2xkZXIgPSAoeyBuYW1lLCBjaGlsZHJlbiwgfSkgPT4ge1xuICAgIGNvbnN0IHBhcmVudCA9IHVzZUNvbnRleHQoRm9sZGVyQ29udGV4dCk7XG4gICAgY29uc3QgeyByZWdpc3RlckZvbGRlciwgdW5yZWdpc3RlckZvbGRlciB9ID0gdXNlQ29udGV4dChDb21wb3NpdGlvbk1hbmFnZXIpO1xuICAgIHZhbGlkYXRlRm9sZGVyTmFtZShuYW1lKTtcbiAgICBjb25zdCBwYXJlbnROYW1lQXJyID0gW3BhcmVudC5wYXJlbnROYW1lLCBwYXJlbnQuZm9sZGVyTmFtZV0uZmlsdGVyKHRydXRoeSk7XG4gICAgY29uc3QgcGFyZW50TmFtZSA9IHBhcmVudE5hbWVBcnIubGVuZ3RoID09PSAwID8gbnVsbCA6IHBhcmVudE5hbWVBcnIuam9pbignLycpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb2xkZXJOYW1lOiBuYW1lLFxuICAgICAgICAgICAgcGFyZW50TmFtZSxcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgcGFyZW50TmFtZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZ2lzdGVyRm9sZGVyKG5hbWUsIHBhcmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdW5yZWdpc3RlckZvbGRlcihuYW1lLCBwYXJlbnROYW1lKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgcGFyZW50LmZvbGRlck5hbWUsIHBhcmVudE5hbWUsIHJlZ2lzdGVyRm9sZGVyLCB1bnJlZ2lzdGVyRm9sZGVyXSk7XG4gICAgcmV0dXJuIChqc3goRm9sZGVyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59O1xuXG5jb25zdCByb3RhdGUgPSB7XG4gICAgdHJhbnNmb3JtOiBgcm90YXRlKDkwZGVnKWAsXG59O1xuY29uc3QgSUNPTl9TSVpFID0gNDA7XG5jb25zdCBsYWJlbCA9IHtcbiAgICBjb2xvcjogJ3doaXRlJyxcbiAgICBmb250U2l6ZTogMTQsXG4gICAgZm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxufTtcbmNvbnN0IGNvbnRhaW5lciA9IHtcbiAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXG4gICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG59O1xuY29uc3QgTG9hZGluZyA9ICgpID0+IHtcbiAgICByZXR1cm4gKGpzeHMoQWJzb2x1dGVGaWxsLCB7IHN0eWxlOiBjb250YWluZXIsIGlkOiBcInJlbW90aW9uLWNvbXAtbG9hZGluZ1wiLCBjaGlsZHJlbjogW2pzeChcInN0eWxlXCIsIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiLCBjaGlsZHJlbjogYFxuXHRcdFx0XHRAa2V5ZnJhbWVzIGFuaW0ge1xuXHRcdFx0XHRcdGZyb20ge1xuXHRcdFx0XHRcdFx0b3BhY2l0eTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0byB7XG5cdFx0XHRcdFx0XHRvcGFjaXR5OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdCNyZW1vdGlvbi1jb21wLWxvYWRpbmcge1xuXHRcdFx0XHRcdGFuaW1hdGlvbjogYW5pbSAycztcblx0XHRcdFx0XHRhbmltYXRpb24tZmlsbC1tb2RlOiBmb3J3YXJkcztcblx0XHRcdFx0fVxuXHRcdFx0YCB9KSwganN4KFwic3ZnXCIsIHsgd2lkdGg6IElDT05fU0laRSwgaGVpZ2h0OiBJQ09OX1NJWkUsIHZpZXdCb3g6IFwiLTEwMCAtMTAwIDQwMCA0MDBcIiwgc3R5bGU6IHJvdGF0ZSwgY2hpbGRyZW46IGpzeChcInBhdGhcIiwgeyBmaWxsOiBcIiM1NTVcIiwgc3Ryb2tlOiBcIiM1NTVcIiwgc3Ryb2tlV2lkdGg6IFwiMTAwXCIsIHN0cm9rZUxpbmVqb2luOiBcInJvdW5kXCIsIGQ6IFwiTSAyIDE3MiBhIDE5NiAxMDAgMCAwIDAgMTk1IDUgQSAxOTYgMjQwIDAgMCAwIDEwMCAyLjI1OSBBIDE5NiAyNDAgMCAwIDAgMiAxNzIgelwiIH0pIH0pLCBqc3hzKFwicFwiLCB7IHN0eWxlOiBsYWJlbCwgY2hpbGRyZW46IFtcIlJlc29sdmluZyBcIiwgJzxTdXNwZW5zZT4nLCBcIi4uLlwiXSB9KV0gfSkpO1xufTtcblxubGV0IF9wb3J0YWxOb2RlID0gbnVsbDtcbmNvbnN0IHBvcnRhbE5vZGUgPSAoKSA9PiB7XG4gICAgaWYgKCFfcG9ydGFsTm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmllZCB0byBjYWxsIGFuIEFQSSB0aGF0IG9ubHkgd29ya3MgaW4gdGhlIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHRoZSBicm93c2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgX3BvcnRhbE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgX3BvcnRhbE5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBfcG9ydGFsTm9kZS5zdHlsZS50b3AgPSAnMHB4JztcbiAgICAgICAgX3BvcnRhbE5vZGUuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgICAgICBfcG9ydGFsTm9kZS5zdHlsZS5yaWdodCA9ICcwcHgnO1xuICAgICAgICBfcG9ydGFsTm9kZS5zdHlsZS5ib3R0b20gPSAnMHB4JztcbiAgICAgICAgX3BvcnRhbE5vZGUuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIF9wb3J0YWxOb2RlLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgX3BvcnRhbE5vZGUuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgX3BvcnRhbE5vZGUuc3R5bGUuZmxleERpcmVjdGlvbiA9ICdjb2x1bW4nO1xuICAgIH1cbiAgICByZXR1cm4gX3BvcnRhbE5vZGU7XG59O1xuXG4vLyBFeHBlY3RlZCwgaXQgY2FuIGJlIGFueSBjb21wb25lbnQgcHJvcHNcbmNvbnN0IHVzZUxhenlDb21wb25lbnQgPSAoY29tcFByb3BzKSA9PiB7XG4gICAgY29uc3QgbGF6eSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBpZiAoJ2xhenlDb21wb25lbnQnIGluIGNvbXBQcm9wcykge1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmxhenkoY29tcFByb3BzLmxhenlDb21wb25lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnY29tcG9uZW50JyBpbiBjb21wUHJvcHMpIHtcbiAgICAgICAgICAgIC8vIEluIFNTUiwgc3VzcGVuc2UgaXMgbm90IHlldCBzdXBwb3J0ZWQsIHdlIGNhbm5vdCB1c2UgUmVhY3QubGF6eVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcFByb3BzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBSZWFjdC5sYXp5KCgpID0+IFByb21pc2UucmVzb2x2ZSh7IGRlZmF1bHQ6IGNvbXBQcm9wcy5jb21wb25lbnQgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgZWl0aGVyICdjb21wb25lbnQnIG9yICdsYXp5Q29tcG9uZW50J1wiKTtcbiAgICAgICAgLy8gVmVyeSBpbXBvcnRhbnQgdG8gbGVhdmUgdGhlIGRlcGVuZGVuY2llcyBhcyB0aGV5IGFyZSwgb3IgaW5zdGVhZFxuICAgICAgICAvLyB0aGUgcGxheWVyIHdpbGwgcmVtb3VudCBvbiBldmVyeSBmcmFtZS5cbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW2NvbXBQcm9wcy5jb21wb25lbnQsIGNvbXBQcm9wcy5sYXp5Q29tcG9uZW50XSk7XG4gICAgcmV0dXJuIGxhenk7XG59O1xuXG5jb25zdCBnZXRSZWdleCA9ICgpID0+IC9eKFthLXpBLVowLTktXSkrJC9nO1xuY29uc3QgaXNDb21wb3NpdGlvbklkVmFsaWQgPSAoaWQpID0+IGlkLm1hdGNoKGdldFJlZ2V4KCkpO1xuY29uc3QgdmFsaWRhdGVDb21wb3NpdGlvbklkID0gKGlkKSA9PiB7XG4gICAgaWYgKCFpc0NvbXBvc2l0aW9uSWRWYWxpZChpZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb3NpdGlvbiBpZCBjYW4gb25seSBjb250YWluIGEteiwgQS1aLCAwLTkgYW5kIC0uIFlvdSBwYXNzZWQgJHtpZH1gKTtcbiAgICB9XG59O1xuY29uc3QgaW52YWxpZENvbXBvc2l0aW9uRXJyb3JNZXNzYWdlID0gYENvbXBvc2l0aW9uIElEIG11c3QgbWF0Y2ggJHtTdHJpbmcoZ2V0UmVnZXgoKSl9YDtcblxuY29uc3QgdmFsaWRhdGVEZWZhdWx0QW5kSW5wdXRQcm9wcyA9IChkZWZhdWx0UHJvcHMsIG5hbWUsIGNvbXBvc2l0aW9uSWQpID0+IHtcbiAgICBpZiAoIWRlZmF1bHRQcm9wcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZGVmYXVsdFByb3BzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtuYW1lfVwiIG11c3QgYmUgYW4gb2JqZWN0LCBidXQgeW91IHBhc3NlZCBhIHZhbHVlIG9mIHR5cGUgJHt0eXBlb2YgZGVmYXVsdFByb3BzfWApO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0UHJvcHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke25hbWV9XCIgbXVzdCBiZSBhbiBvYmplY3QsIGFuIGFycmF5IHdhcyBwYXNzZWQgJHtjb21wb3NpdGlvbklkID8gYGZvciBjb21wb3NpdGlvbiBcIiR7Y29tcG9zaXRpb25JZH1cImAgOiAnJ31gKTtcbiAgICB9XG59O1xuXG5jb25zdCBDbGlwQ29tcG9zaXRpb24gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gICAgY29uc3QgeyBjbGlwUmVnaW9uIH0gPSB1c2VDb250ZXh0KE5hdGl2ZUxheWVyc0NvbnRleHQpO1xuICAgIGNvbnN0IHN0eWxlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXG4gICAgICAgICAgICBmbGV4RGlyZWN0aW9uOiAncm93JyxcbiAgICAgICAgICAgIG9wYWNpdHk6IGNsaXBSZWdpb24gPT09ICdoaWRlJyA/IDAgOiAxLFxuICAgICAgICAgICAgY2xpcFBhdGg6IGNsaXBSZWdpb24gJiYgY2xpcFJlZ2lvbiAhPT0gJ2hpZGUnXG4gICAgICAgICAgICAgICAgPyBgcG9seWdvbigke2NsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLnh9cHggJHtjbGlwUmVnaW9uLmhlaWdodCArIGNsaXBSZWdpb24ueX1weCwgJHtjbGlwUmVnaW9uLndpZHRoICsgY2xpcFJlZ2lvbi54fXB4ICR7Y2xpcFJlZ2lvbi5oZWlnaHQgKyBjbGlwUmVnaW9uLnl9cHgsICR7Y2xpcFJlZ2lvbi53aWR0aCArIGNsaXBSZWdpb24ueH1weCAke2NsaXBSZWdpb24ueX1weClgXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSwgW2NsaXBSZWdpb25dKTtcbiAgICByZXR1cm4ganN4KEFic29sdXRlRmlsbCwgeyBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KTtcbn07XG5jb25zdCBGYWxsYmFjayA9ICgpID0+IHtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBmYWxsYmFjayA9IGRlbGF5UmVuZGVyKCdXYWl0aW5nIGZvciBSb290IGNvbXBvbmVudCB0byB1bnN1c3BlbmQnKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGNvbnRpbnVlUmVuZGVyKGZhbGxiYWNrKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG51bGw7XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBjb21wb25lbnQgaXMgdXNlZCB0byByZWdpc3RlciBhIHZpZGVvIHRvIG1ha2UgaXQgcmVuZGVyYWJsZSBhbmQgbWFrZSBpdCBzaG93IGluIHRoZSBzaWRlYmFyLCBpbiBkZXYgbW9kZS5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2NvbXBvc2l0aW9uKVxuICovXG5jb25zdCBDb21wb3NpdGlvbiA9ICh7IHdpZHRoLCBoZWlnaHQsIGZwcywgZHVyYXRpb25JbkZyYW1lcywgaWQsIGRlZmF1bHRQcm9wcywgc2NoZW1hLCAuLi5jb21wUHJvcHMgfSkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgeyByZWdpc3RlckNvbXBvc2l0aW9uLCB1bnJlZ2lzdGVyQ29tcG9zaXRpb24gfSA9IHVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgICBjb25zdCB2aWRlbyA9IHVzZVZpZGVvKCk7XG4gICAgY29uc3QgbGF6eSA9IHVzZUxhenlDb21wb25lbnQoY29tcFByb3BzKTtcbiAgICBjb25zdCBub25jZSA9IHVzZU5vbmNlKCk7XG4gICAgY29uc3QgaXNQbGF5ZXIgPSB1c2VJc1BsYXllcigpO1xuICAgIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IGNhblVzZUNvbXBvc2l0aW9uID0gdXNlQ29udGV4dChDYW5Vc2VSZW1vdGlvbkhvb2tzKTtcbiAgICBpZiAoY2FuVXNlQ29tcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKGlzUGxheWVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxDb21wb3NpdGlvbj4gd2FzIG1vdW50ZWQgaW5zaWRlIHRoZSBgY29tcG9uZW50YCB0aGF0IHdhcyBwYXNzZWQgdG8gdGhlIDxQbGF5ZXI+LiBTZWUgaHR0cHM6Ly9yZW1vdGlvbi5kZXYvZG9jcy93cm9uZy1jb21wb3NpdGlvbi1tb3VudCBmb3IgaGVscC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJzxDb21wb3NpdGlvbj4gbW91bnRlZCBpbnNpZGUgYW5vdGhlciBjb21wb3NpdGlvbi4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3Mvd3JvbmctY29tcG9zaXRpb24tbW91bnQgZm9yIGhlbHAuJyk7XG4gICAgfVxuICAgIGNvbnN0IHsgZm9sZGVyTmFtZSwgcGFyZW50TmFtZSB9ID0gdXNlQ29udGV4dChGb2xkZXJDb250ZXh0KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIEVuc3VyZSBpdCdzIGEgVVJMIHNhZmUgaWRcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpZCBmb3IgY29tcG9zaXRpb24gcGFzc2VkLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhbGlkYXRlQ29tcG9zaXRpb25JZChpZCk7XG4gICAgICAgIHZhbGlkYXRlRGVmYXVsdEFuZElucHV0UHJvcHMoZGVmYXVsdFByb3BzLCAnZGVmYXVsdFByb3BzJywgaWQpO1xuICAgICAgICByZWdpc3RlckNvbXBvc2l0aW9uKHtcbiAgICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IGR1cmF0aW9uSW5GcmFtZXMgIT09IG51bGwgJiYgZHVyYXRpb25JbkZyYW1lcyAhPT0gdm9pZCAwID8gZHVyYXRpb25JbkZyYW1lcyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGZwczogZnBzICE9PSBudWxsICYmIGZwcyAhPT0gdm9pZCAwID8gZnBzIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgIT09IG51bGwgJiYgaGVpZ2h0ICE9PSB2b2lkIDAgPyBoZWlnaHQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB3aWR0aDogd2lkdGggIT09IG51bGwgJiYgd2lkdGggIT09IHZvaWQgMCA/IHdpZHRoIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBmb2xkZXJOYW1lLFxuICAgICAgICAgICAgY29tcG9uZW50OiBsYXp5LFxuICAgICAgICAgICAgZGVmYXVsdFByb3BzOiBkZWZhdWx0UHJvcHMsXG4gICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgIHBhcmVudEZvbGRlck5hbWU6IHBhcmVudE5hbWUsXG4gICAgICAgICAgICBzY2hlbWE6IHNjaGVtYSAhPT0gbnVsbCAmJiBzY2hlbWEgIT09IHZvaWQgMCA/IHNjaGVtYSA6IG51bGwsXG4gICAgICAgICAgICBjYWxjdWxhdGVNZXRhZGF0YTogKF9hID0gY29tcFByb3BzLmNhbGN1bGF0ZU1ldGFkYXRhKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHVucmVnaXN0ZXJDb21wb3NpdGlvbihpZCk7XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICBkdXJhdGlvbkluRnJhbWVzLFxuICAgICAgICBmcHMsXG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgbGF6eSxcbiAgICAgICAgaWQsXG4gICAgICAgIGZvbGRlck5hbWUsXG4gICAgICAgIGRlZmF1bHRQcm9wcyxcbiAgICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgICB3aWR0aCxcbiAgICAgICAgbm9uY2UsXG4gICAgICAgIHBhcmVudE5hbWUsXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgY29tcFByb3BzLmNhbGN1bGF0ZU1ldGFkYXRhLFxuICAgIF0pO1xuICAgIGNvbnN0IHJlc29sdmVkID0gdXNlUmVzb2x2ZWRWaWRlb0NvbmZpZyhpZCk7XG4gICAgaWYgKGVudmlyb25tZW50LmlzU3R1ZGlvICYmIHZpZGVvICYmIHZpZGVvLmNvbXBvbmVudCA9PT0gbGF6eSkge1xuICAgICAgICBjb25zdCBDb21wID0gbGF6eTtcbiAgICAgICAgaWYgKHJlc29sdmVkID09PSBudWxsIHx8IHJlc29sdmVkLnR5cGUgIT09ICdzdWNjZXNzJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChqc3goQ2xpcENvbXBvc2l0aW9uLCB7IGNoaWxkcmVuOiBqc3goQ2FuVXNlUmVtb3Rpb25Ib29rc1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goU3VzcGVuc2UsIHsgZmFsbGJhY2s6IGpzeChMb2FkaW5nLCB7fSksIGNoaWxkcmVuOiBqc3goQ29tcCwgeyAuLi4oKF9hID0gcmVzb2x2ZWQucmVzdWx0LnByb3BzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB7fSkgfSkgfSkgfSkgfSksIHBvcnRhbE5vZGUoKSk7XG4gICAgfVxuICAgIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZyAmJiB2aWRlbyAmJiB2aWRlby5jb21wb25lbnQgPT09IGxhenkpIHtcbiAgICAgICAgY29uc3QgQ29tcCA9IGxhenk7XG4gICAgICAgIGlmIChyZXNvbHZlZCA9PT0gbnVsbCB8fCByZXNvbHZlZC50eXBlICE9PSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjcmVhdGVQb3J0YWwoanN4KENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KFN1c3BlbnNlLCB7IGZhbGxiYWNrOiBqc3goRmFsbGJhY2ssIHt9KSwgY2hpbGRyZW46IGpzeChDb21wLCB7IC4uLigoX2IgPSByZXNvbHZlZC5yZXN1bHQucHJvcHMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9KSB9KSB9KSB9KSwgcG9ydGFsTm9kZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59O1xuXG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvYmxvYi8wYjllYTYwYjRmZWU4Y2FjYzM2ZTcxNjBlMzFiOTFmYzExNGRiYzBkL0xpYnJhcmllcy9BbmltYXRlZC9zcmMvYmV6aWVyLmpzXG5jb25zdCBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG5jb25zdCBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG5jb25zdCBTVUJESVZJU0lPTl9QUkVDSVNJT04gPSAwLjAwMDAwMDE7XG5jb25zdCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuY29uc3Qga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuY29uc3Qga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuY29uc3QgZmxvYXQzMkFycmF5U3VwcG9ydGVkID0gdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJztcbmZ1bmN0aW9uIGEoYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMS4wIC0gMy4wICogYUEyICsgMy4wICogYUExO1xufVxuZnVuY3Rpb24gYihhQTEsIGFBMikge1xuICAgIHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7XG59XG5mdW5jdGlvbiBjKGFBMSkge1xuICAgIHJldHVybiAzLjAgKiBhQTE7XG59XG4vLyBSZXR1cm5zIHgodCkgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgeSh0KSBnaXZlbiB0LCB5MSwgYW5kIHkyLlxuZnVuY3Rpb24gY2FsY0JlemllcihhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gKChhKGFBMSwgYUEyKSAqIGFUICsgYihhQTEsIGFBMikpICogYVQgKyBjKGFBMSkpICogYVQ7XG59XG4vLyBSZXR1cm5zIGR4L2R0IGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIGR5L2R0IGdpdmVuIHQsIHkxLCBhbmQgeTIuXG5mdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICByZXR1cm4gMy4wICogYShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogYihhQTEsIGFBMikgKiBhVCArIGMoYUExKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVN1YmRpdmlkZSh7IGFYLCBfYUEsIF9hQiwgbVgxLCBtWDIsIH0pIHtcbiAgICBsZXQgY3VycmVudFg7XG4gICAgbGV0IGN1cnJlbnRUO1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgYUEgPSBfYUE7XG4gICAgbGV0IGFCID0gX2FCO1xuICAgIGRvIHtcbiAgICAgICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICAgICAgY3VycmVudFggPSBjYWxjQmV6aWVyKGN1cnJlbnRULCBtWDEsIG1YMikgLSBhWDtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJlxuICAgICAgICArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gICAgcmV0dXJuIGN1cnJlbnRUO1xufVxuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIF9hR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGxldCBhR3Vlc3NUID0gX2FHdWVzc1Q7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xufVxuZnVuY3Rpb24gYmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIGlmICghKG1YMSA+PSAwICYmIG1YMSA8PSAxICYmIG1YMiA+PSAwICYmIG1YMiA8PSAxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JlemllciB4IHZhbHVlcyBtdXN0IGJlIGluIFswLCAxXSByYW5nZScpO1xuICAgIH1cbiAgICAvLyBQcmVjb21wdXRlIHNhbXBsZXMgdGFibGVcbiAgICBjb25zdCBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWRcbiAgICAgICAgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpXG4gICAgICAgIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgICAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VEZvclgoYVgpIHtcbiAgICAgICAgbGV0IGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIGxldCBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgY29uc3QgbGFzdFNhbXBsZSA9IGtTcGxpbmVUYWJsZVNpemUgLSAxO1xuICAgICAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xuICAgICAgICAvLyBJbnRlcnBvbGF0ZSB0byBwcm92aWRlIGFuIGluaXRpYWwgZ3Vlc3MgZm9yIHRcbiAgICAgICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgL1xuICAgICAgICAgICAgKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICBjb25zdCBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gTkVXVE9OX01JTl9TTE9QRSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBndWVzc0ZvclQsIG1YMSwgbVgyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZSh7XG4gICAgICAgICAgICBhWCxcbiAgICAgICAgICAgIF9hQTogaW50ZXJ2YWxTdGFydCxcbiAgICAgICAgICAgIF9hQjogaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSxcbiAgICAgICAgICAgIG1YMSxcbiAgICAgICAgICAgIG1YMixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICAgICAgICAgIHJldHVybiB4OyAvLyBsaW5lYXJcbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNhdXNlIEphdmFTY3JpcHQgbnVtYmVyIGFyZSBpbXByZWNpc2UsIHdlIHNob3VsZCBndWFyYW50ZWUgdGhlIGV4dHJlbWVzIGFyZSByaWdodC5cbiAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh4ID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2FsY0JlemllcihnZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgIH07XG59XG5cbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9ibG9iLzBiOWVhNjBiNGZlZThjYWNjMzZlNzE2MGUzMWI5MWZjMTE0ZGJjMGQvTGlicmFyaWVzL0FuaW1hdGVkL3NyYy9FYXNpbmcuanNcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoZSBFYXNpbmcgbW9kdWxlIGltcGxlbWVudHMgY29tbW9uIGVhc2luZyBmdW5jdGlvbnMuIFlvdSBjYW4gdXNlIGl0IHdpdGggdGhlIGludGVycG9sYXRlKCkgQVBJLlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvZWFzaW5nKVxuICovXG5jbGFzcyBFYXNpbmcge1xuICAgIHN0YXRpYyBzdGVwMChuKSB7XG4gICAgICAgIHJldHVybiBuID4gMCA/IDEgOiAwO1xuICAgIH1cbiAgICBzdGF0aWMgc3RlcDEobikge1xuICAgICAgICByZXR1cm4gbiA+PSAxID8gMSA6IDA7XG4gICAgfVxuICAgIHN0YXRpYyBsaW5lYXIodCkge1xuICAgICAgICByZXR1cm4gdDtcbiAgICB9XG4gICAgc3RhdGljIGVhc2UodCkge1xuICAgICAgICByZXR1cm4gRWFzaW5nLmJlemllcigwLjQyLCAwLCAxLCAxKSh0KTtcbiAgICB9XG4gICAgc3RhdGljIHF1YWQodCkge1xuICAgICAgICByZXR1cm4gdCAqIHQ7XG4gICAgfVxuICAgIHN0YXRpYyBjdWJpYyh0KSB7XG4gICAgICAgIHJldHVybiB0ICogdCAqIHQ7XG4gICAgfVxuICAgIHN0YXRpYyBwb2x5KG4pIHtcbiAgICAgICAgcmV0dXJuICh0KSA9PiB0ICoqIG47XG4gICAgfVxuICAgIHN0YXRpYyBzaW4odCkge1xuICAgICAgICByZXR1cm4gMSAtIE1hdGguY29zKCh0ICogTWF0aC5QSSkgLyAyKTtcbiAgICB9XG4gICAgc3RhdGljIGNpcmNsZSh0KSB7XG4gICAgICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSB0ICogdCk7XG4gICAgfVxuICAgIHN0YXRpYyBleHAodCkge1xuICAgICAgICByZXR1cm4gMiAqKiAoMTAgKiAodCAtIDEpKTtcbiAgICB9XG4gICAgc3RhdGljIGVsYXN0aWMoYm91bmNpbmVzcyA9IDEpIHtcbiAgICAgICAgY29uc3QgcCA9IGJvdW5jaW5lc3MgKiBNYXRoLlBJO1xuICAgICAgICByZXR1cm4gKHQpID0+IDEgLSBNYXRoLmNvcygodCAqIE1hdGguUEkpIC8gMikgKiogMyAqIE1hdGguY29zKHQgKiBwKTtcbiAgICB9XG4gICAgc3RhdGljIGJhY2socyA9IDEuNzAxNTgpIHtcbiAgICAgICAgcmV0dXJuICh0KSA9PiB0ICogdCAqICgocyArIDEpICogdCAtIHMpO1xuICAgIH1cbiAgICBzdGF0aWMgYm91bmNlKHQpIHtcbiAgICAgICAgaWYgKHQgPCAxIC8gMi43NSkge1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQgKiB0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0IDwgMiAvIDIuNzUpIHtcbiAgICAgICAgICAgIGNvbnN0IHQyXyA9IHQgLSAxLjUgLyAyLjc1O1xuICAgICAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyXyAqIHQyXyArIDAuNzU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQgPCAyLjUgLyAyLjc1KSB7XG4gICAgICAgICAgICBjb25zdCB0Ml8gPSB0IC0gMi4yNSAvIDIuNzU7XG4gICAgICAgICAgICByZXR1cm4gNy41NjI1ICogdDJfICogdDJfICsgMC45Mzc1O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHQyID0gdCAtIDIuNjI1IC8gMi43NTtcbiAgICAgICAgcmV0dXJuIDcuNTYyNSAqIHQyICogdDIgKyAwLjk4NDM3NTtcbiAgICB9XG4gICAgc3RhdGljIGJlemllcih4MSwgeTEsIHgyLCB5Mikge1xuICAgICAgICByZXR1cm4gYmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgc3RhdGljIGluKGVhc2luZykge1xuICAgICAgICByZXR1cm4gZWFzaW5nO1xuICAgIH1cbiAgICBzdGF0aWMgb3V0KGVhc2luZykge1xuICAgICAgICByZXR1cm4gKHQpID0+IDEgLSBlYXNpbmcoMSAtIHQpO1xuICAgIH1cbiAgICBzdGF0aWMgaW5PdXQoZWFzaW5nKSB7XG4gICAgICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgICAgICAgaWYgKHQgPCAwLjUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWFzaW5nKHQgKiAyKSAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMSAtIGVhc2luZygoMSAtIHQpICogMikgLyAyO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2QgZnJlZXplcyBhbGwgb2YgaXRzIGNoaWxkcmVuIHRvIHRoZSBmcmFtZSB0aGF0IHlvdSBzcGVjaWZ5IGFzIGEgcHJvcFxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvZnJlZXplKVxuICovXG5jb25zdCBGcmVlemUgPSAoeyBmcmFtZSwgY2hpbGRyZW4gfSkgPT4ge1xuICAgIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVmlkZW9Db25maWcoKTtcbiAgICBpZiAodHlwZW9mIGZyYW1lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSA8RnJlZXplIC8+IGNvbXBvbmVudCByZXF1aXJlcyBhICdmcmFtZScgcHJvcCwgYnV0IG5vbmUgd2FzIHBhc3NlZC5gKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBmcmFtZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgJ2ZyYW1lJyBwcm9wIG9mIDxGcmVlemUgLz4gbXVzdCBiZSBhIG51bWJlciwgYnV0IGlzIG9mIHR5cGUgJHt0eXBlb2YgZnJhbWV9YCk7XG4gICAgfVxuICAgIGlmIChOdW1iZXIuaXNOYU4oZnJhbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdmcmFtZScgcHJvcCBvZiA8RnJlZXplIC8+IG11c3QgYmUgYSByZWFsIG51bWJlciwgYnV0IGl0IGlzIE5hTi5gKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZnJhbWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlICdmcmFtZScgcHJvcCBvZiA8RnJlZXplIC8+IG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyLCBidXQgaXQgaXMgJHtmcmFtZX0uYCk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB1c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwbGF5aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGltcGVyYXRpdmVQbGF5aW5nOiB7XG4gICAgICAgICAgICAgICAgY3VycmVudDogZmFsc2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJhbWU6IHtcbiAgICAgICAgICAgICAgICBbdmlkZW9Db25maWcuaWRdOiBmcmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW2NvbnRleHQsIGZyYW1lLCB2aWRlb0NvbmZpZy5pZF0pO1xuICAgIHJldHVybiAoanN4KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdmFsdWUsIGNoaWxkcmVuOiBqc3goU2VxdWVuY2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBudWxsLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufTtcblxubGV0IHdhcm5lZFNlcnZlciA9IGZhbHNlO1xubGV0IHdhcm5lZFBsYXllciA9IGZhbHNlO1xuY29uc3Qgd2FyblNlcnZlck9uY2UgPSAoKSA9PiB7XG4gICAgaWYgKHdhcm5lZFNlcnZlcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5lZFNlcnZlciA9IHRydWU7XG4gICAgY29uc29sZS53YXJuKCdDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSBvbiB0aGUgc2VydmVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyLiBBbiBlbXB0eSBhcnJheSB3YXMgcmV0dXJuZWQuJyk7XG59O1xuY29uc3Qgd2FyblBsYXllck9uY2UgPSAoKSA9PiB7XG4gICAgaWYgKHdhcm5lZFBsYXllcikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5lZFBsYXllciA9IHRydWU7XG4gICAgY29uc29sZS53YXJuKCdDYWxsZWQgZ2V0U3RhdGljRmlsZXMoKSB3aGlsZSB1c2luZyB0aGUgUmVtb3Rpb24gUGxheWVyLiBUaGUgQVBJIGlzIG9ubHkgYXZhaWxhYmxlIHdoaWxlIHVzaW5nIHRoZSBSZW1vdGlvbiBTdHVkaW8uIEFuIGVtcHR5IGFycmF5IHdhcyByZXR1cm5lZC4nKTtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGUgZnVuY3Rpb24gYXJyYXkgY29udGFpbmluZyBhbGwgZmlsZXMgaW4gdGhlIHB1YmxpYy8gZm9sZGVyLiBZb3UgY2FuIHJlZmVyZW5jZSB0aGVtIGJ5IHVzaW5nIHN0YXRpY0ZpbGUoKS5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2dldHN0YXRpY2ZpbGVzKVxuICovXG5jb25zdCBnZXRTdGF0aWNGaWxlcyA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB3YXJuU2VydmVyT25jZSgpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICh3aW5kb3cucmVtb3Rpb25faXNQbGF5ZXIpIHtcbiAgICAgICAgd2FyblBsYXllck9uY2UoKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LnJlbW90aW9uX3N0YXRpY0ZpbGVzO1xufTtcblxuY29uc3QgSUZyYW1lUmVmRm9yd2FyZGluZyA9ICh7IG9uTG9hZCwgb25FcnJvciwgLi4ucHJvcHMgfSwgcmVmKSA9PiB7XG4gICAgY29uc3QgW2hhbmRsZV0gPSB1c2VTdGF0ZSgoKSA9PiBkZWxheVJlbmRlcihgTG9hZGluZyA8SUZyYW1lPiB3aXRoIHNvdXJjZSAke3Byb3BzLnNyY31gKSk7XG4gICAgY29uc3QgZGlkTG9hZCA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgIG9uTG9hZCA9PT0gbnVsbCB8fCBvbkxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uTG9hZChlKTtcbiAgICB9LCBbaGFuZGxlLCBvbkxvYWRdKTtcbiAgICBjb25zdCBkaWRHZXRFcnJvciA9IHVzZUNhbGxiYWNrKChlKSA9PiB7XG4gICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBpZnJhbWU6JywgZSwgJ0hhbmRsZSB0aGUgZXZlbnQgdXNpbmcgdGhlIG9uRXJyb3IoKSBwcm9wIHRvIG1ha2UgdGhpcyBtZXNzYWdlIGRpc2FwcGVhci4nKTtcbiAgICAgICAgfVxuICAgIH0sIFtoYW5kbGUsIG9uRXJyb3JdKTtcbiAgICByZXR1cm4ganN4KFwiaWZyYW1lXCIsIHsgLi4ucHJvcHMsIHJlZjogcmVmLCBvbkVycm9yOiBkaWRHZXRFcnJvciwgb25Mb2FkOiBkaWRMb2FkIH0pO1xufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoZSA8SUZyYW1lIC8+IGNhbiBiZSB1c2VkIGxpa2UgYSByZWd1bGFyIDxpZnJhbWU+IEhUTUwgdGFnLlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvaWZyYW1lKVxuICovXG5jb25zdCBJRnJhbWUgPSBmb3J3YXJkUmVmKElGcmFtZVJlZkZvcndhcmRpbmcpO1xuXG5mdW5jdGlvbiBleHBvbmVudGlhbEJhY2tvZmYoZXJyb3JDb3VudCkge1xuICAgIHJldHVybiAxMDAwICogMiAqKiAoZXJyb3JDb3VudCAtIDEpO1xufVxuY29uc3QgSW1nUmVmRm9yd2FyZGluZyA9ICh7IG9uRXJyb3IsIG1heFJldHJpZXMgPSAyLCBzcmMsIC4uLnByb3BzIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IGltYWdlUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGVycm9ycyA9IHVzZVJlZih7fSk7XG4gICAgaWYgKCFzcmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBcInNyY1wiIHByb3Agd2FzIHBhc3NlZCB0byA8SW1nPi4nKTtcbiAgICB9XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGltYWdlUmVmLmN1cnJlbnQ7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGFjdHVhbFNyYyA9IHVzZVByZWxvYWQoc3JjKTtcbiAgICBjb25zdCByZXRyeUluID0gdXNlQ2FsbGJhY2soKHRpbWVvdXQpID0+IHtcbiAgICAgICAgaWYgKCFpbWFnZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFNyYyA9IGltYWdlUmVmLmN1cnJlbnQuc3JjO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICghaW1hZ2VSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIC8vIENvbXBvbmVudCBoYXMgYmVlbiB1bm1vdW50ZWQsIGRvIG5vdCByZXRyeVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld1NyYyA9IChfYSA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcmM7XG4gICAgICAgICAgICBpZiAobmV3U3JjICE9PSBjdXJyZW50U3JjKSB7XG4gICAgICAgICAgICAgICAgLy8gc3JjIGhhcyBjaGFuZ2VkLCBkbyBub3QgcmV0cnlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbWFnZVJlZi5jdXJyZW50LnJlbW92ZUF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICBpbWFnZVJlZi5jdXJyZW50LnNldEF0dHJpYnV0ZSgnc3JjJywgbmV3U3JjKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGRpZEdldEVycm9yID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbDtcbiAgICAgICAgaWYgKCFlcnJvcnMuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVycm9ycy5jdXJyZW50WyhfYSA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcmNdID1cbiAgICAgICAgICAgICgoX2MgPSBlcnJvcnMuY3VycmVudFsoX2IgPSBpbWFnZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3JjXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMCkgKyAxO1xuICAgICAgICBpZiAob25FcnJvciAmJlxuICAgICAgICAgICAgKChfZSA9IGVycm9ycy5jdXJyZW50WyhfZCA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zcmNdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAwKSA+IG1heFJldHJpZXMpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2cgPSBlcnJvcnMuY3VycmVudFsoX2YgPSBpbWFnZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yuc3JjXSkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDogMCkgPD0gbWF4UmV0cmllcykge1xuICAgICAgICAgICAgY29uc3QgYmFja29mZiA9IGV4cG9uZW50aWFsQmFja29mZigoX2ogPSBlcnJvcnMuY3VycmVudFsoX2ggPSBpbWFnZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2guc3JjXSkgIT09IG51bGwgJiYgX2ogIT09IHZvaWQgMCA/IF9qIDogMCk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBsb2FkIGltYWdlIHdpdGggc291cmNlICR7KF9rID0gaW1hZ2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9rLnNyY30sIHJldHJ5aW5nIGFnYWluIGluICR7YmFja29mZn1tc2ApO1xuICAgICAgICAgICAgcmV0cnlJbihiYWNrb2ZmKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxSZW5kZXIoJ0Vycm9yIGxvYWRpbmcgaW1hZ2Ugd2l0aCBzcmM6ICcgKyAoKF9sID0gaW1hZ2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2wgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9sLnNyYykpO1xuICAgIH0sIFttYXhSZXRyaWVzLCBvbkVycm9yLCByZXRyeUluXSk7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rc1xuICAgICAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdIYW5kbGUgPSBkZWxheVJlbmRlcignTG9hZGluZyA8SW1nPiB3aXRoIHNyYz0nICsgYWN0dWFsU3JjKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gaW1hZ2VSZWY7XG4gICAgICAgICAgICBjb25zdCBvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IGVycm9ycy5jdXJyZW50WyhfYSA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcmNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGVycm9ycy5jdXJyZW50WyhfYyA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zcmNdO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmluZm8oYFJldHJ5IHN1Y2Nlc3NmdWwgLSAkeyhfZCA9IGltYWdlUmVmLmN1cnJlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5zcmN9IGlzIG5vdyBsb2FkZWRgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBkaWRMb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkaWRMb2FkLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0YWcgZ2V0cyB1bm1vdW50ZWQsIGNsZWFyIHBlbmRpbmcgaGFuZGxlcyBiZWNhdXNlIGltYWdlIGlzIG5vdCBnb2luZyB0byBsb2FkXG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgZGlkTG9hZCk7XG4gICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFthY3R1YWxTcmNdKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJpbWdcIiwgeyAuLi5wcm9wcywgcmVmOiBpbWFnZVJlZiwgc3JjOiBhY3R1YWxTcmMsIG9uRXJyb3I6IGRpZEdldEVycm9yIH0pKTtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBXb3JrcyBqdXN0IGxpa2UgYSByZWd1bGFyIEhUTUwgaW1nIHRhZy4gV2hlbiB5b3UgdXNlIHRoZSA8SW1nPiB0YWcsIFJlbW90aW9uIHdpbGwgZW5zdXJlIHRoYXQgdGhlIGltYWdlIGlzIGxvYWRlZCBiZWZvcmUgcmVuZGVyaW5nIHRoZSBmcmFtZS5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL2ltZylcbiAqL1xuY29uc3QgSW1nID0gZm9yd2FyZFJlZihJbWdSZWZGb3J3YXJkaW5nKTtcblxuY29uc3QgY29tcG9zaXRpb25zUmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG5jb25zdCBDb21wb3NpdGlvbk1hbmFnZXJQcm92aWRlciA9ICh7IGNoaWxkcmVuLCBudW1iZXJPZkF1ZGlvVGFncyB9KSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFdvbnRmaXgsIGV4cGVjdGVkIHRvIGhhdmVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IFtjb21wb3NpdGlvbnMsIHNldENvbXBvc2l0aW9uc10gPSB1c2VTdGF0ZShbXSk7XG4gICAgY29uc3QgY3VycmVudGNvbXBvc2l0aW9uc1JlZiA9IHVzZVJlZihjb21wb3NpdGlvbnMpO1xuICAgIGNvbnN0IFtmb2xkZXJzLCBzZXRGb2xkZXJzXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCBbY2FudmFzQ29udGVudCwgc2V0Q2FudmFzQ29udGVudF0gPSB1c2VTdGF0ZShudWxsKTtcbiAgICBjb25zdCBbY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsIHNldEN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHVwZGF0ZUNvbXBvc2l0aW9ucyA9IHVzZUNhbGxiYWNrKChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIHVwZGF0ZUNvbXBzKSA9PiB7XG4gICAgICAgIHNldENvbXBvc2l0aW9ucygoY29tcHMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWQgPSB1cGRhdGVDb21wcyhjb21wcyk7XG4gICAgICAgICAgICBjdXJyZW50Y29tcG9zaXRpb25zUmVmLmN1cnJlbnQgPSB1cGRhdGVkO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCByZWdpc3RlckNvbXBvc2l0aW9uID0gdXNlQ2FsbGJhY2soKGNvbXApID0+IHtcbiAgICAgICAgdXBkYXRlQ29tcG9zaXRpb25zKChjb21wcykgPT4ge1xuICAgICAgICAgICAgaWYgKGNvbXBzLmZpbmQoKGMpID0+IGMuaWQgPT09IGNvbXAuaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNdWx0aXBsZSBjb21wb3NpdGlvbiB3aXRoIGlkICR7Y29tcC5pZH0gYXJlIHJlZ2lzdGVyZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IFsuLi5jb21wcywgY29tcF1cbiAgICAgICAgICAgICAgICAuc2xpY2UoKVxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEubm9uY2UgLSBiLm5vbmNlKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfSwgW3VwZGF0ZUNvbXBvc2l0aW9uc10pO1xuICAgIGNvbnN0IHVucmVnaXN0ZXJDb21wb3NpdGlvbiA9IHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICBzZXRDb21wb3NpdGlvbnMoKGNvbXBzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gY29tcHMuZmlsdGVyKChjKSA9PiBjLmlkICE9PSBpZCk7XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCByZWdpc3RlckZvbGRlciA9IHVzZUNhbGxiYWNrKChuYW1lLCBwYXJlbnQpID0+IHtcbiAgICAgICAgc2V0Rm9sZGVycygocHJldkZvbGRlcnMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgLi4ucHJldkZvbGRlcnMsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCB1bnJlZ2lzdGVyRm9sZGVyID0gdXNlQ2FsbGJhY2soKG5hbWUsIHBhcmVudCkgPT4ge1xuICAgICAgICBzZXRGb2xkZXJzKChwcmV2Rm9sZGVycykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZGb2xkZXJzLmZpbHRlcigocCkgPT4gIShwLm5hbWUgPT09IG5hbWUgJiYgcC5wYXJlbnQgPT09IHBhcmVudCkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShjb21wb3NpdGlvbnNSZWYsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldENvbXBvc2l0aW9uczogKCkgPT4gY3VycmVudGNvbXBvc2l0aW9uc1JlZi5jdXJyZW50LFxuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBjb21wb3NpdGlvbiA9IGNvbXBvc2l0aW9ucy5maW5kKChjKSA9PiAoY2FudmFzQ29udGVudCA9PT0gbnVsbCB8fCBjYW52YXNDb250ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYW52YXNDb250ZW50LnR5cGUpID09PSAnY29tcG9zaXRpb24nXG4gICAgICAgID8gYy5pZCA9PT0gY2FudmFzQ29udGVudC5jb21wb3NpdGlvbklkXG4gICAgICAgIDogbnVsbCk7XG4gICAgY29uc3QgY29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb21wb3NpdGlvbnMsXG4gICAgICAgICAgICByZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgICAgICAgZm9sZGVycyxcbiAgICAgICAgICAgIHJlZ2lzdGVyRm9sZGVyLFxuICAgICAgICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgICAgICAgIGN1cnJlbnRDb21wb3NpdGlvbk1ldGFkYXRhLFxuICAgICAgICAgICAgc2V0Q3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgICBjYW52YXNDb250ZW50LFxuICAgICAgICAgICAgc2V0Q2FudmFzQ29udGVudCxcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGNvbXBvc2l0aW9ucyxcbiAgICAgICAgcmVnaXN0ZXJDb21wb3NpdGlvbixcbiAgICAgICAgdW5yZWdpc3RlckNvbXBvc2l0aW9uLFxuICAgICAgICBmb2xkZXJzLFxuICAgICAgICByZWdpc3RlckZvbGRlcixcbiAgICAgICAgdW5yZWdpc3RlckZvbGRlcixcbiAgICAgICAgY3VycmVudENvbXBvc2l0aW9uTWV0YWRhdGEsXG4gICAgICAgIGNhbnZhc0NvbnRlbnQsXG4gICAgICAgIHNldENhbnZhc0NvbnRlbnQsXG4gICAgXSk7XG4gICAgcmV0dXJuIChqc3goQ29tcG9zaXRpb25NYW5hZ2VyLlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBqc3goU2VxdWVuY2VNYW5hZ2VyUHJvdmlkZXIsIHsgY2hpbGRyZW46IGpzeChSZW5kZXJBc3NldE1hbmFnZXJQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KFJlc29sdmVDb21wb3NpdGlvbkNvbmZpZywgeyBjaGlsZHJlbjoganN4KFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyLCB7IG51bWJlck9mQXVkaW9UYWdzOiBudW1iZXJPZkF1ZGlvVGFncywgY29tcG9uZW50OiAoX2EgPSBjb21wb3NpdGlvbiA9PT0gbnVsbCB8fCBjb21wb3NpdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tcG9zaXRpb24uY29tcG9uZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBudWxsLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkgfSkgfSkpO1xufTtcblxuY29uc3QgaW5qZWN0ZWQgPSB7fTtcbmNvbnN0IGluamVjdENTUyA9IChjc3MpID0+IHtcbiAgICAvLyBTa2lwIGluIG5vZGVcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpbmplY3RlZFtjc3NdKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgc3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gICAgaGVhZC5wcmVwZW5kKHN0eWxlKTtcbiAgICBpbmplY3RlZFtjc3NdID0gdHJ1ZTtcbn07XG5jb25zdCBPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSA9ICdfX3JlbW90aW9uX29mZnRocmVhZHZpZGVvJztcbmNvbnN0IG1ha2VEZWZhdWx0Q1NTID0gKHNjb3BlLCBiYWNrZ3JvdW5kQ29sb3IpID0+IHtcbiAgICBpZiAoIXNjb3BlKSB7XG4gICAgICAgIHJldHVybiBgXG4gICAgKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICBib2R5IHtcbiAgICAgIG1hcmdpbjogMDtcblx0ICAgIGJhY2tncm91bmQtY29sb3I6ICR7YmFja2dyb3VuZENvbG9yfTtcbiAgICB9XG4gICAgLiR7T0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUV9IHtcbiAgICAgIG9iamVjdC1maXQ6IGNvbnRhaW47XG4gICAgfVxuICAgIGA7XG4gICAgfVxuICAgIHJldHVybiBgXG4gICAgJHtzY29wZX0gKiB7XG4gICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgIH1cbiAgICAke3Njb3BlfSAqOi13ZWJraXQtZnVsbC1zY3JlZW4ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgfVxuICAgICR7c2NvcGV9IC4ke09GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FfSB7XG4gICAgICBvYmplY3QtZml0OiBjb250YWluO1xuICAgIH1cbiAgYDtcbn07XG5cbnZhciBDU1NVdGlscyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgaW5qZWN0Q1NTOiBpbmplY3RDU1MsXG4gICAgT0ZGVEhSRUFEX1ZJREVPX0NMQVNTX05BTUU6IE9GRlRIUkVBRF9WSURFT19DTEFTU19OQU1FLFxuICAgIG1ha2VEZWZhdWx0Q1NTOiBtYWtlRGVmYXVsdENTU1xufSk7XG5cbmNvbnN0IFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCA9ICdfX3JlbW90aW9uLXN0dWRpby1jb250YWluZXInO1xuY29uc3QgZ2V0UHJldmlld0RvbUVsZW1lbnQgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCk7XG59O1xuXG4vKipcbiAqIENvcGllZCBmcm9tOlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvZnR3YXJlLW1hbnNpb24vcmVhY3QtbmF0aXZlLXJlYW5pbWF0ZWQvYmxvYi9tYXN0ZXIvc3JjL3JlYW5pbWF0ZWQyL0NvbG9ycy50c1xuICovXG4vLyB2YXIgSU5URUdFUiA9ICdbLStdP1xcXFxkKyc7XG5jb25zdCBOVU1CRVIgPSAnWy0rXT9cXFxcZCpcXFxcLj9cXFxcZCsnO1xuY29uc3QgUEVSQ0VOVEFHRSA9IE5VTUJFUiArICclJztcbmZ1bmN0aW9uIGNhbGwoLi4uYXJncykge1xuICAgIHJldHVybiAnXFxcXChcXFxccyooJyArIGFyZ3Muam9pbignKVxcXFxzKixcXFxccyooJykgKyAnKVxcXFxzKlxcXFwpJztcbn1cbmZ1bmN0aW9uIGdldE1hdGNoZXJzKCkge1xuICAgIGNvbnN0IGNhY2hlZE1hdGNoZXJzID0ge1xuICAgICAgICByZ2I6IHVuZGVmaW5lZCxcbiAgICAgICAgcmdiYTogdW5kZWZpbmVkLFxuICAgICAgICBoc2w6IHVuZGVmaW5lZCxcbiAgICAgICAgaHNsYTogdW5kZWZpbmVkLFxuICAgICAgICBoZXgzOiB1bmRlZmluZWQsXG4gICAgICAgIGhleDQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaGV4NTogdW5kZWZpbmVkLFxuICAgICAgICBoZXg2OiB1bmRlZmluZWQsXG4gICAgICAgIGhleDg6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChjYWNoZWRNYXRjaGVycy5yZ2IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWNoZWRNYXRjaGVycy5yZ2IgPSBuZXcgUmVnRXhwKCdyZ2InICsgY2FsbChOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgICAgIGNhY2hlZE1hdGNoZXJzLnJnYmEgPSBuZXcgUmVnRXhwKCdyZ2JhJyArIGNhbGwoTlVNQkVSLCBOVU1CRVIsIE5VTUJFUiwgTlVNQkVSKSk7XG4gICAgICAgIGNhY2hlZE1hdGNoZXJzLmhzbCA9IG5ldyBSZWdFeHAoJ2hzbCcgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSkpO1xuICAgICAgICBjYWNoZWRNYXRjaGVycy5oc2xhID0gbmV3IFJlZ0V4cCgnaHNsYScgKyBjYWxsKE5VTUJFUiwgUEVSQ0VOVEFHRSwgUEVSQ0VOVEFHRSwgTlVNQkVSKSk7XG4gICAgICAgIGNhY2hlZE1hdGNoZXJzLmhleDMgPSAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkkLztcbiAgICAgICAgY2FjaGVkTWF0Y2hlcnMuaGV4NCA9XG4gICAgICAgICAgICAvXiMoWzAtOWEtZkEtRl17MX0pKFswLTlhLWZBLUZdezF9KShbMC05YS1mQS1GXXsxfSkoWzAtOWEtZkEtRl17MX0pJC87XG4gICAgICAgIGNhY2hlZE1hdGNoZXJzLmhleDYgPSAvXiMoWzAtOWEtZkEtRl17Nn0pJC87XG4gICAgICAgIGNhY2hlZE1hdGNoZXJzLmhleDggPSAvXiMoWzAtOWEtZkEtRl17OH0pJC87XG4gICAgfVxuICAgIHJldHVybiBjYWNoZWRNYXRjaGVycztcbn1cbmZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMCkge1xuICAgICAgICB0ICs9IDE7XG4gICAgfVxuICAgIGlmICh0ID4gMSkge1xuICAgICAgICB0IC09IDE7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDYpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgfVxuICAgIGlmICh0IDwgMSAvIDIpIHtcbiAgICAgICAgcmV0dXJuIHE7XG4gICAgfVxuICAgIGlmICh0IDwgMiAvIDMpIHtcbiAgICAgICAgcmV0dXJuIHAgKyAocSAtIHApICogKDIgLyAzIC0gdCkgKiA2O1xuICAgIH1cbiAgICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbFRvUmdiKGgsIHMsIGwpIHtcbiAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuICAgIGNvbnN0IHIgPSBodWUycmdiKHAsIHEsIGggKyAxIC8gMyk7XG4gICAgY29uc3QgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgY29uc3QgYiA9IGh1ZTJyZ2IocCwgcSwgaCAtIDEgLyAzKTtcbiAgICByZXR1cm4gKChNYXRoLnJvdW5kKHIgKiAyNTUpIDw8IDI0KSB8XG4gICAgICAgIChNYXRoLnJvdW5kKGcgKiAyNTUpIDw8IDE2KSB8XG4gICAgICAgIChNYXRoLnJvdW5kKGIgKiAyNTUpIDw8IDgpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlMjU1KHN0cikge1xuICAgIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUludChzdHIsIDEwKTtcbiAgICBpZiAoaW50IDwgMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGludCA+IDI1NSkge1xuICAgICAgICByZXR1cm4gMjU1O1xuICAgIH1cbiAgICByZXR1cm4gaW50O1xufVxuZnVuY3Rpb24gcGFyc2UzNjAoc3RyKSB7XG4gICAgY29uc3QgaW50ID0gTnVtYmVyLnBhcnNlRmxvYXQoc3RyKTtcbiAgICByZXR1cm4gKCgoaW50ICUgMzYwKSArIDM2MCkgJSAzNjApIC8gMzYwO1xufVxuZnVuY3Rpb24gcGFyc2UxKHN0cikge1xuICAgIGNvbnN0IG51bSA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gICAgaWYgKG51bSA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChudW0gPiAxKSB7XG4gICAgICAgIHJldHVybiAyNTU7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIDI1NSk7XG59XG5mdW5jdGlvbiBwYXJzZVBlcmNlbnRhZ2Uoc3RyKSB7XG4gICAgLy8gcGFyc2VGbG9hdCBjb252ZW5pZW50bHkgaWdub3JlcyB0aGUgZmluYWwgJVxuICAgIGNvbnN0IGludCA9IE51bWJlci5wYXJzZUZsb2F0KHN0cik7XG4gICAgaWYgKGludCA8IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChpbnQgPiAxMDApIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBpbnQgLyAxMDA7XG59XG5jb25zdCBuYW1lcyA9IHtcbiAgICB0cmFuc3BhcmVudDogMHgwMDAwMDAwMCxcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWNvbG9yLyNzdmctY29sb3JcbiAgICBhbGljZWJsdWU6IDB4ZjBmOGZmZmYsXG4gICAgYW50aXF1ZXdoaXRlOiAweGZhZWJkN2ZmLFxuICAgIGFxdWE6IDB4MDBmZmZmZmYsXG4gICAgYXF1YW1hcmluZTogMHg3ZmZmZDRmZixcbiAgICBhenVyZTogMHhmMGZmZmZmZixcbiAgICBiZWlnZTogMHhmNWY1ZGNmZixcbiAgICBiaXNxdWU6IDB4ZmZlNGM0ZmYsXG4gICAgYmxhY2s6IDB4MDAwMDAwZmYsXG4gICAgYmxhbmNoZWRhbG1vbmQ6IDB4ZmZlYmNkZmYsXG4gICAgYmx1ZTogMHgwMDAwZmZmZixcbiAgICBibHVldmlvbGV0OiAweDhhMmJlMmZmLFxuICAgIGJyb3duOiAweGE1MmEyYWZmLFxuICAgIGJ1cmx5d29vZDogMHhkZWI4ODdmZixcbiAgICBidXJudHNpZW5uYTogMHhlYTdlNWRmZixcbiAgICBjYWRldGJsdWU6IDB4NWY5ZWEwZmYsXG4gICAgY2hhcnRyZXVzZTogMHg3ZmZmMDBmZixcbiAgICBjaG9jb2xhdGU6IDB4ZDI2OTFlZmYsXG4gICAgY29yYWw6IDB4ZmY3ZjUwZmYsXG4gICAgY29ybmZsb3dlcmJsdWU6IDB4NjQ5NWVkZmYsXG4gICAgY29ybnNpbGs6IDB4ZmZmOGRjZmYsXG4gICAgY3JpbXNvbjogMHhkYzE0M2NmZixcbiAgICBjeWFuOiAweDAwZmZmZmZmLFxuICAgIGRhcmtibHVlOiAweDAwMDA4YmZmLFxuICAgIGRhcmtjeWFuOiAweDAwOGI4YmZmLFxuICAgIGRhcmtnb2xkZW5yb2Q6IDB4Yjg4NjBiZmYsXG4gICAgZGFya2dyYXk6IDB4YTlhOWE5ZmYsXG4gICAgZGFya2dyZWVuOiAweDAwNjQwMGZmLFxuICAgIGRhcmtncmV5OiAweGE5YTlhOWZmLFxuICAgIGRhcmtraGFraTogMHhiZGI3NmJmZixcbiAgICBkYXJrbWFnZW50YTogMHg4YjAwOGJmZixcbiAgICBkYXJrb2xpdmVncmVlbjogMHg1NTZiMmZmZixcbiAgICBkYXJrb3JhbmdlOiAweGZmOGMwMGZmLFxuICAgIGRhcmtvcmNoaWQ6IDB4OTkzMmNjZmYsXG4gICAgZGFya3JlZDogMHg4YjAwMDBmZixcbiAgICBkYXJrc2FsbW9uOiAweGU5OTY3YWZmLFxuICAgIGRhcmtzZWFncmVlbjogMHg4ZmJjOGZmZixcbiAgICBkYXJrc2xhdGVibHVlOiAweDQ4M2Q4YmZmLFxuICAgIGRhcmtzbGF0ZWdyYXk6IDB4MmY0ZjRmZmYsXG4gICAgZGFya3NsYXRlZ3JleTogMHgyZjRmNGZmZixcbiAgICBkYXJrdHVycXVvaXNlOiAweDAwY2VkMWZmLFxuICAgIGRhcmt2aW9sZXQ6IDB4OTQwMGQzZmYsXG4gICAgZGVlcHBpbms6IDB4ZmYxNDkzZmYsXG4gICAgZGVlcHNreWJsdWU6IDB4MDBiZmZmZmYsXG4gICAgZGltZ3JheTogMHg2OTY5NjlmZixcbiAgICBkaW1ncmV5OiAweDY5Njk2OWZmLFxuICAgIGRvZGdlcmJsdWU6IDB4MWU5MGZmZmYsXG4gICAgZmlyZWJyaWNrOiAweGIyMjIyMmZmLFxuICAgIGZsb3JhbHdoaXRlOiAweGZmZmFmMGZmLFxuICAgIGZvcmVzdGdyZWVuOiAweDIyOGIyMmZmLFxuICAgIGZ1Y2hzaWE6IDB4ZmYwMGZmZmYsXG4gICAgZ2FpbnNib3JvOiAweGRjZGNkY2ZmLFxuICAgIGdob3N0d2hpdGU6IDB4ZjhmOGZmZmYsXG4gICAgZ29sZDogMHhmZmQ3MDBmZixcbiAgICBnb2xkZW5yb2Q6IDB4ZGFhNTIwZmYsXG4gICAgZ3JheTogMHg4MDgwODBmZixcbiAgICBncmVlbjogMHgwMDgwMDBmZixcbiAgICBncmVlbnllbGxvdzogMHhhZGZmMmZmZixcbiAgICBncmV5OiAweDgwODA4MGZmLFxuICAgIGhvbmV5ZGV3OiAweGYwZmZmMGZmLFxuICAgIGhvdHBpbms6IDB4ZmY2OWI0ZmYsXG4gICAgaW5kaWFucmVkOiAweGNkNWM1Y2ZmLFxuICAgIGluZGlnbzogMHg0YjAwODJmZixcbiAgICBpdm9yeTogMHhmZmZmZjBmZixcbiAgICBraGFraTogMHhmMGU2OGNmZixcbiAgICBsYXZlbmRlcjogMHhlNmU2ZmFmZixcbiAgICBsYXZlbmRlcmJsdXNoOiAweGZmZjBmNWZmLFxuICAgIGxhd25ncmVlbjogMHg3Y2ZjMDBmZixcbiAgICBsZW1vbmNoaWZmb246IDB4ZmZmYWNkZmYsXG4gICAgbGlnaHRibHVlOiAweGFkZDhlNmZmLFxuICAgIGxpZ2h0Y29yYWw6IDB4ZjA4MDgwZmYsXG4gICAgbGlnaHRjeWFuOiAweGUwZmZmZmZmLFxuICAgIGxpZ2h0Z29sZGVucm9keWVsbG93OiAweGZhZmFkMmZmLFxuICAgIGxpZ2h0Z3JheTogMHhkM2QzZDNmZixcbiAgICBsaWdodGdyZWVuOiAweDkwZWU5MGZmLFxuICAgIGxpZ2h0Z3JleTogMHhkM2QzZDNmZixcbiAgICBsaWdodHBpbms6IDB4ZmZiNmMxZmYsXG4gICAgbGlnaHRzYWxtb246IDB4ZmZhMDdhZmYsXG4gICAgbGlnaHRzZWFncmVlbjogMHgyMGIyYWFmZixcbiAgICBsaWdodHNreWJsdWU6IDB4ODdjZWZhZmYsXG4gICAgbGlnaHRzbGF0ZWdyYXk6IDB4Nzc4ODk5ZmYsXG4gICAgbGlnaHRzbGF0ZWdyZXk6IDB4Nzc4ODk5ZmYsXG4gICAgbGlnaHRzdGVlbGJsdWU6IDB4YjBjNGRlZmYsXG4gICAgbGlnaHR5ZWxsb3c6IDB4ZmZmZmUwZmYsXG4gICAgbGltZTogMHgwMGZmMDBmZixcbiAgICBsaW1lZ3JlZW46IDB4MzJjZDMyZmYsXG4gICAgbGluZW46IDB4ZmFmMGU2ZmYsXG4gICAgbWFnZW50YTogMHhmZjAwZmZmZixcbiAgICBtYXJvb246IDB4ODAwMDAwZmYsXG4gICAgbWVkaXVtYXF1YW1hcmluZTogMHg2NmNkYWFmZixcbiAgICBtZWRpdW1ibHVlOiAweDAwMDBjZGZmLFxuICAgIG1lZGl1bW9yY2hpZDogMHhiYTU1ZDNmZixcbiAgICBtZWRpdW1wdXJwbGU6IDB4OTM3MGRiZmYsXG4gICAgbWVkaXVtc2VhZ3JlZW46IDB4M2NiMzcxZmYsXG4gICAgbWVkaXVtc2xhdGVibHVlOiAweDdiNjhlZWZmLFxuICAgIG1lZGl1bXNwcmluZ2dyZWVuOiAweDAwZmE5YWZmLFxuICAgIG1lZGl1bXR1cnF1b2lzZTogMHg0OGQxY2NmZixcbiAgICBtZWRpdW12aW9sZXRyZWQ6IDB4YzcxNTg1ZmYsXG4gICAgbWlkbmlnaHRibHVlOiAweDE5MTk3MGZmLFxuICAgIG1pbnRjcmVhbTogMHhmNWZmZmFmZixcbiAgICBtaXN0eXJvc2U6IDB4ZmZlNGUxZmYsXG4gICAgbW9jY2FzaW46IDB4ZmZlNGI1ZmYsXG4gICAgbmF2YWpvd2hpdGU6IDB4ZmZkZWFkZmYsXG4gICAgbmF2eTogMHgwMDAwODBmZixcbiAgICBvbGRsYWNlOiAweGZkZjVlNmZmLFxuICAgIG9saXZlOiAweDgwODAwMGZmLFxuICAgIG9saXZlZHJhYjogMHg2YjhlMjNmZixcbiAgICBvcmFuZ2U6IDB4ZmZhNTAwZmYsXG4gICAgb3JhbmdlcmVkOiAweGZmNDUwMGZmLFxuICAgIG9yY2hpZDogMHhkYTcwZDZmZixcbiAgICBwYWxlZ29sZGVucm9kOiAweGVlZThhYWZmLFxuICAgIHBhbGVncmVlbjogMHg5OGZiOThmZixcbiAgICBwYWxldHVycXVvaXNlOiAweGFmZWVlZWZmLFxuICAgIHBhbGV2aW9sZXRyZWQ6IDB4ZGI3MDkzZmYsXG4gICAgcGFwYXlhd2hpcDogMHhmZmVmZDVmZixcbiAgICBwZWFjaHB1ZmY6IDB4ZmZkYWI5ZmYsXG4gICAgcGVydTogMHhjZDg1M2ZmZixcbiAgICBwaW5rOiAweGZmYzBjYmZmLFxuICAgIHBsdW06IDB4ZGRhMGRkZmYsXG4gICAgcG93ZGVyYmx1ZTogMHhiMGUwZTZmZixcbiAgICBwdXJwbGU6IDB4ODAwMDgwZmYsXG4gICAgcmViZWNjYXB1cnBsZTogMHg2NjMzOTlmZixcbiAgICByZWQ6IDB4ZmYwMDAwZmYsXG4gICAgcm9zeWJyb3duOiAweGJjOGY4ZmZmLFxuICAgIHJveWFsYmx1ZTogMHg0MTY5ZTFmZixcbiAgICBzYWRkbGVicm93bjogMHg4YjQ1MTNmZixcbiAgICBzYWxtb246IDB4ZmE4MDcyZmYsXG4gICAgc2FuZHlicm93bjogMHhmNGE0NjBmZixcbiAgICBzZWFncmVlbjogMHgyZThiNTdmZixcbiAgICBzZWFzaGVsbDogMHhmZmY1ZWVmZixcbiAgICBzaWVubmE6IDB4YTA1MjJkZmYsXG4gICAgc2lsdmVyOiAweGMwYzBjMGZmLFxuICAgIHNreWJsdWU6IDB4ODdjZWViZmYsXG4gICAgc2xhdGVibHVlOiAweDZhNWFjZGZmLFxuICAgIHNsYXRlZ3JheTogMHg3MDgwOTBmZixcbiAgICBzbGF0ZWdyZXk6IDB4NzA4MDkwZmYsXG4gICAgc25vdzogMHhmZmZhZmFmZixcbiAgICBzcHJpbmdncmVlbjogMHgwMGZmN2ZmZixcbiAgICBzdGVlbGJsdWU6IDB4NDY4MmI0ZmYsXG4gICAgdGFuOiAweGQyYjQ4Y2ZmLFxuICAgIHRlYWw6IDB4MDA4MDgwZmYsXG4gICAgdGhpc3RsZTogMHhkOGJmZDhmZixcbiAgICB0b21hdG86IDB4ZmY2MzQ3ZmYsXG4gICAgdHVycXVvaXNlOiAweDQwZTBkMGZmLFxuICAgIHZpb2xldDogMHhlZTgyZWVmZixcbiAgICB3aGVhdDogMHhmNWRlYjNmZixcbiAgICB3aGl0ZTogMHhmZmZmZmZmZixcbiAgICB3aGl0ZXNtb2tlOiAweGY1ZjVmNWZmLFxuICAgIHllbGxvdzogMHhmZmZmMDBmZixcbiAgICB5ZWxsb3dncmVlbjogMHg5YWNkMzJmZixcbn07XG5mdW5jdGlvbiBub3JtYWxpemVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IG1hdGNoZXJzID0gZ2V0TWF0Y2hlcnMoKTtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gT3JkZXJlZCBiYXNlZCBvbiBvY2N1cnJlbmNlcyBvbiBGYWNlYm9vayBjb2RlYmFzZVxuICAgIGlmIChtYXRjaGVycy5oZXg2KSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg2LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSArICdmZicsIDE2KSA+Pj4gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZXNbY29sb3JdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIG5hbWVzW2NvbG9yXTtcbiAgICB9XG4gICAgaWYgKG1hdGNoZXJzLnJnYikge1xuICAgICAgICBpZiAoKG1hdGNoID0gbWF0Y2hlcnMucmdiLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGJcbiAgICAgICAgICAgICgocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0KSB8IC8vIHJcbiAgICAgICAgICAgICAgICAocGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2KSB8IC8vIGdcbiAgICAgICAgICAgICAgICAocGFyc2UyNTUobWF0Y2hbM10pIDw8IDgpIHxcbiAgICAgICAgICAgICAgICAweDAwMDAwMGZmKSA+Pj4gLy8gYVxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVycy5yZ2JhKSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5yZ2JhLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGJcbiAgICAgICAgICAgICgocGFyc2UyNTUobWF0Y2hbMV0pIDw8IDI0KSB8IC8vIHJcbiAgICAgICAgICAgICAgICAocGFyc2UyNTUobWF0Y2hbMl0pIDw8IDE2KSB8IC8vIGdcbiAgICAgICAgICAgICAgICAocGFyc2UyNTUobWF0Y2hbM10pIDw8IDgpIHxcbiAgICAgICAgICAgICAgICBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gLy8gYVxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVycy5oZXgzKSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXgzLmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgIG1hdGNoWzFdICsgLy8gclxuICAgICAgICAgICAgICAgIG1hdGNoWzJdICtcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSArIC8vIGdcbiAgICAgICAgICAgICAgICBtYXRjaFszXSArXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10gKyAvLyBiXG4gICAgICAgICAgICAgICAgJ2ZmJywgLy8gYVxuICAgICAgICAgICAgMTYpID4+PiAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3NzLWNvbG9yLTQvI2hleC1ub3RhdGlvblxuICAgIGlmIChtYXRjaGVycy5oZXg4KSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg4LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUludChtYXRjaFsxXSwgMTYpID4+PiAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVycy5oZXg0KSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSBtYXRjaGVycy5oZXg0LmV4ZWMoY29sb3IpKSkge1xuICAgICAgICAgICAgcmV0dXJuIChOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgIG1hdGNoWzFdICsgLy8gclxuICAgICAgICAgICAgICAgIG1hdGNoWzJdICtcbiAgICAgICAgICAgICAgICBtYXRjaFsyXSArIC8vIGdcbiAgICAgICAgICAgICAgICBtYXRjaFszXSArXG4gICAgICAgICAgICAgICAgbWF0Y2hbM10gKyAvLyBiXG4gICAgICAgICAgICAgICAgbWF0Y2hbNF0gK1xuICAgICAgICAgICAgICAgIG1hdGNoWzRdLCAvLyBhXG4gICAgICAgICAgICAxNikgPj4+IDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaGVycy5oc2wpIHtcbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbC5leGVjKGNvbG9yKSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoKGhzbFRvUmdiKHBhcnNlMzYwKG1hdGNoWzFdKSwgLy8gaFxuICAgICAgICAgICAgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzJdKSwgLy8gc1xuICAgICAgICAgICAgcGFyc2VQZXJjZW50YWdlKG1hdGNoWzNdKSkgfFxuICAgICAgICAgICAgICAgIDB4MDAwMDAwZmYpID4+PiAvLyBhXG4gICAgICAgICAgICAgICAgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hdGNoZXJzLmhzbGEpIHtcbiAgICAgICAgaWYgKChtYXRjaCA9IG1hdGNoZXJzLmhzbGEuZXhlYyhjb2xvcikpKSB7XG4gICAgICAgICAgICByZXR1cm4gKChoc2xUb1JnYihwYXJzZTM2MChtYXRjaFsxXSksIC8vIGhcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudGFnZShtYXRjaFsyXSksIC8vIHNcbiAgICAgICAgICAgIHBhcnNlUGVyY2VudGFnZShtYXRjaFszXSkpIHxcbiAgICAgICAgICAgICAgICBwYXJzZTEobWF0Y2hbNF0pKSA+Pj4gLy8gYVxuICAgICAgICAgICAgICAgIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBjb2xvciBzdHJpbmcgJHtjb2xvcn0gcHJvdmlkZWRgKTtcbn1cbmNvbnN0IG9wYWNpdHkgPSAoYykgPT4ge1xuICAgIHJldHVybiAoKGMgPj4gMjQpICYgMjU1KSAvIDI1NTtcbn07XG5jb25zdCByZWQgPSAoYykgPT4ge1xuICAgIHJldHVybiAoYyA+PiAxNikgJiAyNTU7XG59O1xuY29uc3QgZ3JlZW4gPSAoYykgPT4ge1xuICAgIHJldHVybiAoYyA+PiA4KSAmIDI1NTtcbn07XG5jb25zdCBibHVlID0gKGMpID0+IHtcbiAgICByZXR1cm4gYyAmIDI1NTtcbn07XG5jb25zdCByZ2JhQ29sb3IgPSAociwgZywgYiwgYWxwaGEpID0+IHtcbiAgICByZXR1cm4gYHJnYmEoJHtyfSwgJHtnfSwgJHtifSwgJHthbHBoYX0pYDtcbn07XG5mdW5jdGlvbiBwcm9jZXNzQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBub3JtYWxpemVkQ29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgcmV0dXJuICgobm9ybWFsaXplZENvbG9yIDw8IDI0KSB8IChub3JtYWxpemVkQ29sb3IgPj4+IDgpKSA+Pj4gMDsgLy8gYXJnYlxufVxuY29uc3QgaW50ZXJwb2xhdGVDb2xvcnNSR0IgPSAodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycykgPT4ge1xuICAgIGNvbnN0IFtyLCBnLCBiLCBhXSA9IFtyZWQsIGdyZWVuLCBibHVlLCBvcGFjaXR5XS5tYXAoKGYpID0+IHtcbiAgICAgICAgY29uc3QgdW5yb3VuZGVkID0gaW50ZXJwb2xhdGUodmFsdWUsIGlucHV0UmFuZ2UsIGNvbG9ycy5tYXAoKGMpID0+IGYoYykpLCB7XG4gICAgICAgICAgICBleHRyYXBvbGF0ZUxlZnQ6ICdjbGFtcCcsXG4gICAgICAgICAgICBleHRyYXBvbGF0ZVJpZ2h0OiAnY2xhbXAnLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGYgPT09IG9wYWNpdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIodW5yb3VuZGVkLnRvRml4ZWQoMykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBNYXRoLnJvdW5kKHVucm91bmRlZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJnYmFDb2xvcihyLCBnLCBiLCBhKTtcbn07XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gbWFwIGEgcmFuZ2Ugb2YgdmFsdWVzIHRvIGNvbG9ycyB1c2luZyBhIGNvbmNpc2Ugc3ludGF4LlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvaW50ZXJwb2xhdGUtY29sb3JzKVxuICovXG5jb25zdCBpbnRlcnBvbGF0ZUNvbG9ycyA9IChpbnB1dCwgaW5wdXRSYW5nZSwgb3V0cHV0UmFuZ2UpID0+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBjYW4gbm90IGJlIHVuZGVmaW5lZCcpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0UmFuZ2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvdXRwdXRSYW5nZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3V0cHV0UmFuZ2UgY2FuIG5vdCBiZSB1bmRlZmluZWQnKTtcbiAgICB9XG4gICAgaWYgKGlucHV0UmFuZ2UubGVuZ3RoICE9PSBvdXRwdXRSYW5nZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXRSYW5nZSAoJyArXG4gICAgICAgICAgICBpbnB1dFJhbmdlLmxlbmd0aCArXG4gICAgICAgICAgICAnIHZhbHVlcyBwcm92aWRlZCkgYW5kIG91dHB1dFJhbmdlICgnICtcbiAgICAgICAgICAgIG91dHB1dFJhbmdlLmxlbmd0aCArXG4gICAgICAgICAgICAnIHZhbHVlcyBwcm92aWRlZCkgbXVzdCBoYXZlIHRoZSBzYW1lIGxlbmd0aCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzZWRPdXRwdXRSYW5nZSA9IG91dHB1dFJhbmdlLm1hcCgoYykgPT4gcHJvY2Vzc0NvbG9yKGMpKTtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGVDb2xvcnNSR0IoaW5wdXQsIGlucHV0UmFuZ2UsIHByb2Nlc3NlZE91dHB1dFJhbmdlKTtcbn07XG5cbmxldCBSb290ID0gbnVsbDtcbmxldCBsaXN0ZW5lcnMgPSBbXTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcmVnaXN0ZXJzIHRoZSByb290IGNvbXBvbmVudCBvZiB0aGUgUmVtb3Rpb24gcHJvamVjdFxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3MvcmVnaXN0ZXItcm9vdClcbiAqL1xuY29uc3QgcmVnaXN0ZXJSb290ID0gKGNvbXApID0+IHtcbiAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgbXVzdCBwYXNzIGEgUmVhY3QgY29tcG9uZW50IHRvIHJlZ2lzdGVyUm9vdCgpLCBidXQgJHtKU09OLnN0cmluZ2lmeShjb21wKX0gd2FzIHBhc3NlZC5gKTtcbiAgICB9XG4gICAgaWYgKFJvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWdpc3RlclJvb3QoKSB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLicpO1xuICAgIH1cbiAgICBSb290ID0gY29tcDtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaCgobCkgPT4ge1xuICAgICAgICBsKGNvbXApO1xuICAgIH0pO1xufTtcbmNvbnN0IGdldFJvb3QgPSAoKSA9PiB7XG4gICAgcmV0dXJuIFJvb3Q7XG59O1xuY29uc3Qgd2FpdEZvclJvb3QgPSAoZm4pID0+IHtcbiAgICBpZiAoUm9vdCkge1xuICAgICAgICBmbihSb290KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGlzdGVuZXJzLnB1c2goZm4pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGxpc3RlbmVycyA9IGxpc3RlbmVycy5maWx0ZXIoKGwpID0+IGwgIT09IGZuKTtcbiAgICB9O1xufTtcblxuY29uc3QgUmVtb3Rpb25Sb290ID0gKHsgY2hpbGRyZW4sIG51bWJlck9mQXVkaW9UYWdzIH0pID0+IHtcbiAgICBjb25zdCBbcmVtb3Rpb25Sb290SWRdID0gdXNlU3RhdGUoKCkgPT4gU3RyaW5nKHJhbmRvbShudWxsKSkpO1xuICAgIGNvbnN0IFtmcmFtZSwgc2V0RnJhbWVdID0gdXNlU3RhdGUoe30pO1xuICAgIGNvbnN0IFtwbGF5aW5nLCBzZXRQbGF5aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBpbXBlcmF0aXZlUGxheWluZyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgW2Zhc3RSZWZyZXNoZXMsIHNldEZhc3RSZWZyZXNoZXNdID0gdXNlU3RhdGUoMCk7XG4gICAgY29uc3QgW3BsYXliYWNrUmF0ZSwgc2V0UGxheWJhY2tSYXRlXSA9IHVzZVN0YXRlKDEpO1xuICAgIGNvbnN0IGF1ZGlvQW5kVmlkZW9UYWdzID0gdXNlUmVmKFtdKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL3J1bGVzLW9mLWhvb2tzXG4gICAgICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3Rpb25fc2V0RnJhbWUgPSAoZiwgY29tcG9zaXRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGRlbGF5UmVuZGVyKGBTZXR0aW5nIHRoZSBjdXJyZW50IGZyYW1lIHRvICR7Zn1gKTtcbiAgICAgICAgICAgICAgICBzZXRGcmFtZSgocykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4ucyxcbiAgICAgICAgICAgICAgICAgICAgW2NvbXBvc2l0aW9uXTogZixcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGNvbnRpbnVlUmVuZGVyKGlkKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd2luZG93LnJlbW90aW9uX2lzUGxheWVyID0gZmFsc2U7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgY29uc3QgdGltZWxpbmVDb250ZXh0VmFsdWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyYW1lLFxuICAgICAgICAgICAgcGxheWluZyxcbiAgICAgICAgICAgIGltcGVyYXRpdmVQbGF5aW5nLFxuICAgICAgICAgICAgcm9vdElkOiByZW1vdGlvblJvb3RJZCxcbiAgICAgICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgICAgIHNldFBsYXliYWNrUmF0ZSxcbiAgICAgICAgICAgIGF1ZGlvQW5kVmlkZW9UYWdzLFxuICAgICAgICB9O1xuICAgIH0sIFtmcmFtZSwgcGxheWJhY2tSYXRlLCBwbGF5aW5nLCByZW1vdGlvblJvb3RJZF0pO1xuICAgIGNvbnN0IHNldFRpbWVsaW5lQ29udGV4dFZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRGcmFtZSxcbiAgICAgICAgICAgIHNldFBsYXlpbmcsXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IG5vbmNlQ29udGV4dCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROb25jZTogKCkgPT4gY291bnRlcisrLFxuICAgICAgICAgICAgZmFzdFJlZnJlc2hlcyxcbiAgICAgICAgfTtcbiAgICB9LCBbZmFzdFJlZnJlc2hlc10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX21vZHVsZV9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgaWYgKF9fd2VicGFja19tb2R1bGVfXy5ob3QpIHtcbiAgICAgICAgICAgICAgICBfX3dlYnBhY2tfbW9kdWxlX18uaG90LmFkZFN0YXR1c0hhbmRsZXIoKHN0YXR1cykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzID09PSAnaWRsZScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEZhc3RSZWZyZXNoZXMoKGkpID0+IGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoanN4KE5vbmNlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbm9uY2VDb250ZXh0LCBjaGlsZHJlbjoganN4KFRpbWVsaW5lQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdGltZWxpbmVDb250ZXh0VmFsdWUsIGNoaWxkcmVuOiBqc3goU2V0VGltZWxpbmVDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBzZXRUaW1lbGluZUNvbnRleHRWYWx1ZSwgY2hpbGRyZW46IGpzeChFZGl0b3JQcm9wc1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goUHJlZmV0Y2hQcm92aWRlciwgeyBjaGlsZHJlbjoganN4KE5hdGl2ZUxheWVyc1Byb3ZpZGVyLCB7IGNoaWxkcmVuOiBqc3goQ29tcG9zaXRpb25NYW5hZ2VyUHJvdmlkZXIsIHsgbnVtYmVyT2ZBdWRpb1RhZ3M6IG51bWJlck9mQXVkaW9UYWdzLCBjaGlsZHJlbjoganN4KER1cmF0aW9uc0NvbnRleHRQcm92aWRlciwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkgfSkgfSkgfSkgfSkgfSkgfSkpO1xufTtcblxuY29uc3QgZ2V0RW52VmFyaWFibGVzID0gKCkgPT4ge1xuICAgIGlmIChnZXRSZW1vdGlvbkVudmlyb25tZW50KCkuaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSB3aW5kb3cucmVtb3Rpb25fZW52VmFyaWFibGVzO1xuICAgICAgICBpZiAoIXBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgLi4uSlNPTi5wYXJzZShwYXJhbSksIE5PREVfRU5WOiBwcm9jZXNzLmVudi5OT0RFX0VOViB9O1xuICAgIH1cbiAgICBpZiAoZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpLmlzU3R1ZGlvKSB7XG4gICAgICAgIC8vIEZvciB0aGUgU3R1ZGlvLCB3ZSBhbHJlYWR5IHNldCB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGluIGluZGV4LWh0bWwudHMuXG4gICAgICAgIC8vIFdlIGp1c3QgYWRkIE5PREVfRU5WIGhlcmUuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBOT0RFX0VOVjogJ2RldmVsb3BtZW50JyxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW4gb25seSBjYWxsIGdldEVudlZhcmlhYmxlcygpIGlmIGVudmlyb25tZW50IGlzIGByZW5kZXJpbmdgIG9yIGBwcmV2aWV3YCcpO1xufTtcbmNvbnN0IHNldHVwRW52VmFyaWFibGVzID0gKCkgPT4ge1xuICAgIGNvbnN0IGVudiA9IGdldEVudlZhcmlhYmxlcygpO1xuICAgIGlmICghd2luZG93LnByb2Nlc3MpIHtcbiAgICAgICAgd2luZG93LnByb2Nlc3MgPSB7fTtcbiAgICB9XG4gICAgaWYgKCF3aW5kb3cucHJvY2Vzcy5lbnYpIHtcbiAgICAgICAgd2luZG93LnByb2Nlc3MuZW52ID0ge307XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHdpbmRvdy5wcm9jZXNzLmVudltrZXldID0gZW52W2tleV07XG4gICAgfSk7XG59O1xuXG5jb25zdCB2YWxpZGF0ZUZyYW1lID0gKHsgYWxsb3dGbG9hdHMsIGR1cmF0aW9uSW5GcmFtZXMsIGZyYW1lLCB9KSA9PiB7XG4gICAgaWYgKHR5cGVvZiBmcmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgQXJndW1lbnQgbWlzc2luZyBmb3IgcGFyYW1ldGVyIFwiZnJhbWVcImApO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZyYW1lICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBcmd1bWVudCBwYXNzZWQgZm9yIFwiZnJhbWVcIiBpcyBub3QgYSBudW1iZXI6ICR7ZnJhbWV9YCk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGZyYW1lKSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgRnJhbWUgJHtmcmFtZX0gaXMgbm90IGZpbml0ZWApO1xuICAgIH1cbiAgICBpZiAoZnJhbWUgJSAxICE9PSAwICYmICFhbGxvd0Zsb2F0cykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgQXJndW1lbnQgZm9yIGZyYW1lIG11c3QgYmUgYW4gaW50ZWdlciwgYnV0IGdvdCAke2ZyYW1lfWApO1xuICAgIH1cbiAgICBpZiAoZnJhbWUgPCAwICYmIGZyYW1lIDwgLWR1cmF0aW9uSW5GcmFtZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENhbm5vdCB1c2UgZnJhbWUgJHtmcmFtZX06IER1cmF0aW9uIG9mIGNvbXBvc2l0aW9uIGlzICR7ZHVyYXRpb25JbkZyYW1lc30sIHRoZXJlZm9yZSB0aGUgbG93ZXN0IGZyYW1lIHRoYXQgY2FuIGJlIHJlbmRlcmVkIGlzICR7LWR1cmF0aW9uSW5GcmFtZXN9YCk7XG4gICAgfVxuICAgIGlmIChmcmFtZSA+IGR1cmF0aW9uSW5GcmFtZXMgLSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBDYW5ub3QgdXNlIGZyYW1lICR7ZnJhbWV9OiBEdXJhdGlvbiBvZiBjb21wb3NpdGlvbiBpcyAke2R1cmF0aW9uSW5GcmFtZXN9LCB0aGVyZWZvcmUgdGhlIGhpZ2hlc3QgZnJhbWUgdGhhdCBjYW4gYmUgcmVuZGVyZWQgaXMgJHtkdXJhdGlvbkluRnJhbWVzIC0gMX1gKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiB1c2VSZW1vdGlvbkNvbnRleHRzKCkge1xuICAgIGNvbnN0IGNvbXBvc2l0aW9uTWFuYWdlckN0eCA9IFJlYWN0LnVzZUNvbnRleHQoQ29tcG9zaXRpb25NYW5hZ2VyKTtcbiAgICBjb25zdCB0aW1lbGluZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFRpbWVsaW5lQ29udGV4dCk7XG4gICAgY29uc3Qgc2V0VGltZWxpbmVDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTZXRUaW1lbGluZUNvbnRleHQpO1xuICAgIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCBub25jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE5vbmNlQ29udGV4dCk7XG4gICAgY29uc3QgY2FuVXNlUmVtb3Rpb25Ib29rc0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KENhblVzZVJlbW90aW9uSG9va3MpO1xuICAgIGNvbnN0IG5hdGl2ZUxheWVyc0NvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KE5hdGl2ZUxheWVyc0NvbnRleHQpO1xuICAgIGNvbnN0IHByZWxvYWRDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVsb2FkQ29udGV4dCk7XG4gICAgY29uc3QgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCk7XG4gICAgY29uc3QgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCA9IFJlYWN0LnVzZUNvbnRleHQoUmVuZGVyQXNzZXRNYW5hZ2VyKTtcbiAgICBjb25zdCBzZXF1ZW5jZU1hbmFnZXJDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChTZXF1ZW5jZU1hbmFnZXIpO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+ICh7XG4gICAgICAgIGNvbXBvc2l0aW9uTWFuYWdlckN0eCxcbiAgICAgICAgdGltZWxpbmVDb250ZXh0LFxuICAgICAgICBzZXRUaW1lbGluZUNvbnRleHQsXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICAgICAgbm9uY2VDb250ZXh0LFxuICAgICAgICBjYW5Vc2VSZW1vdGlvbkhvb2tzQ29udGV4dCxcbiAgICAgICAgbmF0aXZlTGF5ZXJzQ29udGV4dCxcbiAgICAgICAgcHJlbG9hZENvbnRleHQsXG4gICAgICAgIHJlc29sdmVDb21wb3NpdGlvbkNvbnRleHQsXG4gICAgICAgIHJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsXG4gICAgICAgIHNlcXVlbmNlTWFuYWdlckNvbnRleHQsXG4gICAgfSksIFtcbiAgICAgICAgY29tcG9zaXRpb25NYW5hZ2VyQ3R4LFxuICAgICAgICBub25jZUNvbnRleHQsXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCxcbiAgICAgICAgc2V0VGltZWxpbmVDb250ZXh0LFxuICAgICAgICB0aW1lbGluZUNvbnRleHQsXG4gICAgICAgIGNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LFxuICAgICAgICBuYXRpdmVMYXllcnNDb250ZXh0LFxuICAgICAgICBwcmVsb2FkQ29udGV4dCxcbiAgICAgICAgcmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCxcbiAgICAgICAgcmVuZGVyQXNzZXRNYW5hZ2VyQ29udGV4dCxcbiAgICAgICAgc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCxcbiAgICBdKTtcbn1cbmNvbnN0IFJlbW90aW9uQ29udGV4dFByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgY29udGV4dHMgfSA9IHByb3BzO1xuICAgIHJldHVybiAoanN4KENhblVzZVJlbW90aW9uSG9va3MuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLmNhblVzZVJlbW90aW9uSG9va3NDb250ZXh0LCBjaGlsZHJlbjoganN4KE5vbmNlQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dHMubm9uY2VDb250ZXh0LCBjaGlsZHJlbjoganN4KE5hdGl2ZUxheWVyc0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLm5hdGl2ZUxheWVyc0NvbnRleHQsIGNoaWxkcmVuOiBqc3goUHJlbG9hZENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLnByZWxvYWRDb250ZXh0LCBjaGlsZHJlbjoganN4KENvbXBvc2l0aW9uTWFuYWdlci5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dHMuY29tcG9zaXRpb25NYW5hZ2VyQ3R4LCBjaGlsZHJlbjoganN4KFNlcXVlbmNlTWFuYWdlci5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dHMuc2VxdWVuY2VNYW5hZ2VyQ29udGV4dCwgY2hpbGRyZW46IGpzeChSZW5kZXJBc3NldE1hbmFnZXIuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLnJlbmRlckFzc2V0TWFuYWdlckNvbnRleHQsIGNoaWxkcmVuOiBqc3goUmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dHMucmVzb2x2ZUNvbXBvc2l0aW9uQ29udGV4dCwgY2hpbGRyZW46IGpzeChUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLnRpbWVsaW5lQ29udGV4dCwgY2hpbGRyZW46IGpzeChTZXRUaW1lbGluZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLnNldFRpbWVsaW5lQ29udGV4dCwgY2hpbGRyZW46IGpzeChTZXF1ZW5jZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHRzLnNlcXVlbmNlQ29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pIH0pIH0pIH0pIH0pIH0pIH0pIH0pIH0pIH0pKTtcbn07XG5cbi8vIE1hcmsgdGhlbSBhcyBJbnRlcm5hbHMgc28gdXNlIGRvbid0IGFzc3VtZSB0aGlzIGlzIHB1YmxpY1xuLy8gQVBJIGFuZCBhcmUgbGVzcyBsaWtlbHkgdG8gdXNlIGl0XG5jb25zdCBJbnRlcm5hbHMgPSB7XG4gICAgdXNlVW5zYWZlVmlkZW9Db25maWcsXG4gICAgVGltZWxpbmU6IFRpbWVsaW5lUG9zaXRpb24sXG4gICAgQ29tcG9zaXRpb25NYW5hZ2VyLFxuICAgIFNlcXVlbmNlTWFuYWdlcixcbiAgICBSZW1vdGlvblJvb3QsXG4gICAgdXNlVmlkZW8sXG4gICAgZ2V0Um9vdCxcbiAgICB1c2VNZWRpYVZvbHVtZVN0YXRlLFxuICAgIHVzZU1lZGlhTXV0ZWRTdGF0ZSxcbiAgICB1c2VMYXp5Q29tcG9uZW50LFxuICAgIHRydXRoeSxcbiAgICBTZXF1ZW5jZUNvbnRleHQsXG4gICAgdXNlUmVtb3Rpb25Db250ZXh0cyxcbiAgICBSZW1vdGlvbkNvbnRleHRQcm92aWRlcixcbiAgICBDU1NVdGlscyxcbiAgICBzZXR1cEVudlZhcmlhYmxlcyxcbiAgICBNZWRpYVZvbHVtZUNvbnRleHQsXG4gICAgU2V0TWVkaWFWb2x1bWVDb250ZXh0LFxuICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyxcbiAgICB2YWxpZGF0ZUZwcyxcbiAgICB2YWxpZGF0ZURlZmF1bHRBbmRJbnB1dFByb3BzLFxuICAgIHZhbGlkYXRlRGltZW5zaW9uLFxuICAgIGdldFJlbW90aW9uRW52aXJvbm1lbnQsXG4gICAgU2hhcmVkQXVkaW9Db250ZXh0LFxuICAgIFNoYXJlZEF1ZGlvQ29udGV4dFByb3ZpZGVyLFxuICAgIGludmFsaWRDb21wb3NpdGlvbkVycm9yTWVzc2FnZSxcbiAgICBpc0NvbXBvc2l0aW9uSWRWYWxpZCxcbiAgICBnZXRQcmV2aWV3RG9tRWxlbWVudCxcbiAgICBjb21wb3NpdGlvbnNSZWYsXG4gICAgREVMQVlfUkVOREVSX0NBTExTVEFDS19UT0tFTixcbiAgICBwb3J0YWxOb2RlLFxuICAgIHdhaXRGb3JSb290LFxuICAgIENhblVzZVJlbW90aW9uSG9va3NQcm92aWRlcixcbiAgICBDYW5Vc2VSZW1vdGlvbkhvb2tzLFxuICAgIFByZWZldGNoUHJvdmlkZXIsXG4gICAgRHVyYXRpb25zQ29udGV4dFByb3ZpZGVyLFxuICAgIElzUGxheWVyQ29udGV4dFByb3ZpZGVyLFxuICAgIHVzZUlzUGxheWVyLFxuICAgIHZhbGlkYXRlRnJhbWUsXG4gICAgRWRpdG9yUHJvcHNQcm92aWRlcixcbiAgICBFZGl0b3JQcm9wc0NvbnRleHQsXG4gICAgdXNlUHJlbG9hZCxcbiAgICBwcm9jZXNzQ29sb3IsXG4gICAgTm9uY2VDb250ZXh0LFxuICAgIHJlc29sdmVWaWRlb0NvbmZpZyxcbiAgICB1c2VSZXNvbHZlZFZpZGVvQ29uZmlnLFxuICAgIHJlc29sdmVDb21wb3NpdGlvbnNSZWYsXG4gICAgUmVzb2x2ZUNvbXBvc2l0aW9uQ29uZmlnLFxuICAgIFJFTU9USU9OX1NUVURJT19DT05UQUlORVJfRUxFTUVOVCxcbiAgICBSZW5kZXJBc3NldE1hbmFnZXIsXG4gICAgYnVuZGxlTmFtZTogJ2J1bmRsZS5qcycsXG4gICAgYnVuZGxlTWFwTmFtZTogJ2J1bmRsZS5qcy5tYXAnLFxuICAgIHBlcnNpc3RDdXJyZW50RnJhbWUsXG4gICAgdXNlVGltZWxpbmVTZXRGcmFtZSxcbiAgICBzZXJpYWxpemVKU09OV2l0aERhdGUsXG4gICAgZGVzZXJpYWxpemVKU09OV2l0aEN1c3RvbUZpZWxkcyxcbiAgICBGSUxFX1RPS0VOLFxuICAgIERBVEVfVE9LRU4sXG4gICAgTmF0aXZlTGF5ZXJzUHJvdmlkZXIsXG4gICAgQ2xpcENvbXBvc2l0aW9uLFxuICAgIGlzSW9zU2FmYXJpLFxufTtcblxuY29uc3QgZmxhdHRlbkNoaWxkcmVuID0gKGNoaWxkcmVuKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW5BcnJheSA9IFJlYWN0LkNoaWxkcmVuLnRvQXJyYXkoY2hpbGRyZW4pO1xuICAgIHJldHVybiBjaGlsZHJlbkFycmF5LnJlZHVjZSgoZmxhdENoaWxkcmVuLCBjaGlsZCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQudHlwZSA9PT0gUmVhY3QuRnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmbGF0Q2hpbGRyZW4uY29uY2F0KGZsYXR0ZW5DaGlsZHJlbihjaGlsZC5wcm9wc1xuICAgICAgICAgICAgICAgIC5jaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgICAgIGZsYXRDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgcmV0dXJuIGZsYXRDaGlsZHJlbjtcbiAgICB9LCBbXSk7XG59O1xuXG5jb25zdCBTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbiA9ICh7IGNoaWxkcmVuIH0sIF9yZWYpID0+IHtcbiAgICAvLyBEaXNjYXJkIHJlZlxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9qc3gtbm8tdXNlbGVzcy1mcmFnbWVudFxuICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufTtcbmNvbnN0IFNlcmllc1NlcXVlbmNlID0gZm9yd2FyZFJlZihTZXJpZXNTZXF1ZW5jZVJlZkZvcndhcmRpbmdGdW5jdGlvbik7XG4vKipcbiAqIEBkZXNjcmlwdGlvbiB3aXRoIHRoaXMgY29tcG9uZW50LCB5b3UgY2FuIGVhc2lseSBzdGl0Y2ggdG9nZXRoZXIgc2NlbmVzIHRoYXQgc2hvdWxkIHBsYXkgc2VxdWVudGlhbGx5IGFmdGVyIGFub3RoZXIuXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9zZXJpZXMpXG4gKi9cbmNvbnN0IFNlcmllcyA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBjb25zdCBjaGlsZHJlblZhbHVlID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGxldCBzdGFydEZyYW1lID0gMDtcbiAgICAgICAgY29uc3QgZmxhdHRlbmVkQ2hpbGRyZW4gPSBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICAgICAgICByZXR1cm4gQ2hpbGRyZW4ubWFwKGZsYXR0ZW5lZENoaWxkcmVuLCAoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGNhc3RlZENoaWxkID0gY2hpbGQ7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhc3RlZENoaWxkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIC8vIERvbid0IHRocm93IGlmIGl0J3MganVzdCBzb21lIGFjY2lkZW50aWFsIHdoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICBpZiAoY2FzdGVkQ2hpbGQudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0J3MgY2hpbGRyZW4sIGJ1dCB5b3UgcGFzc2VkIGEgc3RyaW5nIFwiJHtjYXN0ZWRDaGlsZH1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNhc3RlZENoaWxkLnR5cGUgIT09IFNlcmllc1NlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIDxTZXJpZXMgLz4gY29tcG9uZW50IG9ubHkgYWNjZXB0cyBhIGxpc3Qgb2YgPFNlcmllcy5TZXF1ZW5jZSAvPiBjb21wb25lbnRzIGFzIGl0J3MgY2hpbGRyZW4sIGJ1dCBnb3QgJHtjYXN0ZWRDaGlsZH0gaW5zdGVhZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGVidWdJbmZvID0gYGluZGV4ID0gJHtpfSwgZHVyYXRpb24gPSAke2Nhc3RlZENoaWxkLnByb3BzLmR1cmF0aW9uSW5GcmFtZXN9YDtcbiAgICAgICAgICAgIGlmICghKGNhc3RlZENoaWxkID09PSBudWxsIHx8IGNhc3RlZENoaWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXN0ZWRDaGlsZC5wcm9wcy5jaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBBIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50ICgke2RlYnVnSW5mb30pIHdhcyBkZXRlY3RlZCB0byBub3QgaGF2ZSBhbnkgY2hpbGRyZW4uIERlbGV0ZSBpdCB0byBmaXggdGhpcyBlcnJvci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1cmF0aW9uSW5GcmFtZXNQcm9wID0gY2FzdGVkQ2hpbGQucHJvcHMuZHVyYXRpb25JbkZyYW1lcztcbiAgICAgICAgICAgIGNvbnN0IHsgZHVyYXRpb25JbkZyYW1lcywgY2hpbGRyZW46IF9jaGlsZHJlbiwgZnJvbSwgLi4ucGFzc2VkUHJvcHMgfSA9IGNhc3RlZENoaWxkLnByb3BzOyAvLyBgZnJvbWAgaXMgbm90IGFjY2VwdGVkIGFuZCBtdXN0IGJlIGZpbHRlcmVkIG91dCBpZiB1c2VkIGluIEpTXG4gICAgICAgICAgICBpZiAoaSAhPT0gZmxhdHRlbmVkQ2hpbGRyZW4ubGVuZ3RoIC0gMSB8fFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uSW5GcmFtZXNQcm9wICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRHVyYXRpb25JbkZyYW1lcyhkdXJhdGlvbkluRnJhbWVzUHJvcCwge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQ6IGBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gY29tcG9uZW50YCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dGbG9hdHM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvZmZzZXQgPSAoX2EgPSBjYXN0ZWRDaGlsZC5wcm9wcy5vZmZzZXQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBub3QgYmUgTmFOLCBidXQgZ290IE5hTiAoJHtkZWJ1Z0luZm99KS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtvZmZzZXR9ICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9mZnNldCAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXCJvZmZzZXRcIiBwcm9wZXJ0eSBvZiBhIDxTZXJpZXMuU2VxdWVuY2UgLz4gbXVzdCBiZSBmaW5pdGUsIGJ1dCBnb3QgJHtvZmZzZXR9ICgke2RlYnVnSW5mb30pLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3VycmVudFN0YXJ0RnJhbWUgPSBzdGFydEZyYW1lICsgb2Zmc2V0O1xuICAgICAgICAgICAgc3RhcnRGcmFtZSArPSBkdXJhdGlvbkluRnJhbWVzUHJvcCArIG9mZnNldDtcbiAgICAgICAgICAgIHJldHVybiAoanN4KFNlcXVlbmNlLCB7IGZyb206IGN1cnJlbnRTdGFydEZyYW1lLCBkdXJhdGlvbkluRnJhbWVzOiBkdXJhdGlvbkluRnJhbWVzUHJvcCwgLi4ucGFzc2VkUHJvcHMsIHJlZjogY2FzdGVkQ2hpbGQucmVmLCBjaGlsZHJlbjogY2hpbGQgfSkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbY2hpbGRyZW5dKTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC9qc3gtbm8tdXNlbGVzcy1mcmFnbWVudCAqL1xuICAgIHJldHVybiBqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IGNoaWxkcmVuVmFsdWUgfSk7XG59O1xuU2VyaWVzLlNlcXVlbmNlID0gU2VyaWVzU2VxdWVuY2U7XG5cbmNvbnN0IHZhbGlkYXRlU3ByaW5nRHVyYXRpb24gPSAoZHVyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkdXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkdXIgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYEEgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgYSBcIm51bWJlclwiIGJ1dCBpcyBcIiR7dHlwZW9mIGR1cn1cImApO1xuICAgIH1cbiAgICBpZiAoTnVtYmVyLmlzTmFOKGR1cikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBcImR1cmF0aW9uXCIgb2YgYSBzcHJpbmcgaXMgTmFOLCB3aGljaCBpdCBtdXN0IG5vdCBiZScpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShkdXIpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgXCJkdXJhdGlvblwiIG9mIGEgc3ByaW5nIG11c3QgYmUgZmluaXRlLCBidXQgaXMgJyArIGR1cik7XG4gICAgfVxuICAgIGlmIChkdXIgPD0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIFwiZHVyYXRpb25cIiBvZiBhIHNwcmluZyBtdXN0IGJlIHBvc2l0aXZlLCBidXQgaXMgJyArIGR1cik7XG4gICAgfVxufTtcblxuY29uc3QgZGVmYXVsdFNwcmluZ0NvbmZpZyA9IHtcbiAgICBkYW1waW5nOiAxMCxcbiAgICBtYXNzOiAxLFxuICAgIHN0aWZmbmVzczogMTAwLFxuICAgIG92ZXJzaG9vdENsYW1waW5nOiBmYWxzZSxcbn07XG5jb25zdCBhZHZhbmNlQ2FjaGUgPSB7fTtcbmZ1bmN0aW9uIGFkdmFuY2UoeyBhbmltYXRpb24sIG5vdywgY29uZmlnLCB9KSB7XG4gICAgY29uc3QgeyB0b1ZhbHVlLCBsYXN0VGltZXN0YW1wLCBjdXJyZW50LCB2ZWxvY2l0eSB9ID0gYW5pbWF0aW9uO1xuICAgIGNvbnN0IGRlbHRhVGltZSA9IE1hdGgubWluKG5vdyAtIGxhc3RUaW1lc3RhbXAsIDY0KTtcbiAgICBjb25zdCBjID0gY29uZmlnLmRhbXBpbmc7XG4gICAgY29uc3QgbSA9IGNvbmZpZy5tYXNzO1xuICAgIGNvbnN0IGsgPSBjb25maWcuc3RpZmZuZXNzO1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgICAgICB0b1ZhbHVlLFxuICAgICAgICBsYXN0VGltZXN0YW1wLFxuICAgICAgICBjdXJyZW50LFxuICAgICAgICB2ZWxvY2l0eSxcbiAgICAgICAgYyxcbiAgICAgICAgbSxcbiAgICAgICAgayxcbiAgICAgICAgbm93LFxuICAgIF0uam9pbignLScpO1xuICAgIGlmIChhZHZhbmNlQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgIHJldHVybiBhZHZhbmNlQ2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICBjb25zdCB2MCA9IC12ZWxvY2l0eTtcbiAgICBjb25zdCB4MCA9IHRvVmFsdWUgLSBjdXJyZW50O1xuICAgIGNvbnN0IHpldGEgPSBjIC8gKDIgKiBNYXRoLnNxcnQoayAqIG0pKTsgLy8gZGFtcGluZyByYXRpb1xuICAgIGNvbnN0IG9tZWdhMCA9IE1hdGguc3FydChrIC8gbSk7IC8vIHVuZGFtcGVkIGFuZ3VsYXIgZnJlcXVlbmN5IG9mIHRoZSBvc2NpbGxhdG9yIChyYWQvbXMpXG4gICAgY29uc3Qgb21lZ2ExID0gb21lZ2EwICogTWF0aC5zcXJ0KDEgLSB6ZXRhICoqIDIpOyAvLyBleHBvbmVudGlhbCBkZWNheVxuICAgIGNvbnN0IHQgPSBkZWx0YVRpbWUgLyAxMDAwO1xuICAgIGNvbnN0IHNpbjEgPSBNYXRoLnNpbihvbWVnYTEgKiB0KTtcbiAgICBjb25zdCBjb3MxID0gTWF0aC5jb3Mob21lZ2ExICogdCk7XG4gICAgLy8gdW5kZXIgZGFtcGVkXG4gICAgY29uc3QgdW5kZXJEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC16ZXRhICogb21lZ2EwICogdCk7XG4gICAgY29uc3QgdW5kZXJEYW1wZWRGcmFnMSA9IHVuZGVyRGFtcGVkRW52ZWxvcGUgKlxuICAgICAgICAoc2luMSAqICgodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC8gb21lZ2ExKSArIHgwICogY29zMSk7XG4gICAgY29uc3QgdW5kZXJEYW1wZWRQb3NpdGlvbiA9IHRvVmFsdWUgLSB1bmRlckRhbXBlZEZyYWcxO1xuICAgIC8vIFRoaXMgbG9va3MgY3JhenkgLS0gaXQncyBhY3R1YWxseSBqdXN0IHRoZSBkZXJpdmF0aXZlIG9mIHRoZSBvc2NpbGxhdGlvbiBmdW5jdGlvblxuICAgIGNvbnN0IHVuZGVyRGFtcGVkVmVsb2NpdHkgPSB6ZXRhICogb21lZ2EwICogdW5kZXJEYW1wZWRGcmFnMSAtXG4gICAgICAgIHVuZGVyRGFtcGVkRW52ZWxvcGUgKlxuICAgICAgICAgICAgKGNvczEgKiAodjAgKyB6ZXRhICogb21lZ2EwICogeDApIC0gb21lZ2ExICogeDAgKiBzaW4xKTtcbiAgICAvLyBjcml0aWNhbGx5IGRhbXBlZFxuICAgIGNvbnN0IGNyaXRpY2FsbHlEYW1wZWRFbnZlbG9wZSA9IE1hdGguZXhwKC1vbWVnYTAgKiB0KTtcbiAgICBjb25zdCBjcml0aWNhbGx5RGFtcGVkUG9zaXRpb24gPSB0b1ZhbHVlIC0gY3JpdGljYWxseURhbXBlZEVudmVsb3BlICogKHgwICsgKHYwICsgb21lZ2EwICogeDApICogdCk7XG4gICAgY29uc3QgY3JpdGljYWxseURhbXBlZFZlbG9jaXR5ID0gY3JpdGljYWxseURhbXBlZEVudmVsb3BlICpcbiAgICAgICAgKHYwICogKHQgKiBvbWVnYTAgLSAxKSArIHQgKiB4MCAqIG9tZWdhMCAqIG9tZWdhMCk7XG4gICAgY29uc3QgYW5pbWF0aW9uTm9kZSA9IHtcbiAgICAgICAgdG9WYWx1ZSxcbiAgICAgICAgcHJldlBvc2l0aW9uOiBjdXJyZW50LFxuICAgICAgICBsYXN0VGltZXN0YW1wOiBub3csXG4gICAgICAgIGN1cnJlbnQ6IHpldGEgPCAxID8gdW5kZXJEYW1wZWRQb3NpdGlvbiA6IGNyaXRpY2FsbHlEYW1wZWRQb3NpdGlvbixcbiAgICAgICAgdmVsb2NpdHk6IHpldGEgPCAxID8gdW5kZXJEYW1wZWRWZWxvY2l0eSA6IGNyaXRpY2FsbHlEYW1wZWRWZWxvY2l0eSxcbiAgICB9O1xuICAgIGFkdmFuY2VDYWNoZVtjYWNoZUtleV0gPSBhbmltYXRpb25Ob2RlO1xuICAgIHJldHVybiBhbmltYXRpb25Ob2RlO1xufVxuY29uc3QgY2FsY3VsYXRpb25DYWNoZSA9IHt9O1xuZnVuY3Rpb24gc3ByaW5nQ2FsY3VsYXRpb24oeyBmcm9tID0gMCwgdG8gPSAxLCBmcmFtZSwgZnBzLCBjb25maWcgPSB7fSwgfSkge1xuICAgIGNvbnN0IGNhY2hlS2V5ID0gW1xuICAgICAgICBmcm9tLFxuICAgICAgICB0byxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGZwcyxcbiAgICAgICAgY29uZmlnLmRhbXBpbmcsXG4gICAgICAgIGNvbmZpZy5tYXNzLFxuICAgICAgICBjb25maWcub3ZlcnNob290Q2xhbXBpbmcsXG4gICAgICAgIGNvbmZpZy5zdGlmZm5lc3MsXG4gICAgXS5qb2luKCctJyk7XG4gICAgaWYgKGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldKSB7XG4gICAgICAgIHJldHVybiBjYWxjdWxhdGlvbkNhY2hlW2NhY2hlS2V5XTtcbiAgICB9XG4gICAgbGV0IGFuaW1hdGlvbiA9IHtcbiAgICAgICAgbGFzdFRpbWVzdGFtcDogMCxcbiAgICAgICAgY3VycmVudDogZnJvbSxcbiAgICAgICAgdG9WYWx1ZTogdG8sXG4gICAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgICBwcmV2UG9zaXRpb246IDAsXG4gICAgfTtcbiAgICBjb25zdCBmcmFtZUNsYW1wZWQgPSBNYXRoLm1heCgwLCBmcmFtZSk7XG4gICAgY29uc3QgdW5ldmVuUmVzdCA9IGZyYW1lQ2xhbXBlZCAlIDE7XG4gICAgZm9yIChsZXQgZiA9IDA7IGYgPD0gTWF0aC5mbG9vcihmcmFtZUNsYW1wZWQpOyBmKyspIHtcbiAgICAgICAgaWYgKGYgPT09IE1hdGguZmxvb3IoZnJhbWVDbGFtcGVkKSkge1xuICAgICAgICAgICAgZiArPSB1bmV2ZW5SZXN0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWUgPSAoZiAvIGZwcykgKiAxMDAwO1xuICAgICAgICBhbmltYXRpb24gPSBhZHZhbmNlKHtcbiAgICAgICAgICAgIGFuaW1hdGlvbixcbiAgICAgICAgICAgIG5vdzogdGltZSxcbiAgICAgICAgICAgIGNvbmZpZzoge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRTcHJpbmdDb25maWcsXG4gICAgICAgICAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhbGN1bGF0aW9uQ2FjaGVbY2FjaGVLZXldID0gYW5pbWF0aW9uO1xuICAgIHJldHVybiBhbmltYXRpb247XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRoZSBmdW5jdGlvbiByZXR1cm5zIGhvdyBsb25nIGl0IHRha2VzIGZvciBhIHNwcmluZyBhbmltYXRpb24gdG8gc2V0dGxlXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9tZWFzdXJlLXNwcmluZylcbiAqL1xuZnVuY3Rpb24gbWVhc3VyZVNwcmluZyh7IGZwcywgY29uZmlnID0ge30sIHRocmVzaG9sZCA9IDAuMDA1LCBmcm9tID0gMCwgdG8gPSAxLCB9KSB7XG4gICAgaWYgKHR5cGVvZiB0aHJlc2hvbGQgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHRocmVzaG9sZCBtdXN0IGJlIGEgbnVtYmVyLCBnb3QgJHt0aHJlc2hvbGR9IG9mIHR5cGUgJHt0eXBlb2YgdGhyZXNob2xkfWApO1xuICAgIH1cbiAgICBpZiAodGhyZXNob2xkID09PSAwKSB7XG4gICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICB9XG4gICAgaWYgKHRocmVzaG9sZCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgaWYgKGlzTmFOKHRocmVzaG9sZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhyZXNob2xkIGlzIE5hTicpO1xuICAgIH1cbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZSh0aHJlc2hvbGQpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RocmVzaG9sZCBpcyBub3QgZmluaXRlJyk7XG4gICAgfVxuICAgIGlmICh0aHJlc2hvbGQgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RocmVzaG9sZCBpcyBiZWxvdyAwJyk7XG4gICAgfVxuICAgIHZhbGlkYXRlRnBzKGZwcywgJ3RvIHRoZSBtZWFzdXJlU3ByaW5nKCkgZnVuY3Rpb24nLCBmYWxzZSk7XG4gICAgY29uc3QgcmFuZ2UgPSBNYXRoLmFicyhmcm9tIC0gdG8pO1xuICAgIGxldCBmcmFtZSA9IDA7XG4gICAgbGV0IGZpbmlzaGVkRnJhbWUgPSAwO1xuICAgIGNvbnN0IGNhbGMgPSAoKSA9PiB7XG4gICAgICAgIHJldHVybiBzcHJpbmdDYWxjdWxhdGlvbih7XG4gICAgICAgICAgICBmcHMsXG4gICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICB0byxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBsZXQgYW5pbWF0aW9uID0gY2FsYygpO1xuICAgIGNvbnN0IGNhbGNEaWZmZXJlbmNlID0gKCkgPT4ge1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGFuaW1hdGlvbi5jdXJyZW50IC0gYW5pbWF0aW9uLnRvVmFsdWUpIC9cbiAgICAgICAgICAgIChyYW5nZSA9PT0gMCA/IDEgOiByYW5nZSkpO1xuICAgIH07XG4gICAgbGV0IGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIHdoaWxlIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgICBmcmFtZSsrO1xuICAgICAgICBhbmltYXRpb24gPSBjYWxjKCk7XG4gICAgICAgIGRpZmZlcmVuY2UgPSBjYWxjRGlmZmVyZW5jZSgpO1xuICAgIH1cbiAgICAvLyBTaW5jZSBzcHJpbmcgaXMgYm91bmN5LCBqdXN0IGJlY2F1c2UgaXQncyB1bmRlciB0aGUgdGhyZXNob2xkIHdlXG4gICAgLy8gY2Fubm90IGJlIHN1cmUgaXQncyBkb25lLiBXZSBuZWVkIHRvIGFuaW1hdGUgZnVydGhlciB1bnRpbCBpdCBzdGF5cyBpbiB0aGVcbiAgICAvLyB0aHJlc2hvbGQgZm9yLCBzYXksIDIwIGZyYW1lcy5cbiAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWU7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyMDsgaSsrKSB7XG4gICAgICAgIGZyYW1lKys7XG4gICAgICAgIGFuaW1hdGlvbiA9IGNhbGMoKTtcbiAgICAgICAgZGlmZmVyZW5jZSA9IGNhbGNEaWZmZXJlbmNlKCk7XG4gICAgICAgIGlmIChkaWZmZXJlbmNlID49IHRocmVzaG9sZCkge1xuICAgICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgICBmaW5pc2hlZEZyYW1lID0gZnJhbWUgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hlZEZyYW1lO1xufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBDYWxjdWxhdGVzIGEgcG9zaXRpb24gYmFzZWQgb24gcGh5c2ljYWwgcGFyYW1ldGVycywgc3RhcnQgYW5kIGVuZCB2YWx1ZSwgYW5kIHRpbWUuXG4gKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9zcHJpbmcpXG4gKiBAcGFyYW0ge251bWJlcn0gZnJhbWUgVGhlIGN1cnJlbnQgdGltZSB2YWx1ZS4gTW9zdCBvZiB0aGUgdGltZSB5b3Ugd2FudCB0byBwYXNzIGluIHRoZSByZXR1cm4gdmFsdWUgb2YgdXNlQ3VycmVudEZyYW1lLlxuICogQHBhcmFtIHtudW1iZXJ9IGZwcyBUaGUgZnJhbWVyYXRlIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gcnVucy4gUGFzcyBpbiB0aGUgdmFsdWUgb2J0YWluZWQgYnkgYHVzZVZpZGVvQ29uZmlnKClgLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gcmV2ZXJzZSBXaGV0aGVyIHRoZSBhbmltYXRpb24gcGxheXMgaW4gcmV2ZXJzZSBvciBub3QuIERlZmF1bHQgYGZhbHNlYC5cbiAqIEBwYXJhbSB7P09iamVjdH0gY29uZmlnIG9wdGlvbmFsIG9iamVjdCB0aGF0IGFsbG93cyB5b3UgdG8gY3VzdG9taXplIHRoZSBwaHlzaWNhbCBwcm9wZXJ0aWVzIG9mIHRoZSBhbmltYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXNzPTFdIFRoZSB3ZWlnaHQgb2YgdGhlIHNwcmluZy4gSWYgeW91IHJlZHVjZSB0aGUgbWFzcywgdGhlIGFuaW1hdGlvbiBiZWNvbWVzIGZhc3RlciFcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLmRhbXBpbmc9MTBdIEhvdyBoYXJkIHRoZSBhbmltYXRpb24gZGVjZWxlcmF0ZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5zdGlmZm5lc3M9MTAwXSBBZmZlY3RzIGJvdW5jaW5lc3Mgb2YgdGhlIGFuaW1hdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvbmZpZy5vdmVyc2hvb3RDbGFtcGluZz1mYWxzZV0gV2hldGhlciB0byBwcmV2ZW50IHRoZSBhbmltYXRpb24gZ29pbmcgYmV5b25kIHRoZSB0YXJnZXQgdmFsdWUuXG4gKiBAcGFyYW0gez9udW1iZXJ9IFtjb25maWcuZnJvbV0gVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGFuaW1hdGlvbi4gRGVmYXVsdCBgMGBcbiAqIEBwYXJhbSB7P251bWJlcn0gW2NvbmZpZy50b10gVGhlIGVuZCB2YWx1ZSBvZiB0aGUgYW5pbWF0aW9uLiBEZWZhdWx0IGAxYFxuICogQHBhcmFtIHs/bnVtYmVyfSBbY29uZmlnLmR1cmF0aW9uSW5GcmFtZXNdIFN0cmV0Y2ggdGhlIGR1cmF0aW9uIG9mIGFuIGFuaW1hdGlvbiB0byAgYSBzZXQgdmFsdWUuLiBEZWZhdWx0IGB1bmRlZmluZWRgXG4gKiBAcGFyYW0gez9udW1iZXJ9IFtjb25maWcuZHVyYXRpb25UaHJlc2hvbGRdIEhvdyBjbG9zZSB0byB0aGUgZW5kIHRoZSBhbmltYXRpb24gaXMgY29uc2lkZXJlZCB0byBiZSBkb25lLiBEZWZhdWx0IGAwLjAwNWBcbiAqIEBwYXJhbSB7P251bWJlcn0gW2NvbmZpZy5kZWxheV0gRGVsYXkgdGhlIGFuaW1hdGlvbiBmb3IgdGhpcyBhbW91bnQgb2YgZnJhbWVzLiBEZWZhdWx0IGAwYFxuICovXG5mdW5jdGlvbiBzcHJpbmcoeyBmcmFtZTogcGFzc2VkRnJhbWUsIGZwcywgY29uZmlnID0ge30sIGZyb20gPSAwLCB0byA9IDEsIGR1cmF0aW9uSW5GcmFtZXM6IHBhc3NlZER1cmF0aW9uSW5GcmFtZXMsIGR1cmF0aW9uUmVzdFRocmVzaG9sZCwgZGVsYXkgPSAwLCByZXZlcnNlID0gZmFsc2UsIH0pIHtcbiAgICB2YWxpZGF0ZVNwcmluZ0R1cmF0aW9uKHBhc3NlZER1cmF0aW9uSW5GcmFtZXMpO1xuICAgIHZhbGlkYXRlRnJhbWUoe1xuICAgICAgICBmcmFtZTogcGFzc2VkRnJhbWUsXG4gICAgICAgIGR1cmF0aW9uSW5GcmFtZXM6IEluZmluaXR5LFxuICAgICAgICBhbGxvd0Zsb2F0czogdHJ1ZSxcbiAgICB9KTtcbiAgICB2YWxpZGF0ZUZwcyhmcHMsICd0byBzcHJpbmcoKScsIGZhbHNlKTtcbiAgICBjb25zdCBuZWVkc1RvQ2FsY3VsYXRlTmF0dXJhbER1cmF0aW9uID0gcmV2ZXJzZSB8fCB0eXBlb2YgcGFzc2VkRHVyYXRpb25JbkZyYW1lcyAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgY29uc3QgbmF0dXJhbER1cmF0aW9uID0gbmVlZHNUb0NhbGN1bGF0ZU5hdHVyYWxEdXJhdGlvblxuICAgICAgICA/IG1lYXN1cmVTcHJpbmcoe1xuICAgICAgICAgICAgZnBzLFxuICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgdGhyZXNob2xkOiBkdXJhdGlvblJlc3RUaHJlc2hvbGQsXG4gICAgICAgIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG5hdHVyYWxEdXJhdGlvbkdldHRlciA9IG5lZWRzVG9DYWxjdWxhdGVOYXR1cmFsRHVyYXRpb25cbiAgICAgICAgPyB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IG5hdHVyYWxEdXJhdGlvbixcbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlkIG5vdCBjYWxjdWxhdGUgbmF0dXJhbCBkdXJhdGlvbiwgdGhpcyBpcyBhbiBlcnJvciB3aXRoIFJlbW90aW9uLiBQbGVhc2UgcmVwb3J0Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIGNvbnN0IGZyYW1lID0gKHJldmVyc2VcbiAgICAgICAgPyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyAhPT0gbnVsbCAmJiBwYXNzZWREdXJhdGlvbkluRnJhbWVzICE9PSB2b2lkIDAgPyBwYXNzZWREdXJhdGlvbkluRnJhbWVzIDogbmF0dXJhbER1cmF0aW9uR2V0dGVyLmdldCgpKSAtIHBhc3NlZEZyYW1lXG4gICAgICAgIDogcGFzc2VkRnJhbWUpIC0gKHJldmVyc2UgPyAtZGVsYXkgOiBkZWxheSk7XG4gICAgY29uc3Qgc3ByID0gc3ByaW5nQ2FsY3VsYXRpb24oe1xuICAgICAgICBmcHMsXG4gICAgICAgIGZyYW1lOiBwYXNzZWREdXJhdGlvbkluRnJhbWVzID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gZnJhbWVcbiAgICAgICAgICAgIDogZnJhbWUgLyAocGFzc2VkRHVyYXRpb25JbkZyYW1lcyAvIG5hdHVyYWxEdXJhdGlvbkdldHRlci5nZXQoKSksXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgZnJvbSxcbiAgICAgICAgdG8sXG4gICAgfSk7XG4gICAgaWYgKCFjb25maWcub3ZlcnNob290Q2xhbXBpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNwci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAodG8gPj0gZnJvbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oc3ByLmN1cnJlbnQsIHRvKTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGgubWF4KHNwci5jdXJyZW50LCB0byk7XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIEEgYDxTdGlsbCAvPmAgaXMgYSBgPENvbXBvc2l0aW9uIC8+YCB0aGF0IGlzIG9ubHkgMSBmcmFtZSBsb25nLlxuICogQHNlZSBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cucmVtb3Rpb24uZGV2L2RvY3Mvc3RpbGwpXG4gKi9cbmNvbnN0IFN0aWxsID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgbmV3UHJvcHMgPSB7XG4gICAgICAgIC4uLnByb3BzLFxuICAgICAgICBkdXJhdGlvbkluRnJhbWVzOiAxLFxuICAgICAgICBmcHM6IDEsXG4gICAgfTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFR5cGVTY3JpcHQgZG9lcyBub3QgdW5kZXJzdGFuZCBpdCwgYnV0IHNob3VsZCBzdGlsbCBmYWlsIG9uIHR5cGUgbWlzbWF0Y2hcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudCgoQ29tcG9zaXRpb24pLCBuZXdQcm9wcyk7XG59O1xuXG5jb25zdCBPZmZ0aHJlYWRWaWRlb0ZvclJlbmRlcmluZyA9ICh7IG9uRXJyb3IsIHZvbHVtZTogdm9sdW1lUHJvcCwgcGxheWJhY2tSYXRlLCBzcmMsIG11dGVkLCBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIsIHRyYW5zcGFyZW50ID0gZmFsc2UsIHRvbmVGcmVxdWVuY3ksIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBhYnNvbHV0ZUZyYW1lID0gdXNlVGltZWxpbmVQb3NpdGlvbigpO1xuICAgIGNvbnN0IGZyYW1lID0gdXNlQ3VycmVudEZyYW1lKCk7XG4gICAgY29uc3Qgdm9sdW1lUHJvcHNGcmFtZSA9IHVzZUZyYW1lRm9yVm9sdW1lUHJvcCgpO1xuICAgIGNvbnN0IHZpZGVvQ29uZmlnID0gdXNlVW5zYWZlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCBzZXF1ZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFNlcXVlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgbWVkaWFTdGFydHNBdCA9IHVzZU1lZGlhU3RhcnRzQXQoKTtcbiAgICBjb25zdCB7IHJlZ2lzdGVyUmVuZGVyQXNzZXQsIHVucmVnaXN0ZXJSZW5kZXJBc3NldCB9ID0gdXNlQ29udGV4dChSZW5kZXJBc3NldE1hbmFnZXIpO1xuICAgIGlmICghc3JjKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vIGBzcmNgIHdhcyBwYXNzZWQgdG8gPE9mZnRocmVhZFZpZGVvPi4nKTtcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgYSBzdHJpbmcgdGhhdCdzIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZSBmb3IgdGhpcyBhc3NldFxuICAgIC8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIHRoZSBzYW1lIG9uIGFsbCB0aHJlYWRzXG4gICAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IGBvZmZ0aHJlYWR2aWRlby0ke3JhbmRvbShzcmMgIT09IG51bGwgJiYgc3JjICE9PSB2b2lkIDAgPyBzcmMgOiAnJyl9LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmN1bXVsYXRlZEZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LnJlbGF0aXZlRnJvbX0tJHtzZXF1ZW5jZUNvbnRleHQgPT09IG51bGwgfHwgc2VxdWVuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzZXF1ZW5jZUNvbnRleHQuZHVyYXRpb25JbkZyYW1lc31gLCBbXG4gICAgICAgIHNyYyxcbiAgICAgICAgc2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmN1bXVsYXRlZEZyb20sXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5yZWxhdGl2ZUZyb20sXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5kdXJhdGlvbkluRnJhbWVzLFxuICAgIF0pO1xuICAgIGlmICghdmlkZW9Db25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2aWRlbyBjb25maWcgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgICAgICBtZWRpYVZvbHVtZTogMSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgIT09IG51bGwgJiYgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyICE9PSB2b2lkIDAgPyBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgOiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzcmMgcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11dGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhzcmMpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgICAgICAgIHZvbHVtZSxcbiAgICAgICAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgIT09IG51bGwgJiYgcGxheWJhY2tSYXRlICE9PSB2b2lkIDAgPyBwbGF5YmFja1JhdGUgOiAxLFxuICAgICAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgIT09IG51bGwgJiYgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyICE9PSB2b2lkIDAgPyBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgOiBmYWxzZSxcbiAgICAgICAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgIT09IG51bGwgJiYgdG9uZUZyZXF1ZW5jeSAhPT0gdm9pZCAwID8gdG9uZUZyZXF1ZW5jeSA6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgICB9LCBbXG4gICAgICAgIG11dGVkLFxuICAgICAgICBzcmMsXG4gICAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICAgIGlkLFxuICAgICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICAgIHZvbHVtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGFic29sdXRlRnJhbWUsXG4gICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgICAgICB0b25lRnJlcXVlbmN5LFxuICAgIF0pO1xuICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiAoZ2V0RXhwZWN0ZWRNZWRpYUZyYW1lVW5jb3JyZWN0ZWQoe1xuICAgICAgICAgICAgZnJhbWUsXG4gICAgICAgICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgICAgICAgc3RhcnRGcm9tOiAtbWVkaWFTdGFydHNBdCxcbiAgICAgICAgfSkgLyB2aWRlb0NvbmZpZy5mcHMpO1xuICAgIH0sIFtmcmFtZSwgbWVkaWFTdGFydHNBdCwgcGxheWJhY2tSYXRlLCB2aWRlb0NvbmZpZy5mcHNdKTtcbiAgICBjb25zdCBhY3R1YWxTcmMgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGBodHRwOi8vbG9jYWxob3N0OiR7d2luZG93LnJlbW90aW9uX3Byb3h5UG9ydH0vcHJveHk/c3JjPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGdldEFic29sdXRlU3JjKHNyYykpfSZ0aW1lPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGN1cnJlbnRUaW1lKX0mdHJhbnNwYXJlbnQ9JHtTdHJpbmcodHJhbnNwYXJlbnQpfWA7XG4gICAgfSwgW2N1cnJlbnRUaW1lLCBzcmMsIHRyYW5zcGFyZW50XSk7XG4gICAgY29uc3Qgb25FcnIgPSB1c2VDYWxsYmFjaygoZSkgPT4ge1xuICAgICAgICBpZiAob25FcnJvcikge1xuICAgICAgICAgICAgb25FcnJvciA9PT0gbnVsbCB8fCBvbkVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkVycm9yKGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FuY2VsUmVuZGVyKCdGYWlsZWQgdG8gbG9hZCBpbWFnZSB3aXRoIHNyYyAnICsgYWN0dWFsU3JjKTtcbiAgICAgICAgfVxuICAgIH0sIFthY3R1YWxTcmMsIG9uRXJyb3JdKTtcbiAgICBjb25zdCBjbGFzc05hbWUgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIFtPRkZUSFJFQURfVklERU9fQ0xBU1NfTkFNRSwgcHJvcHMuY2xhc3NOYW1lXVxuICAgICAgICAgICAgLmZpbHRlcih0cnV0aHkpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH0sIFtwcm9wcy5jbGFzc05hbWVdKTtcbiAgICByZXR1cm4gKGpzeChJbWcsIHsgc3JjOiBhY3R1YWxTcmMsIGNsYXNzTmFtZTogY2xhc3NOYW1lLCAuLi5wcm9wcywgb25FcnJvcjogb25FcnIgfSkpO1xufTtcblxuY29uc3QgVmlkZW9Gb3JEZXZlbG9wbWVudFJlZkZvcndhcmRpbmdGdW5jdGlvbiA9IChwcm9wcywgcmVmKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB2aWRlb1JlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB2b2x1bWVQcm9wRnJhbWUgPSB1c2VGcmFtZUZvclZvbHVtZVByb3AoKTtcbiAgICBjb25zdCB7IGZwcywgZHVyYXRpb25JbkZyYW1lcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCBwYXJlbnRTZXF1ZW5jZSA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCB7IHZvbHVtZSwgbXV0ZWQsIHBsYXliYWNrUmF0ZSwgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvciwgc3JjLCBvbkR1cmF0aW9uLCBcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgYWNjZXB0YWJsZVRpbWVTaGlmdCwgYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcywgdG9uZUZyZXF1ZW5jeSwgLi4ubmF0aXZlUHJvcHMgfSA9IHByb3BzO1xuICAgIGlmICh0eXBlb2YgYWNjZXB0YWJsZVRpbWVTaGlmdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhY2NlcHRhYmxlVGltZVNoaWZ0IGhhcyBiZWVuIHJlbW92ZWQuIFVzZSBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzIGluc3RlYWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGFjdHVhbFZvbHVtZSA9IHVzZU1lZGlhVGFnVm9sdW1lKHZpZGVvUmVmKTtcbiAgICBjb25zdCBbbWVkaWFWb2x1bWVdID0gdXNlTWVkaWFWb2x1bWVTdGF0ZSgpO1xuICAgIGNvbnN0IFttZWRpYU11dGVkXSA9IHVzZU1lZGlhTXV0ZWRTdGF0ZSgpO1xuICAgIHVzZU1lZGlhSW5UaW1lbGluZSh7XG4gICAgICAgIG1lZGlhUmVmOiB2aWRlb1JlZixcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgbWVkaWFUeXBlOiAndmlkZW8nLFxuICAgICAgICBzcmMsXG4gICAgICAgIHBsYXliYWNrUmF0ZTogKF9hID0gcHJvcHMucGxheWJhY2tSYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgIH0pO1xuICAgIHVzZVN5bmNWb2x1bWVXaXRoTWVkaWFUYWcoe1xuICAgICAgICB2b2x1bWVQcm9wRnJhbWUsXG4gICAgICAgIGFjdHVhbFZvbHVtZSxcbiAgICAgICAgdm9sdW1lLFxuICAgICAgICBtZWRpYVZvbHVtZSxcbiAgICAgICAgbWVkaWFSZWY6IHZpZGVvUmVmLFxuICAgIH0pO1xuICAgIHVzZU1lZGlhUGxheWJhY2soe1xuICAgICAgICBtZWRpYVJlZjogdmlkZW9SZWYsXG4gICAgICAgIHNyYyxcbiAgICAgICAgbWVkaWFUeXBlOiAndmlkZW8nLFxuICAgICAgICBwbGF5YmFja1JhdGU6IChfYiA9IHByb3BzLnBsYXliYWNrUmF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMSxcbiAgICAgICAgb25seVdhcm5Gb3JNZWRpYVNlZWtpbmdFcnJvcixcbiAgICAgICAgYWNjZXB0YWJsZVRpbWVzaGlmdDogYWNjZXB0YWJsZVRpbWVTaGlmdEluU2Vjb25kcyAhPT0gbnVsbCAmJiBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzICE9PSB2b2lkIDAgPyBhY2NlcHRhYmxlVGltZVNoaWZ0SW5TZWNvbmRzIDogREVGQVVMVF9BQ0NFUFRBQkxFX1RJTUVTSElGVCxcbiAgICB9KTtcbiAgICBjb25zdCBhY3R1YWxGcm9tID0gcGFyZW50U2VxdWVuY2VcbiAgICAgICAgPyBwYXJlbnRTZXF1ZW5jZS5yZWxhdGl2ZUZyb20gKyBwYXJlbnRTZXF1ZW5jZS5jdW11bGF0ZWRGcm9tXG4gICAgICAgIDogMDtcbiAgICBjb25zdCBkdXJhdGlvbiA9IHBhcmVudFNlcXVlbmNlXG4gICAgICAgID8gTWF0aC5taW4ocGFyZW50U2VxdWVuY2UuZHVyYXRpb25JbkZyYW1lcywgZHVyYXRpb25JbkZyYW1lcylcbiAgICAgICAgOiBkdXJhdGlvbkluRnJhbWVzO1xuICAgIGNvbnN0IGFjdHVhbFNyYyA9IHVzZUFwcGVuZFZpZGVvRnJhZ21lbnQoe1xuICAgICAgICBhY3R1YWxTcmM6IHVzZVByZWxvYWQoc3JjKSxcbiAgICAgICAgYWN0dWFsRnJvbSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGZwcyxcbiAgICB9KTtcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gdmlkZW9SZWYuY3VycmVudDtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9jY3VycmVkIGluIHZpZGVvJywgY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIGlzIGhhbmRsaW5nIHRoZSBlcnJvciwgd2UgZG9uJ3QgY2F1c2UgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIGlmIChwcm9wcy5vbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3NyY306IENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9IC0gJHsoX2EgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgfSwgW3Byb3BzLm9uRXJyb3IsIHNyY10pO1xuICAgIGNvbnN0IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2sgPSB1c2VSZWYoKTtcbiAgICBjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLmN1cnJlbnQgPSBvbkR1cmF0aW9uO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB2aWRlb1JlZjtcbiAgICAgICAgaWYgKCFjdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIChfYSA9IGN1cnJlbnRPbkR1cmF0aW9uQ2FsbGJhY2suY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoY3VycmVudE9uRHVyYXRpb25DYWxsYmFjaywgc3JjLCBjdXJyZW50LmR1cmF0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkxvYWRlZE1ldGFkYXRhID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gY3VycmVudE9uRHVyYXRpb25DYWxsYmFjay5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjdXJyZW50T25EdXJhdGlvbkNhbGxiYWNrLCBzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICB9O1xuICAgICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgb25Mb2FkZWRNZXRhZGF0YSk7XG4gICAgICAgIH07XG4gICAgfSwgW3NyY10pO1xuICAgIHJldHVybiAoanN4KFwidmlkZW9cIiwgeyByZWY6IHZpZGVvUmVmLCBcbiAgICAgICAgLy8gV2l0aG91dCB0aGlzLCBvbiBpT1MgU2FmYXJpLCB0aGUgdmlkZW8gY2Fubm90IGJlIHNlZWtlZC5cbiAgICAgICAgLy8gaWYgYSBzZWVrIGlzIHRyaWdnZXJlZCBiZWZvcmUgYGxvYWRlZG1ldGFkYXRhYCBpcyBmaXJlZCxcbiAgICAgICAgLy8gdGhlIHZpZGVvIHdpbGwgbm90IHNlZWssIGV2ZW4gaWYgYGxvYWRlZG1ldGFkYXRhYCBpcyBmaXJlZCBhZnRlcndhcmRzLlxuICAgICAgICBwcmVsb2FkOiBpc0lvc1NhZmFyaSgpID8gJ21ldGFkYXRhJyA6ICdhdXRvJywgbXV0ZWQ6IG11dGVkIHx8IG1lZGlhTXV0ZWQsIHBsYXlzSW5saW5lOiB0cnVlLCBzcmM6IGFjdHVhbFNyYywgLi4ubmF0aXZlUHJvcHMgfSkpO1xufTtcbi8vIENvcHkgdHlwZXMgZnJvbSBmb3J3YXJkUmVmIGJ1dCBub3QgbmVjZXNzYXJ5IHRvIHJlbW92ZSByZWZcbmNvbnN0IFZpZGVvRm9yRGV2ZWxvcG1lbnQgPSBmb3J3YXJkUmVmKFZpZGVvRm9yRGV2ZWxvcG1lbnRSZWZGb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCBpbXBvcnRzIGFuZCBkaXNwbGF5cyBhIHZpZGVvLCBzaW1pbGFyIHRvIDxWaWRlbyAvPi4gRHVyaW5nIHJlbmRlcmluZywgaXQgZXh0cmFjdHMgdGhlIGV4YWN0IGZyYW1lIGZyb20gdGhlIHZpZGVvIGFuZCBkaXNwbGF5cyBpdCBpbiBhbiA8aW1nPiB0YWdcbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL29mZnRocmVhZHZpZGVvKVxuICovXG5jb25zdCBPZmZ0aHJlYWRWaWRlbyA9IChwcm9wcykgPT4ge1xuICAgIC8vIFNob3VsZCBvbmx5IGRlc3RydWN0IGBzdGFydEZyb21gIGFuZCBgZW5kQXRgIGZyb20gcHJvcHMsXG4gICAgLy8gcmVzdCBnZXRzIGRyaWxsZWQgZG93blxuICAgIGNvbnN0IHsgc3RhcnRGcm9tLCBlbmRBdCwgLi4ub3RoZXJQcm9wcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgZW52aXJvbm1lbnQgPSBnZXRSZW1vdGlvbkVudmlyb25tZW50KCk7XG4gICAgY29uc3Qgb25EdXJhdGlvbiA9IHVzZUNhbGxiYWNrKCgpID0+IHVuZGVmaW5lZCwgW10pO1xuICAgIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPE9mZnRocmVhZFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pbWFnZUZvcm1hdCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPE9mZnRocmVhZFZpZGVvPlxcYCB0YWcgZG9lcyBubyBsb25nZXIgYWNjZXB0IFxcYGltYWdlRm9ybWF0XFxgLiBVc2UgdGhlIFxcYHRyYW5zcGFyZW50XFxgIHByb3AgaWYgeW91IHdhbnQgdG8gcmVuZGVyIGEgdHJhbnNwYXJlbnQgdmlkZW8uYCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3RhcnRGcm9tICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZW5kQXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhbGlkYXRlU3RhcnRGcm9tUHJvcHMoc3RhcnRGcm9tLCBlbmRBdCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0RnJvbUZyYW1lTm8gPSBzdGFydEZyb20gIT09IG51bGwgJiYgc3RhcnRGcm9tICE9PSB2b2lkIDAgPyBzdGFydEZyb20gOiAwO1xuICAgICAgICBjb25zdCBlbmRBdEZyYW1lTm8gPSBlbmRBdCAhPT0gbnVsbCAmJiBlbmRBdCAhPT0gdm9pZCAwID8gZW5kQXQgOiBJbmZpbml0eTtcbiAgICAgICAgcmV0dXJuIChqc3goU2VxdWVuY2UsIHsgbGF5b3V0OiBcIm5vbmVcIiwgZnJvbTogMCAtIHN0YXJ0RnJvbUZyYW1lTm8sIHNob3dJblRpbWVsaW5lOiBmYWxzZSwgZHVyYXRpb25JbkZyYW1lczogZW5kQXRGcmFtZU5vLCBjaGlsZHJlbjoganN4KE9mZnRocmVhZFZpZGVvLCB7IC4uLm90aGVyUHJvcHMgfSkgfSkpO1xuICAgIH1cbiAgICB2YWxpZGF0ZU1lZGlhUHJvcHMocHJvcHMsICdWaWRlbycpO1xuICAgIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgICAgICByZXR1cm4ganN4KE9mZnRocmVhZFZpZGVvRm9yUmVuZGVyaW5nLCB7IC4uLm90aGVyUHJvcHMgfSk7XG4gICAgfVxuICAgIGNvbnN0IHsgdHJhbnNwYXJlbnQsIC4uLndpdGhvdXRUcmFuc3BhcmVudCB9ID0gb3RoZXJQcm9wcztcbiAgICByZXR1cm4gKGpzeChWaWRlb0ZvckRldmVsb3BtZW50LCB7IG9uRHVyYXRpb246IG9uRHVyYXRpb24sIG9ubHlXYXJuRm9yTWVkaWFTZWVraW5nRXJyb3I6IHRydWUsIC4uLndpdGhvdXRUcmFuc3BhcmVudCB9KSk7XG59O1xuXG5jb25zdCBWaWRlb0ZvclJlbmRlcmluZ0ZvcndhcmRGdW5jdGlvbiA9ICh7IG9uRXJyb3IsIHZvbHVtZTogdm9sdW1lUHJvcCwgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLCBwbGF5YmFja1JhdGUsIG9uRHVyYXRpb24sIHRvbmVGcmVxdWVuY3ksIC4uLnByb3BzIH0sIHJlZikgPT4ge1xuICAgIGNvbnN0IGFic29sdXRlRnJhbWUgPSB1c2VUaW1lbGluZVBvc2l0aW9uKCk7XG4gICAgY29uc3QgZnJhbWUgPSB1c2VDdXJyZW50RnJhbWUoKTtcbiAgICBjb25zdCB2b2x1bWVQcm9wc0ZyYW1lID0gdXNlRnJhbWVGb3JWb2x1bWVQcm9wKCk7XG4gICAgY29uc3QgdmlkZW9Db25maWcgPSB1c2VVbnNhZmVWaWRlb0NvbmZpZygpO1xuICAgIGNvbnN0IHZpZGVvUmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHNlcXVlbmNlQ29udGV4dCA9IHVzZUNvbnRleHQoU2VxdWVuY2VDb250ZXh0KTtcbiAgICBjb25zdCBtZWRpYVN0YXJ0c0F0ID0gdXNlTWVkaWFTdGFydHNBdCgpO1xuICAgIGNvbnN0IGVudmlyb25tZW50ID0gZ2V0UmVtb3Rpb25FbnZpcm9ubWVudCgpO1xuICAgIGNvbnN0IHsgcmVnaXN0ZXJSZW5kZXJBc3NldCwgdW5yZWdpc3RlclJlbmRlckFzc2V0IH0gPSB1c2VDb250ZXh0KFJlbmRlckFzc2V0TWFuYWdlcik7XG4gICAgLy8gR2VuZXJhdGUgYSBzdHJpbmcgdGhhdCdzIGFzIHVuaXF1ZSBhcyBwb3NzaWJsZSBmb3IgdGhpcyBhc3NldFxuICAgIC8vIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIHRoZSBzYW1lIG9uIGFsbCB0aHJlYWRzXG4gICAgY29uc3QgaWQgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gYHZpZGVvLSR7cmFuZG9tKChfYSA9IHByb3BzLnNyYykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpfS0ke3NlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5jdW11bGF0ZWRGcm9tfS0ke3NlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5yZWxhdGl2ZUZyb219LSR7c2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmR1cmF0aW9uSW5GcmFtZXN9YDtcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLnNyYyxcbiAgICAgICAgc2VxdWVuY2VDb250ZXh0ID09PSBudWxsIHx8IHNlcXVlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2VxdWVuY2VDb250ZXh0LmN1bXVsYXRlZEZyb20sXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5yZWxhdGl2ZUZyb20sXG4gICAgICAgIHNlcXVlbmNlQ29udGV4dCA9PT0gbnVsbCB8fCBzZXF1ZW5jZUNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcXVlbmNlQ29udGV4dC5kdXJhdGlvbkluRnJhbWVzLFxuICAgIF0pO1xuICAgIGlmICghdmlkZW9Db25maWcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2aWRlbyBjb25maWcgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgdm9sdW1lID0gZXZhbHVhdGVWb2x1bWUoe1xuICAgICAgICB2b2x1bWU6IHZvbHVtZVByb3AsXG4gICAgICAgIGZyYW1lOiB2b2x1bWVQcm9wc0ZyYW1lLFxuICAgICAgICBtZWRpYVZvbHVtZTogMSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgIT09IG51bGwgJiYgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyICE9PSB2b2lkIDAgPyBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgOiBmYWxzZSxcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLnNyYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzcmMgcGFzc2VkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLm11dGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZvbHVtZSA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3aW5kb3cucmVtb3Rpb25fYXVkaW9FbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXJSZW5kZXJBc3NldCh7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgc3JjOiBnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpLFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBmcmFtZTogYWJzb2x1dGVGcmFtZSxcbiAgICAgICAgICAgIHZvbHVtZSxcbiAgICAgICAgICAgIG1lZGlhRnJhbWU6IGZyYW1lLFxuICAgICAgICAgICAgcGxheWJhY2tSYXRlOiBwbGF5YmFja1JhdGUgIT09IG51bGwgJiYgcGxheWJhY2tSYXRlICE9PSB2b2lkIDAgPyBwbGF5YmFja1JhdGUgOiAxLFxuICAgICAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyOiBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgIT09IG51bGwgJiYgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyICE9PSB2b2lkIDAgPyBhbGxvd0FtcGxpZmljYXRpb25EdXJpbmdSZW5kZXIgOiBmYWxzZSxcbiAgICAgICAgICAgIHRvbmVGcmVxdWVuY3k6IHRvbmVGcmVxdWVuY3kgIT09IG51bGwgJiYgdG9uZUZyZXF1ZW5jeSAhPT0gdm9pZCAwID8gdG9uZUZyZXF1ZW5jeSA6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4gdW5yZWdpc3RlclJlbmRlckFzc2V0KGlkKTtcbiAgICB9LCBbXG4gICAgICAgIHByb3BzLm11dGVkLFxuICAgICAgICBwcm9wcy5zcmMsXG4gICAgICAgIHJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICAgIGlkLFxuICAgICAgICB1bnJlZ2lzdGVyUmVuZGVyQXNzZXQsXG4gICAgICAgIHZvbHVtZSxcbiAgICAgICAgZnJhbWUsXG4gICAgICAgIGFic29sdXRlRnJhbWUsXG4gICAgICAgIHBsYXliYWNrUmF0ZSxcbiAgICAgICAgYWxsb3dBbXBsaWZpY2F0aW9uRHVyaW5nUmVuZGVyLFxuICAgICAgICB0b25lRnJlcXVlbmN5LFxuICAgIF0pO1xuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiB2aWRlb1JlZi5jdXJyZW50O1xuICAgIH0sIFtdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXdpbmRvdy5yZW1vdGlvbl92aWRlb0VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHZpZGVvUmVmO1xuICAgICAgICBpZiAoIWN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50VGltZSA9ICgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0TWVkaWFUaW1lKHtcbiAgICAgICAgICAgICAgICBmcHM6IHZpZGVvQ29uZmlnLmZwcyxcbiAgICAgICAgICAgICAgICBmcmFtZSxcbiAgICAgICAgICAgICAgICBzcmM6IHByb3BzLnNyYyxcbiAgICAgICAgICAgICAgICBwbGF5YmFja1JhdGU6IHBsYXliYWNrUmF0ZSB8fCAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0RnJvbTogLW1lZGlhU3RhcnRzQXQsXG4gICAgICAgICAgICAgICAgbWVkaWFUeXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGRlbGF5UmVuZGVyKGBSZW5kZXJpbmcgPFZpZGVvIC8+IHdpdGggc3JjPVwiJHtwcm9wcy5zcmN9XCJgKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAndGVzdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXBwcm94aW1hdGVseVRoZVNhbWUoY3VycmVudC5jdXJyZW50VGltZSwgY3VycmVudFRpbWUpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWFkeVN0YXRlID49IDIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZVJlbmRlcihoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxvYWRlZERhdGFIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgbG9hZGVkRGF0YUhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkZWRkYXRhJywgbG9hZGVkRGF0YUhhbmRsZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50LmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgICAgIGNvbnN0IHNlZWtlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB3YXJuQWJvdXROb25TZWVrYWJsZU1lZGlhKGN1cnJlbnQsICdleGNlcHRpb24nKTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubmF2aWdhdG9yLnBsYXRmb3JtLnN0YXJ0c1dpdGgoJ01hYycpKSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wcm92ZSBtZTogVGhpcyBpcyBlbnN1cmVzIGZyYW1lIHBlcmZlY3RuZXNzIGJ1dCBzbG93cyBkb3duIHJlbmRlci5cbiAgICAgICAgICAgICAgICAvLyBQbGVhc2Ugc2VlIHRoaXMgaXNzdWUgZm9yIGNvbnRleHQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9yZW1vdGlvbi1kZXYvcmVtb3Rpb24vaXNzdWVzLzIwMFxuICAgICAgICAgICAgICAgIC8vIE9ubHkgYWZmZWN0cyBtYWNPUyBzaW5jZSBpdCB1c2VzIFZpZGVvVG9vbGJveCBkZWNvZGluZy5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdzZWVrZWQnLCBzZWVrZWRIYW5kbGVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgIGNvbnN0IGVuZGVkSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnRpbnVlUmVuZGVyKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBlbmRlZEhhbmRsZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgZXJyb3JIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5lcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIG9jY3VycmVkIGluIHZpZGVvJywgY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LmVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB1c2VyIGlzIGhhbmRsaW5nIHRoZSBlcnJvciwgd2UgZG9uJ3QgY2F1c2UgYW4gdW5oYW5kbGVkIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgYnJvd3NlciB0aHJldyBhbiBlcnJvciB3aGlsZSBwbGF5aW5nIHRoZSB2aWRlbyAke3Byb3BzLnNyY306IENvZGUgJHtjdXJyZW50LmVycm9yLmNvZGV9IC0gJHsoX2EgPSBjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlfS4gU2VlIGh0dHBzOi8vcmVtb3Rpb24uZGV2L2RvY3MvbWVkaWEtcGxheWJhY2stZXJyb3IgZm9yIGhlbHAuIFBhc3MgYW4gb25FcnJvcigpIHByb3AgdG8gaGFuZGxlIHRoZSBlcnJvci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJyb3dzZXIgdGhyZXcgYW4gZXJyb3InKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAvLyBJZiB2aWRlbyBza2lwcyB0byBhbm90aGVyIGZyYW1lIG9yIHVubW91bnRzLCB3ZSBjbGVhciB0aGUgY3JlYXRlZCBoYW5kbGVcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZW5kZWQnLCBlbmRlZEhhbmRsZXIpO1xuICAgICAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9ySGFuZGxlcik7XG4gICAgICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3NlZWtlZCcsIHNlZWtlZEhhbmRsZXIpO1xuICAgICAgICAgICAgY29udGludWVSZW5kZXIoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHZvbHVtZVByb3BzRnJhbWUsXG4gICAgICAgIHByb3BzLnNyYyxcbiAgICAgICAgcGxheWJhY2tSYXRlLFxuICAgICAgICB2aWRlb0NvbmZpZy5mcHMsXG4gICAgICAgIGZyYW1lLFxuICAgICAgICBtZWRpYVN0YXJ0c0F0LFxuICAgICAgICBvbkVycm9yLFxuICAgIF0pO1xuICAgIGNvbnN0IHsgc3JjIH0gPSBwcm9wcztcbiAgICAvLyBJZiB2aWRlbyBzb3VyY2Ugc3dpdGNoZXMsIG1ha2UgbmV3IGhhbmRsZVxuICAgIGlmIChlbnZpcm9ubWVudC5pc1JlbmRlcmluZykge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgdXNlTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Rlc3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3SGFuZGxlID0gZGVsYXlSZW5kZXIoJ0xvYWRpbmcgPFZpZGVvPiBkdXJhdGlvbiB3aXRoIHNyYz0nICsgc3JjKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdmlkZW9SZWY7XG4gICAgICAgICAgICBjb25zdCBkaWRMb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgb25EdXJhdGlvbihzcmMsIGN1cnJlbnQuZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb250aW51ZVJlbmRlcihuZXdIYW5kbGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnQuZHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBvbkR1cmF0aW9uKHNyYywgY3VycmVudC5kdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGRpZExvYWQsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRhZyBnZXRzIHVubW91bnRlZCwgY2xlYXIgcGVuZGluZyBoYW5kbGVzIGJlY2F1c2UgdmlkZW8gbWV0YWRhdGEgaXMgbm90IGdvaW5nIHRvIGxvYWRcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgZGlkTG9hZCk7XG4gICAgICAgICAgICAgICAgY29udGludWVSZW5kZXIobmV3SGFuZGxlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIFtzcmMsIG9uRHVyYXRpb25dKTtcbiAgICB9XG4gICAgcmV0dXJuIGpzeChcInZpZGVvXCIsIHsgcmVmOiB2aWRlb1JlZiwgLi4ucHJvcHMsIG9uRXJyb3I6IG9uRXJyb3IgfSk7XG59O1xuY29uc3QgVmlkZW9Gb3JSZW5kZXJpbmcgPSBmb3J3YXJkUmVmKFZpZGVvRm9yUmVuZGVyaW5nRm9yd2FyZEZ1bmN0aW9uKTtcblxuY29uc3QgVmlkZW9Gb3J3YXJkaW5nRnVuY3Rpb24gPSAocHJvcHMsIHJlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHN0YXJ0RnJvbSwgZW5kQXQsIC4uLm90aGVyUHJvcHMgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgbG9vcCwgLi4ucHJvcHNPdGhlclRoYW5Mb29wIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IGZwcyB9ID0gdXNlVmlkZW9Db25maWcoKTtcbiAgICBjb25zdCBlbnZpcm9ubWVudCA9IGdldFJlbW90aW9uRW52aXJvbm1lbnQoKTtcbiAgICBjb25zdCB7IGR1cmF0aW9ucywgc2V0RHVyYXRpb25zIH0gPSB1c2VDb250ZXh0KER1cmF0aW9uc0NvbnRleHQpO1xuICAgIGlmICh0eXBlb2YgcmVmID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3N0cmluZyByZWZzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgcHJvcHMuc3JjICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBUaGUgXFxgPFZpZGVvPlxcYCB0YWcgcmVxdWlyZXMgYSBzdHJpbmcgZm9yIFxcYHNyY1xcYCwgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KHByb3BzLnNyYyl9IGluc3RlYWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IG9uRHVyYXRpb24gPSB1c2VDYWxsYmFjaygoc3JjLCBkdXJhdGlvbkluU2Vjb25kcykgPT4ge1xuICAgICAgICBzZXREdXJhdGlvbnMoeyB0eXBlOiAnZ290LWR1cmF0aW9uJywgZHVyYXRpb25JblNlY29uZHMsIHNyYyB9KTtcbiAgICB9LCBbc2V0RHVyYXRpb25zXSk7XG4gICAgaWYgKGxvb3AgJiYgcHJvcHMuc3JjICYmIGR1cmF0aW9uc1tnZXRBYnNvbHV0ZVNyYyhwcm9wcy5zcmMpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IG1lZGlhRHVyYXRpb24gPSBkdXJhdGlvbnNbZ2V0QWJzb2x1dGVTcmMocHJvcHMuc3JjKV0gKiBmcHM7XG4gICAgICAgIHJldHVybiAoanN4KExvb3AsIHsgZHVyYXRpb25JbkZyYW1lczogY2FsY3VsYXRlTG9vcER1cmF0aW9uKHtcbiAgICAgICAgICAgICAgICBlbmRBdCxcbiAgICAgICAgICAgICAgICBtZWRpYUR1cmF0aW9uLFxuICAgICAgICAgICAgICAgIHBsYXliYWNrUmF0ZTogKF9hID0gcHJvcHMucGxheWJhY2tSYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLFxuICAgICAgICAgICAgICAgIHN0YXJ0RnJvbSxcbiAgICAgICAgICAgIH0pLCBsYXlvdXQ6IFwibm9uZVwiLCBjaGlsZHJlbjoganN4KFZpZGVvLCB7IC4uLnByb3BzT3RoZXJUaGFuTG9vcCwgcmVmOiByZWYgfSkgfSkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHN0YXJ0RnJvbSAhPT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGVuZEF0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YWxpZGF0ZVN0YXJ0RnJvbVByb3BzKHN0YXJ0RnJvbSwgZW5kQXQpO1xuICAgICAgICBjb25zdCBzdGFydEZyb21GcmFtZU5vID0gc3RhcnRGcm9tICE9PSBudWxsICYmIHN0YXJ0RnJvbSAhPT0gdm9pZCAwID8gc3RhcnRGcm9tIDogMDtcbiAgICAgICAgY29uc3QgZW5kQXRGcmFtZU5vID0gZW5kQXQgIT09IG51bGwgJiYgZW5kQXQgIT09IHZvaWQgMCA/IGVuZEF0IDogSW5maW5pdHk7XG4gICAgICAgIHJldHVybiAoanN4KFNlcXVlbmNlLCB7IGxheW91dDogXCJub25lXCIsIGZyb206IDAgLSBzdGFydEZyb21GcmFtZU5vLCBzaG93SW5UaW1lbGluZTogZmFsc2UsIGR1cmF0aW9uSW5GcmFtZXM6IGVuZEF0RnJhbWVObywgY2hpbGRyZW46IGpzeChWaWRlbywgeyAuLi5vdGhlclByb3BzLCByZWY6IHJlZiB9KSB9KSk7XG4gICAgfVxuICAgIHZhbGlkYXRlTWVkaWFQcm9wcyhwcm9wcywgJ1ZpZGVvJyk7XG4gICAgaWYgKGVudmlyb25tZW50LmlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHJldHVybiAoanN4KFZpZGVvRm9yUmVuZGVyaW5nLCB7IG9uRHVyYXRpb246IG9uRHVyYXRpb24sIC4uLm90aGVyUHJvcHMsIHJlZjogcmVmIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goVmlkZW9Gb3JEZXZlbG9wbWVudCwgeyBvbmx5V2FybkZvck1lZGlhU2Vla2luZ0Vycm9yOiBmYWxzZSwgLi4ub3RoZXJQcm9wcywgcmVmOiByZWYsIG9uRHVyYXRpb246IG9uRHVyYXRpb24gfSkpO1xufTtcbmNvbnN0IGZvcndhcmQgPSBmb3J3YXJkUmVmO1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gYWxsb3dzIHlvdSB0byBpbmNsdWRlIGEgdmlkZW8gZmlsZSBpbiB5b3VyIFJlbW90aW9uIHByb2plY3QuIEl0IHdyYXBzIHRoZSBuYXRpdmUgSFRNTFZpZGVvRWxlbWVudC5cbiAqIEBzZWUgW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzL3ZpZGVvKVxuICovXG5jb25zdCBWaWRlbyA9IGZvcndhcmQoVmlkZW9Gb3J3YXJkaW5nRnVuY3Rpb24pO1xuXG5jaGVja011bHRpcGxlUmVtb3Rpb25WZXJzaW9ucygpO1xuY29uc3QgRXhwZXJpbWVudGFsID0ge1xuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIGlzIGEgc3BlY2lhbCBjb21wb25lbnQgdGhhdCB3aWxsIGNhdXNlIFJlbW90aW9uIHRvIG9ubHkgcGFydGlhbGx5IGNhcHR1cmUgdGhlIGZyYW1lIG9mIHRoZSB2aWRlby5cbiAgICAgKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9jbGlwcGVyKVxuICAgICAqL1xuICAgIENsaXBwZXIsXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoaXMgaXMgYSBzcGVjaWFsIGNvbXBvbmVudCwgdGhhdCwgd2hlbiByZW5kZXJlZCwgd2lsbCBza2lwIHJlbmRlcmluZyB0aGUgZnJhbWUgYWx0b2dldGhlci5cbiAgICAgKiBAc2VlIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5yZW1vdGlvbi5kZXYvZG9jcy9udWxsKVxuICAgICAqL1xuICAgIE51bGwsXG4gICAgdXNlSXNQbGF5ZXIsXG59O1xuY29uc3QgcHJveHlPYmogPSB7fTtcbmNvbnN0IENvbmZpZyA9IG5ldyBQcm94eShwcm94eU9iaiwge1xuICAgIGdldChfLCBwcm9wKSB7XG4gICAgICAgIGlmIChwcm9wID09PSAnQnVuZGxpbmcnIHx8XG4gICAgICAgICAgICBwcm9wID09PSAnUmVuZGVyaW5nJyB8fFxuICAgICAgICAgICAgcHJvcCA9PT0gJ0xvZycgfHxcbiAgICAgICAgICAgIHByb3AgPT09ICdQdXBwZXRlZXInIHx8XG4gICAgICAgICAgICBwcm9wID09PSAnT3V0cHV0Jykge1xuICAgICAgICAgICAgcmV0dXJuIENvbmZpZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gIFRoZSBDTEkgY29uZmlndXJhdGlvbiBoYXMgYmVlbiBleHRyYWN0ZWQgZnJvbSBSZW1vdGlvbiBDb3JlLicpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdVcGRhdGUgdGhlIGltcG9ydCBmcm9tIHRoZSBjb25maWcgZmlsZTonKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCctIERlbGV0ZTonKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignaW1wb3J0IHtDb25maWd9IGZyb20gXCJyZW1vdGlvblwiOycpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCcrIFJlcGxhY2U6Jyk7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ2ltcG9ydCB7Q29uZmlnfSBmcm9tIFwiQHJlbW90aW9uL2NsaS9jb25maWdcIjsnKTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigpO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIGh0dHBzOi8vd3d3LnJlbW90aW9uLmRldi9kb2NzLzQtMC1taWdyYXRpb24uJyk7XG4gICAgICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBBYnNvbHV0ZUZpbGwsIEF1ZGlvLCBDb21wb3NpdGlvbiwgQ29uZmlnLCBFYXNpbmcsIEV4cGVyaW1lbnRhbCwgRm9sZGVyLCBGb2xkZXJDb250ZXh0LCBGcmVlemUsIElGcmFtZSwgSW1nLCBJbnRlcm5hbHMsIExvb3AsIE9mZnRocmVhZFZpZGVvLCBTZXF1ZW5jZSwgU2VyaWVzLCBTdGlsbCwgVkVSU0lPTiwgVmlkZW8sIGNhbmNlbFJlbmRlciwgY29udGludWVSZW5kZXIsIGRlbGF5UmVuZGVyLCBnZXRJbnB1dFByb3BzLCBnZXRSZW1vdGlvbkVudmlyb25tZW50LCBnZXRTdGF0aWNGaWxlcywgaW50ZXJwb2xhdGUsIGludGVycG9sYXRlQ29sb3JzLCBtZWFzdXJlU3ByaW5nLCBwcmVmZXRjaCwgcmFuZG9tLCByZWdpc3RlclJvb3QsIHNwcmluZywgc3RhdGljRmlsZSwgdXNlQ3VycmVudEZyYW1lLCB1c2VWaWRlb0NvbmZpZyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../../node_modules/.pnpm/remotion@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/remotion/dist/esm/index.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/../use-remotion-player/dist/index.mjs":
/*!*********************************************!*\
  !*** ../use-remotion-player/dist/index.mjs ***!
  \*********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CustomizablePlayer: function() { return /* binding */ CustomizablePlayer; },\n/* harmony export */   useRemotionPlayer: function() { return /* binding */ useRemotionPlayer; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _remotion_player__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @remotion/player */ \"(app-pages-browser)/../../node_modules/.pnpm/@remotion+player@4.0.47_react-dom@18.2.0_react@18.2.0/node_modules/@remotion/player/dist/esm/index.mjs\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react/jsx-runtime */ \"(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/compiled/react/jsx-runtime.js\");\n// src/use-remotion-player.ts\n\nvar useRemotionPlayer = (playerRef, {\n  onSeeked,\n  onPause,\n  onPlay,\n  onRateChange,\n  onScaleChange,\n  onVolumeChange,\n  onEnded,\n  onError,\n  onTimeUpdate,\n  onFrameUpdate,\n  onFullscreenChange,\n  onMuteChange\n}) => {\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (!(playerRef == null ? void 0 : playerRef.current))\n      return;\n    const { current } = playerRef;\n    if (onScaleChange) {\n      current.addEventListener(\"scalechange\", onScaleChange);\n    }\n    if (onSeeked) {\n      current.addEventListener(\"seeked\", onSeeked);\n    }\n    if (onPause) {\n      current.addEventListener(\"pause\", onPause);\n    }\n    if (onPlay) {\n      current.addEventListener(\"play\", onPlay);\n    }\n    if (onRateChange) {\n      current.addEventListener(\"ratechange\", onRateChange);\n    }\n    if (onVolumeChange) {\n      current.addEventListener(\"volumechange\", onVolumeChange);\n    }\n    if (onEnded) {\n      current.addEventListener(\"ended\", onEnded);\n    }\n    if (onError) {\n      current.addEventListener(\"error\", onError);\n    }\n    if (onTimeUpdate) {\n      current.addEventListener(\"timeupdate\", onTimeUpdate);\n    }\n    if (onFrameUpdate) {\n      current.addEventListener(\"frameupdate\", onFrameUpdate);\n    }\n    if (onFullscreenChange) {\n      current.addEventListener(\"fullscreenchange\", onFullscreenChange);\n    }\n    if (onMuteChange) {\n      current.addEventListener(\"mutechange\", onMuteChange);\n    }\n    return () => {\n      if (onScaleChange) {\n        current.removeEventListener(\"scalechange\", onScaleChange);\n      }\n      if (onSeeked) {\n        current.removeEventListener(\"seeked\", onSeeked);\n      }\n      if (onPause) {\n        current.removeEventListener(\"pause\", onPause);\n      }\n      if (onPlay) {\n        current.removeEventListener(\"play\", onPlay);\n      }\n      if (onRateChange) {\n        current.removeEventListener(\"ratechange\", onRateChange);\n      }\n      if (onVolumeChange) {\n        current.removeEventListener(\"volumechange\", onVolumeChange);\n      }\n      if (onEnded) {\n        current.removeEventListener(\"ended\", onEnded);\n      }\n      if (onError) {\n        current.removeEventListener(\"error\", onError);\n      }\n      if (onTimeUpdate) {\n        current.removeEventListener(\"timeupdate\", onTimeUpdate);\n      }\n      if (onFrameUpdate) {\n        current.removeEventListener(\"frameupdate\", onFrameUpdate);\n      }\n      if (onFullscreenChange) {\n        current.removeEventListener(\"fullscreenchange\", onFullscreenChange);\n      }\n      if (onMuteChange) {\n        current.removeEventListener(\"mutechange\", onMuteChange);\n      }\n    };\n  }, [\n    onEnded,\n    onError,\n    onFrameUpdate,\n    onFullscreenChange,\n    onMuteChange,\n    onPause,\n    onPlay,\n    onRateChange,\n    onScaleChange,\n    onSeeked,\n    onTimeUpdate,\n    onVolumeChange,\n    playerRef\n  ]);\n};\n\n// src/CustomizablePlayer.tsx\n\n\n\n\nvar PlayerInternal = ({\n  onSeeked,\n  onPause,\n  onPlay,\n  onRateChange,\n  onScaleChange,\n  onVolumeChange,\n  onEnded,\n  onError,\n  onTimeUpdate,\n  onFrameUpdate,\n  onFullscreenChange,\n  onMuteChange,\n  ...props\n}, forwardedRef) => {\n  const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  if (forwardedRef) {\n    if (typeof forwardedRef === \"function\") {\n      forwardedRef(ref.current);\n    } else {\n      forwardedRef.current = ref.current;\n    }\n  }\n  useRemotionPlayer(ref, {\n    onSeeked,\n    onPause,\n    onPlay,\n    onRateChange,\n    onScaleChange,\n    onVolumeChange,\n    onEnded,\n    onError,\n    onTimeUpdate,\n    onFrameUpdate,\n    onFullscreenChange,\n    onMuteChange\n  });\n  return /* @__PURE__ */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_1__.jsx)(_remotion_player__WEBPACK_IMPORTED_MODULE_2__.Player, { ...props, ref });\n};\nvar CustomizablePlayer = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(PlayerInternal);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi91c2UtcmVtb3Rpb24tcGxheWVyL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDK0I7QUFDSTtBQUNPO0FBQ0Y7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxjQUFjLDZDQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx5QkFBeUIsc0RBQUcsQ0FBQyxvREFBTSxJQUFJLGVBQWU7QUFDdEQ7QUFDQSx5QkFBeUIsaURBQVU7QUFJakMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3VzZS1yZW1vdGlvbi1wbGF5ZXIvZGlzdC9pbmRleC5tanM/ZjFiYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXNlLXJlbW90aW9uLXBsYXllci50c1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG52YXIgdXNlUmVtb3Rpb25QbGF5ZXIgPSAocGxheWVyUmVmLCB7XG4gIG9uU2Vla2VkLFxuICBvblBhdXNlLFxuICBvblBsYXksXG4gIG9uUmF0ZUNoYW5nZSxcbiAgb25TY2FsZUNoYW5nZSxcbiAgb25Wb2x1bWVDaGFuZ2UsXG4gIG9uRW5kZWQsXG4gIG9uRXJyb3IsXG4gIG9uVGltZVVwZGF0ZSxcbiAgb25GcmFtZVVwZGF0ZSxcbiAgb25GdWxsc2NyZWVuQ2hhbmdlLFxuICBvbk11dGVDaGFuZ2Vcbn0pID0+IHtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIShwbGF5ZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHBsYXllclJlZi5jdXJyZW50KSlcbiAgICAgIHJldHVybjtcbiAgICBjb25zdCB7IGN1cnJlbnQgfSA9IHBsYXllclJlZjtcbiAgICBpZiAob25TY2FsZUNoYW5nZSkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwic2NhbGVjaGFuZ2VcIiwgb25TY2FsZUNoYW5nZSk7XG4gICAgfVxuICAgIGlmIChvblNlZWtlZCkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uU2Vla2VkKTtcbiAgICB9XG4gICAgaWYgKG9uUGF1c2UpIHtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIG9uUGF1c2UpO1xuICAgIH1cbiAgICBpZiAob25QbGF5KSB7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIG9uUGxheSk7XG4gICAgfVxuICAgIGlmIChvblJhdGVDaGFuZ2UpIHtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJhdGVjaGFuZ2VcIiwgb25SYXRlQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKG9uVm9sdW1lQ2hhbmdlKSB7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIiwgb25Wb2x1bWVDaGFuZ2UpO1xuICAgIH1cbiAgICBpZiAob25FbmRlZCkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgb25FbmRlZCk7XG4gICAgfVxuICAgIGlmIChvbkVycm9yKSB7XG4gICAgICBjdXJyZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICB9XG4gICAgaWYgKG9uVGltZVVwZGF0ZSkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLCBvblRpbWVVcGRhdGUpO1xuICAgIH1cbiAgICBpZiAob25GcmFtZVVwZGF0ZSkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiZnJhbWV1cGRhdGVcIiwgb25GcmFtZVVwZGF0ZSk7XG4gICAgfVxuICAgIGlmIChvbkZ1bGxzY3JlZW5DaGFuZ2UpIHtcbiAgICAgIGN1cnJlbnQuYWRkRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICB9XG4gICAgaWYgKG9uTXV0ZUNoYW5nZSkge1xuICAgICAgY3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwibXV0ZWNoYW5nZVwiLCBvbk11dGVDaGFuZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKG9uU2NhbGVDaGFuZ2UpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2NhbGVjaGFuZ2VcIiwgb25TY2FsZUNoYW5nZSk7XG4gICAgICB9XG4gICAgICBpZiAob25TZWVrZWQpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Vla2VkXCIsIG9uU2Vla2VkKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblBhdXNlKSB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBhdXNlXCIsIG9uUGF1c2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9uUGxheSkge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwbGF5XCIsIG9uUGxheSk7XG4gICAgICB9XG4gICAgICBpZiAob25SYXRlQ2hhbmdlKSB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJhdGVjaGFuZ2VcIiwgb25SYXRlQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblZvbHVtZUNoYW5nZSkge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2b2x1bWVjaGFuZ2VcIiwgb25Wb2x1bWVDaGFuZ2UpO1xuICAgICAgfVxuICAgICAgaWYgKG9uRW5kZWQpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZW5kZWRcIiwgb25FbmRlZCk7XG4gICAgICB9XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBjdXJyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIGlmIChvblRpbWVVcGRhdGUpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidGltZXVwZGF0ZVwiLCBvblRpbWVVcGRhdGUpO1xuICAgICAgfVxuICAgICAgaWYgKG9uRnJhbWVVcGRhdGUpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZnJhbWV1cGRhdGVcIiwgb25GcmFtZVVwZGF0ZSk7XG4gICAgICB9XG4gICAgICBpZiAob25GdWxsc2NyZWVuQ2hhbmdlKSB7XG4gICAgICAgIGN1cnJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZ1bGxzY3JlZW5jaGFuZ2VcIiwgb25GdWxsc2NyZWVuQ2hhbmdlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbk11dGVDaGFuZ2UpIHtcbiAgICAgICAgY3VycmVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibXV0ZWNoYW5nZVwiLCBvbk11dGVDaGFuZ2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtcbiAgICBvbkVuZGVkLFxuICAgIG9uRXJyb3IsXG4gICAgb25GcmFtZVVwZGF0ZSxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UsXG4gICAgb25NdXRlQ2hhbmdlLFxuICAgIG9uUGF1c2UsXG4gICAgb25QbGF5LFxuICAgIG9uUmF0ZUNoYW5nZSxcbiAgICBvblNjYWxlQ2hhbmdlLFxuICAgIG9uU2Vla2VkLFxuICAgIG9uVGltZVVwZGF0ZSxcbiAgICBvblZvbHVtZUNoYW5nZSxcbiAgICBwbGF5ZXJSZWZcbiAgXSk7XG59O1xuXG4vLyBzcmMvQ3VzdG9taXphYmxlUGxheWVyLnRzeFxuaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBmb3J3YXJkUmVmIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBQbGF5ZXIgfSBmcm9tIFwiQHJlbW90aW9uL3BsYXllclwiO1xuaW1wb3J0IHsganN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG52YXIgUGxheWVySW50ZXJuYWwgPSAoe1xuICBvblNlZWtlZCxcbiAgb25QYXVzZSxcbiAgb25QbGF5LFxuICBvblJhdGVDaGFuZ2UsXG4gIG9uU2NhbGVDaGFuZ2UsXG4gIG9uVm9sdW1lQ2hhbmdlLFxuICBvbkVuZGVkLFxuICBvbkVycm9yLFxuICBvblRpbWVVcGRhdGUsXG4gIG9uRnJhbWVVcGRhdGUsXG4gIG9uRnVsbHNjcmVlbkNoYW5nZSxcbiAgb25NdXRlQ2hhbmdlLFxuICAuLi5wcm9wc1xufSwgZm9yd2FyZGVkUmVmKSA9PiB7XG4gIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgaWYgKGZvcndhcmRlZFJlZikge1xuICAgIGlmICh0eXBlb2YgZm9yd2FyZGVkUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvcndhcmRlZFJlZihyZWYuY3VycmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvcndhcmRlZFJlZi5jdXJyZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgfVxuICB9XG4gIHVzZVJlbW90aW9uUGxheWVyKHJlZiwge1xuICAgIG9uU2Vla2VkLFxuICAgIG9uUGF1c2UsXG4gICAgb25QbGF5LFxuICAgIG9uUmF0ZUNoYW5nZSxcbiAgICBvblNjYWxlQ2hhbmdlLFxuICAgIG9uVm9sdW1lQ2hhbmdlLFxuICAgIG9uRW5kZWQsXG4gICAgb25FcnJvcixcbiAgICBvblRpbWVVcGRhdGUsXG4gICAgb25GcmFtZVVwZGF0ZSxcbiAgICBvbkZ1bGxzY3JlZW5DaGFuZ2UsXG4gICAgb25NdXRlQ2hhbmdlXG4gIH0pO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGpzeChQbGF5ZXIsIHsgLi4ucHJvcHMsIHJlZiB9KTtcbn07XG52YXIgQ3VzdG9taXphYmxlUGxheWVyID0gZm9yd2FyZFJlZihQbGF5ZXJJbnRlcm5hbCk7XG5leHBvcnQge1xuICBDdXN0b21pemFibGVQbGF5ZXIsXG4gIHVzZVJlbW90aW9uUGxheWVyXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../use-remotion-player/dist/index.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/../../node_modules/.pnpm/next@13.5.4_react-dom@18.2.0_react@18.2.0/node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Fmohit%2Fdev%2Fopen-source%2Fuse-remotion-player%2Fpackages%2Fexample%2Fapp%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);